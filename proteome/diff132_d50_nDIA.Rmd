---
title: "diff132_d50_nDIA"
output: html_document
date: "`r Sys.Date()`"
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# I. load packackes & set project directory
```{r setup, include=FALSE}
# install.packages(c(
#   "plyr", "ggrepel", "ggpubr", "ggpmisc", "patchwork", "gghighlight", 
#   "ggVennDiagram", "UpSetR", "ComplexUpset", "pheatmap", "circlize", 
#   "magick", "viridis", "NatParksPalettes", "limma", "bigstatsr", 
#   "irlba", "ggbiplot", "plotly", "Cairo", "devtools", "lintr"
# ))

# Core Data Manipulation & Tidyverse
library(tidyverse)     # Includes ggplot2, dplyr, tidyr, readr, tibble, purrr, stringr, forcats
library(plyr)
library(dplyr)
library(data.table)
library(broom)
library(rlang)
library(tidyr)

# Visualization: ggplot2 Extensions & Plots
library(ggplot2)
library(ggrepel)
library(ggpubr)
library(ggpmisc)
library(cowplot)
library(patchwork)
library(scales)
library(gghighlight)
library(superheat)
library(ggVennDiagram)
library(UpSetR)
library(ComplexUpset)

# Heatmaps & Clustering
library(pheatmap)
library(RColorBrewer)
library(circlize)
library(magick)

# Color Palettes
library(viridis)
library(NatParksPalettes)


# Dimension Reduction / Statistics
library(limma)
library(bigstatsr)
library(irlba)
library(ggbiplot)

# Interactive & Advanced Plotting
library(plotly)
library(circlize)

# Utilities / Dev / Misc
library(grid)
library(gridExtra)
library(Cairo)
#library(png)
library(devtools)
library(lintr)

```


# output dirs overview:
```{r}
out_dir_d50_QC <- "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/QC"
dir.create(out_dir_d50_QC, recursive = TRUE, showWarnings = FALSE)

out_dir_d50_ascd_avg <- "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/ascendingAvg"
dir.create(out_dir_d50_ascd_avg, recursive = TRUE, showWarnings = FALSE)

out_dir_d50_heatmaps <- "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/heatmaps"
dir.create(out_dir_d50_heatmaps, recursive = TRUE, showWarnings = FALSE)

out_dir_d50_dataframes <- "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/dataframes"
dir.create(out_dir_d50_dataframes, recursive = TRUE, showWarnings = FALSE)

out_dir_d50_violins <- "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/Organelle_Violin"
dir.create(out_dir_d50_violins, recursive = TRUE, showWarnings = FALSE)

out_dir_d50_SphMut <- "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/SphMut"
dir.create(out_dir_d50_SphMut, recursive = TRUE, showWarnings = FALSE)

out_dir_d50_DisClass <- "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/DisClass"
dir.create(out_dir_d50_DisClass, recursive = TRUE, showWarnings = FALSE)

out_dir_d50_DisClass_chord <- "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/DisClass/chorddiagram"
dir.create(out_dir_d50_DisClass_chord, recursive = TRUE, showWarnings = FALSE)

out_dir_d50_GRN <- "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/GRN"
dir.create(out_dir_d50_GRN, recursive = TRUE, showWarnings = FALSE)

out_dir_d50_CrossCorr <- "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/Organelle_CrossCorr"
dir.create(out_dir_d50_CrossCorr, recursive = TRUE, showWarnings = FALSE)

out_dir_d50_CrossCorr_annotavg <- "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/Organelle_CrossCorr/annot_avg"
dir.create(out_dir_d50_CrossCorr_annotavg, recursive = TRUE, showWarnings = FALSE)

out_dir_d50_CrossCorr_nMOSTGOavgannot <- "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/Organelle_CrossCorr/nMOSTGOavgannnot"
dir.create(out_dir_d50_CrossCorr_nMOSTGOavgannot, recursive = TRUE, showWarnings = FALSE)

out_dir_d50_CrossCorr_genoavg <- "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/Organelle_CrossCorr/geno_avg"
dir.create(out_dir_d50_CrossCorr_genoavg, recursive = TRUE, showWarnings = FALSE)

out_dir_d50_CrossCorr_bubble <- "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/Organelle_CrossCorr/bubble"
dir.create(out_dir_d50_CrossCorr_bubble, recursive = TRUE, showWarnings = FALSE)

out_dir_d50_CrossCorr_bubble_ASAH1 <- "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/Organelle_CrossCorr/ASAH1_c23d30d50"
dir.create(out_dir_d50_CrossCorr_bubble_ASAH1, recursive = TRUE, showWarnings = FALSE)

out_dir_d50_corrProtein <- "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/proteincorr"
dir.create(out_dir_d50_corrProtein, recursive = TRUE, showWarnings = FALSE)

out_dir_d50_SynPRM <- "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/SynPRM"
dir.create(out_dir_d50_SynPRM, recursive = TRUE, showWarnings = FALSE)

out_dir_d50_LinReg <- "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/LinReg"
dir.create(out_dir_d50_LinReg, recursive = TRUE, showWarnings = FALSE)

out_dir_d50_LinReg_limma <- "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/LinReg/limma_all_coef"
dir.create(out_dir_d50_LinReg_limma, recursive = TRUE, showWarnings = FALSE)

out_dir_d50_LinReg_limma_select <- "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/LinReg/limma_select"
dir.create(out_dir_d50_LinReg_limma_select, recursive = TRUE, showWarnings = FALSE)

out_dir_d50_nMOST_nDIAcorrelation <- "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/nMOST-nDIAcorrelation"
dir.create(out_dir_d50_nMOST_nDIAcorrelation, recursive = TRUE, showWarnings = FALSE)

out_dir_d50_nMOST_nDIAcorrelationS_single <- "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/nMOST-nDIAcorrelation/SingleGeno"
dir.create(out_dir_d50_nMOST_nDIAcorrelationS_single, recursive = TRUE, showWarnings = FALSE)

out_dir_d50_nMOST_nDIAcorrelationS_OrganelleComp <- "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/nMOST-nDIAcorrelation/HeLa_Neuron_SelectAnnotation_comparisons"
dir.create(out_dir_d50_nMOST_nDIAcorrelationS_OrganelleComp, recursive = TRUE, showWarnings = FALSE)

out_dir_d50_nMOST_nDIAcorrelationS_Circos <- "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/nMOST-nDIAcorrelation/HeLa_Neuron_SelectAnnotation_comparisons"
dir.create(out_dir_d50_nMOST_nDIAcorrelationS_Circos, recursive = TRUE, showWarnings = FALSE)


```



# II. Experimental Background: nDIA proteomics iN & iDA d30+d50
- Samples are in triplicates whole-cell samples from 12-well dishes.
- day 30 of in vitro differentiation of iN and iDA:
Genotypes: Ctrl, ASAH1, CLN11.GRN, GBA1, SMPD1

- day 50 of in vitro differentiation of iN and iDA:
Genotypes: Ctrl, ASAH1, CLN1.PPT1, CLN10.CTSD, CLN11.GRN, CLN12.ATP13A2, CLN12.ATP13A2, CLN13.CTSF,CLN2.TPP1, CLN3, CLN4.DNAJC5, CLN5, CLN6, CLN7.MFSD8, CLN8, CTNS, GAA, GBA, GLB1, HEXA, HEXB,LIPA, MCOLN1.TRPML1, NPC1, NPC2, PSAP, SMPD1

run on Thermo Orbitrap Astral, nDIA, hrMS2 
        

# III. Circos plot for neuroLSD 
```{r}
#read the csv file
#read in first column (==gene) as row title
LSD <- read.csv('/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD/Proteomics_Lipidomics/Data_forplots/Circos/LSD_circos.csv', 
                header=T, row.names=1)

#convert the table to a martix
data <- as.matrix(LSD)

#create a chord diagram
chordDiagram(data)

############## CIRCOS Plot with confirmed KOs #####################
## plot only confirmed KOs in color, rest of genes in grey/ per disease group
## save plot as pdf 

# set colors for disease groups
col = c(Sphigolipidoses="#D53E4F",	Mucopolysaccharidoses="#F46D43",	Glycoproteinoses="#FDAE61", Neuronal.ceroid.lipofucinoses="#FEE08B",	
        Integral.membrane.protein.disorders="#E6F598",	PTM.defects="#ABDDA4",	Lipid.storage.diseases= "#66C2A5", 
        AGA= "grey76", ARSA= "grey76", ARSB= "grey76", ASAH1="#D53E4F", CLN1.PPT1= "#FEE08B", CLN10.CTSD="#FEE08B", CLN11.GRN="#FEE08B", CLN12.ATP13A2="#FEE08B", CLN12.ATP13A2="#E6F598", CLN13.CTSF="#FEE08B", CLN14.KCTD7="grey76", CLN2.TPP1="#FEE08B", CLN3="#FEE08B", CLN3="#E6F598", CLN4.DNAJC5="#FEE08B", CLN5="#FEE08B", CLN6="#FEE08B", CLN7.MFSD8="#FEE08B", CLN8="#FEE08B", CTNS="#E6F598", CTSA="grey76", FUCA="grey76", GAA="#66C2A5", GALC="grey76", GALNS="#F46D43", GBA="#D53E4F", GLA="grey76", GLB1="#D53E4F", GM2A="grey76", GNPTAB="grey76", GNPTG="grey76", GNS="grey76", GUSB="grey76", HEXA="#D53E4F", HEXB="#D53E4F", HGSNAT="grey76", HYAL1="grey76",       IDS="grey76", IDUA="grey76", LAMP2="grey76", LIPA="#66C2A5", MAN2B1="grey76", MANBA="grey76", MCOLN1="#E6F598", NAGA="grey76", NAGLU="grey76", NEU1="grey76", NPC1="#E6F598", NPC2="#E6F598", PSAP="#D53E4F", SCARB2="grey76", SGSH="grey76", SLC17A5="grey76",SMPD1="#D53E4F", SUMF1="grey76")


# Set output path and size
pdf("/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/LSD_circos_plot_confirmed_KOs.pdf", width = 10, height = 10)  # adjust size as needed

# Plot: chord diagram
chordDiagram(data, 
             grid.col = col, 
             annotationTrack = "grid", 
             preAllocateTracks = 1, 
             transparency = 0.1,
             link.lwd = 1,    
             link.lty = 1,    
             link.border = 1)

# Add labels
circos.trackPlotRegion(track.index = 2, panel.fun = function(x, y) {
  xlim = get.cell.meta.data("xlim")
  ylim = get.cell.meta.data("ylim")
  sector.name = get.cell.meta.data("sector.index")
  
  circos.text(mean(xlim), ylim[1] + 2.5, sector.name, 
              facing = "clockwise", niceFacing = TRUE, 
              adj = c(0, 0.5), cex = 0.6)
}, bg.border = "black")

# Finish writing the PDF
dev.off()


```


# IV. Based checks on data 
### IVa. PCA plots of data
plot PCA plots to check data landscape on top level 
Have following genotypes and cells in there
iN, DA, pool (== QC mmaker)
3 replicates for genotypes 

```{r}
# --------------------------------------------------- #
# PCA plots for supplements  
# --------------------------------------------------- #

# --- Step 1: Read in the data from the CSV file
# The CSV file has been pre-processed in Excel to replace all NA values with 0.
diff132_d50_PCA_df_full <- read.csv('/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/datasets/lsd_pro_long.csv', 
                                    header = TRUE, sep = ',', stringsAsFactors = FALSE)

# --- Step 1.5: Fill NA or empty values in 'neuron' and 'replicate' with QC info
diff132_d50_PCA_df_full <- diff132_d50_PCA_df_full %>%
  mutate(
    is_qc = is.na(neuron) | neuron == "",
    neuron = ifelse(is_qc, "QC", neuron),
    replicate = ifelse(is_qc, as.character(seq_len(sum(is_qc))), replicate)
  )


# --- Step 2: Inspect the structure of the data
# This helps to understand the data types and identify which columns to retain or remove.
str(diff132_d50_PCA_df_full)


# --- Step 3: Remove unnecessary columns
# Assuming columns 1, 2, 4, 5, and 10 are not needed for PCA, they are removed.
diff132_d50_PCA_df <- diff132_d50_PCA_df_full[, -c(1,2,4,6,7,13,14)]


# --- Step 4: Identify and remove rows with missing or empty 'Genes' entries
# It's crucial to ensure that each gene has a valid identifier for accurate analysis.
# Identify problematic rows where 'Genes' is NA or an empty string
problematic_rows <- diff132_d50_PCA_df %>%
  filter(is.na(Genes) | Genes == "")

# Remove these problematic rows from the dataset
cleaned_df <- diff132_d50_PCA_df %>%
  filter(!is.na(Genes) & Genes != "") %>%       # remove empty gene names
  filter(!is.na(quan))                          # remove missing values in quan


# --- Step 5: Reshape the data from long to wide format
# Each gene will become a separate column, with 'quan' values as the data points.
# Missing values are filled with 0, and duplicate entries are summed.
d50_df_wide <- cleaned_df %>%
  group_by(Genes, genotype, neuron, day, replicate) %>%  # keep day info here
  summarise(across(quan, sum), .groups = "drop") %>%
  pivot_wider(
    names_from = Genes, # Column whose unique values will become new column names
    values_from = quan, # Column providing values for the new columns
    values_fill = list(quan = 0), # Fill missing values with 0
    values_fn = list(quan = sum) # Sum values if there are duplicates
  )


# --- Step 6: Select only numeric columns for PCA
# Keep sample-level metadata
sample_metadata <- d50_df_wide %>%
  select(genotype, neuron, day, replicate)

# Non-numeric data (like sample IDs) are excluded to prevent errors in PCA computation.
d50_numeric_data <- d50_df_wide %>%
  select_if(is.numeric)


# --- Step 7: Perform Principal Component Analysis (PCA)
# Step 7.1: PCA calculation is too large.. have to find different approach 
  # The data is scaled to ensure each variable contributes equally to the analysis.
  # Use irlba::prcomp_irlba() for approximate PCA
  # Much less memory required. You specify how many PCs (n) you want.
pca_res_d50 <- prcomp_irlba(d50_numeric_data, n = 10, scale. = TRUE)


# --- Step 8: Extract PCA scores into a data frame
# These scores represent the principal components for each sample.
pca_scores_d50 <- as.data.frame(pca_res_d50$x)
pca_scores_d50 <- cbind(sample_metadata, pca_scores_d50)
pca_scores_d50$day <- factor(pca_scores_d50$day)


# --- Step 9: Add metadata back into the PCA scores for plotting
# This allows for visualization of the PCA results with respect to sample characteristics.
pca_scores_d50$genotype <- d50_df_wide$genotype
pca_scores_d50$neuron   <- d50_df_wide$neuron
pca_scores_d50$day <- d50_df_wide$day


# --- Step 10. PLOTTING 
# Determine the number of unique genotypes and neurons
n_genotypes <- length(unique(pca_scores_d50$genotype))
n_neurons <- length(unique(pca_scores_d50$neuron))
n_days <- length(unique(pca_scores_d50$day))

# Create color palettes
genotype_colors <- colorRampPalette(brewer.pal(11, "RdYlBu"))(n_genotypes)
neuron_colors <- c("#A50026", "#313695", "grey50") 
#neuron_colors <- colorRampPalette(brewer.pal(11, "RdYlBu"))(n_neurons)
day_colors <- colorRampPalette(brewer.pal(11, "RdYlBu"))(n_days)

## --- Step 10.1: Plot Colored by Genotype: Generate the first PCA plot with points colored by genotype.
# PC1 and PC2 are plotted on the x and y axes, respectively.
d50plot1 <- ggplot(pca_scores_d50, aes(x = PC1, y = PC2, color = genotype)) +
  geom_point(size = 3, alpha = 0.8) +
  geom_text_repel(
                  data = pca_scores_d50 %>% distinct(genotype, .keep_all = TRUE),
                  aes(label=genotype),
                  size = 2,                # Adjust text size as needed
                  box.padding = 0.5,       # Padding around labels
                  point.padding = 0.5,     # Padding around data points
                  max.overlaps = 200) +    # Ensure all labels are displayed
  scale_color_manual(values = genotype_colors) +
  labs(
    title = "PCA of Gene Intensities Colored by Genotype",
    x = paste0("PC1 (", round(summary(pca_res_d50)$importance[2, 1] * 100, 1), "% variance)"),
    y = paste0("PC2 (", round(summary(pca_res_d50)$importance[2, 2] * 100, 1), "% variance)")
  ) +
  coord_fixed(ratio = 1.75) +
  theme_minimal() +
     theme(
    panel.border = element_rect(color = "black", fill = NA, linewidth = 1)
  )


## --- Step 10.2: Plot Colored by Neuron: Generate the second PCA plot with points colored by neuron.
d50plot2 <- ggplot(pca_scores_d50, aes(x = PC1, y = PC2, color = neuron)) +
  geom_point(size = 3, alpha = 0.8) +
  stat_ellipse(aes(fill = neuron), geom = "polygon", alpha = 0.2, level = 0.95) + # 95% confidence ellipses
  scale_color_manual(values = neuron_colors) +
  scale_fill_manual(values = neuron_colors) +
  labs(
    title = "PCA of Gene Intensities Colored by Neuron Type",
    x = paste0("PC1 (", round(summary(pca_res_d50)$importance[2, 1] * 100, 1), "% variance)"),
    y = paste0("PC2 (", round(summary(pca_res_d50)$importance[2, 2] * 100, 1), "% variance)")
  ) +
  coord_fixed(ratio = 1) +
  theme_minimal() +
   theme(
    panel.border = element_rect(color = "black", fill = NA, linewidth = 1)
  )


## --- Step 10.3: Plot Colored by day: Generate the second PCA plot with points colored by day of differentiation
d50plot3 <- ggplot(pca_scores_d50, aes(x = PC1, y = PC2, color = factor(day))) +
  geom_point(size = 3, alpha = 0.8) +
  stat_ellipse(aes(fill = factor(day)), geom = "polygon", alpha = 0.2, level = 0.95) +
  scale_color_manual(values = day_colors) +
  scale_fill_manual(values = day_colors) +
  labs(
    title = "PCA of Gene Intensities Colored by Day of Differentiation",
    x = paste0("PC1 (", round(summary(pca_res_d50)$importance[2, 1] * 100, 1), "% variance)"),
    y = paste0("PC2 (", round(summary(pca_res_d50)$importance[2, 2] * 100, 1), "% variance)")
  ) +
  coord_fixed(ratio = 1) +
  theme_minimal() +
  theme(panel.border = element_rect(color = "black", fill = NA, linewidth = 1))



# --- Step 11. Calculate PCA for excluding QC datasets
# since the PCA is skewed when the QCs are in there, have a 2nd run on the PCA calculation where QC datasets are removed.
# remove QC from "neuron" column in d50_df_wide df and then calculate the pca again 
# Step 5: Reshape the data from long to wide format
d50_df_wide <- cleaned_df %>%
  group_by(Genes, genotype, neuron, day, replicate) %>%  # keep day info
  summarise(across(quan, sum), .groups = "drop") %>%
  pivot_wider(
    names_from = Genes,
    values_from = quan,
    values_fill = list(quan = 0),
    values_fn = list(quan = sum)
  )

## --- Step 11.1: Remove QC-labeled samples before PCA
d50_df_wide_noQC <- d50_df_wide %>%
  filter(neuron != "QC")

## --- Step 11.2: Select only numeric columns for PCA
d50_numeric_data <- d50_df_wide_noQC %>%
  select(where(is.numeric))

## --- Step 11.3: Perform PCA using memory-efficient method
pca_res_d50_noQC <- irlba::prcomp_irlba(d50_numeric_data, n = 10, scale. = TRUE)

## --- Step 11.4: Extract PCA scores and attach metadata
pca_scores_d50_noQC <- as.data.frame(pca_res_d50_noQC$x)  # not pca_res_d50
pca_scores_d50_noQC$genotype <- d50_df_wide_noQC$genotype
pca_scores_d50_noQC$neuron   <- d50_df_wide_noQC$neuron
pca_scores_d50_noQC$day      <- factor(d50_df_wide_noQC$day)


# --- Step 12. plotting of PCA etc w/o QC samples 
# Determine the number of unique genotypes and neurons
n_genotypes_noQC <- length(unique(pca_scores_d50_noQC$genotype))
n_neurons_noQC <- length(unique(pca_scores_d50_noQC$neuron))
n_days_noQC <- length(unique(pca_scores_d50_noQC$day))

# Create color palettes
genotype_colors_noQC <- colorRampPalette(brewer.pal(11, "RdYlBu"))(n_genotypes_noQC)
neuron_colors_noQC <- c("#A50026", "#313695", "grey50") 
#neuron_colors <- colorRampPalette(brewer.pal(11, "RdYlBu"))(n_neurons)
day_colors_noQC <- colorRampPalette(brewer.pal(11, "RdYlBu"))(n_days_noQC)

## --- Step 12.1: Plot Colored by Genotype
d50plot1_noQC <- ggplot(pca_scores_d50_noQC, aes(x = PC1, y = PC2, color = genotype, alpha = day)) +
  geom_point(size = 3) +
  scale_alpha_manual(values = c("30" = 0.5, "50" = 1)) + # adjust as needed 
  geom_text_repel(
                  data = pca_scores_d50_noQC %>% distinct(genotype, .keep_all = TRUE),
                  aes(label=genotype),
                  color = "black",  
                  size = 6,                # Adjust text size as needed
                  box.padding = 0.5,       # Padding around labels
                  point.padding = 0.5,     # Padding around data points
                  max.overlaps = 1000) +    # Ensure all labels are displayed
  scale_color_manual(values = genotype_colors_noQC) +
  labs(
    title = "PCA of Gene Intensities Colored by Genotype",
    x = paste0("PC1 (", round(summary(pca_res_d50_noQC)$importance[2, 1] * 100, 1), "% variance)"),
    y = paste0("PC2 (", round(summary(pca_res_d50_noQC)$importance[2, 2] * 100, 1), "% variance)")
  ) +
  coord_fixed(ratio = 0.5) +
  theme_minimal() +
     theme(
    panel.border = element_rect(color = "black", fill = NA, linewidth = 1),
    legend.position = "bottom"
  )


  ## --- Step 12.2: Plot Colored by Neuron: Generate the second PCA plot with points colored by neuron.
  d50plot2_noQC <- ggplot(pca_scores_d50_noQC, aes(x = PC1, y = PC2, color = neuron)) +
    geom_point(size = 3, alpha = 0.8) +
    stat_ellipse(aes(fill = neuron), geom = "polygon", alpha = 0.2, level = 0.998) + # 99.8% confidence ellipses
    scale_color_manual(values = neuron_colors_noQC) +
    scale_fill_manual(values = neuron_colors_noQC) +
    labs(
      title = "PCA of Gene Intensities Colored by Neuron Type",
      x = paste0("PC1 (", round(summary(pca_res_d50_noQC)$importance[2, 1] * 100, 1), "% variance)"),
      y = paste0("PC2 (", round(summary(pca_res_d50_noQC)$importance[2, 2] * 100, 1), "% variance)")
    ) +
    coord_fixed(ratio = 0.5) +
    theme_minimal() +
     theme(
      panel.border = element_rect(color = "black", fill = NA, linewidth = 1)
    )


  ## --- Step 12.3: Plot Colored by day: Generate the second PCA plot with points colored by day of differentiation
  d50plot3_noQC <- ggplot(pca_scores_d50_noQC, aes(x = PC1, y = PC2, color = factor(day))) +
    geom_point(size = 3, alpha = 0.8) +
    stat_ellipse(aes(fill = factor(day)), geom = "polygon", alpha = 0.2, level = 0.95) +
    scale_color_manual(values = day_colors_noQC) +
    scale_fill_manual(values = day_colors_noQC) +
    labs(
      title = "PCA of Gene Intensities Colored by Day of Differentiation",
      x = paste0("PC1 (", round(summary(pca_res_d50_noQC)$importance[2, 1] * 100, 1), "% variance)"),
      y = paste0("PC2 (", round(summary(pca_res_d50_noQC)$importance[2, 2] * 100, 1), "% variance)")
    ) +
    coord_fixed(ratio = 1) +
    theme_minimal() +
    theme(panel.border = element_rect(color = "black", fill = NA, linewidth = 1))



# ----- call all plots ---- #
d50plot1
d50plot2
d50plot3
d50plot1_noQC
d50plot2_noQC
d50plot3_noQC


# --- Step 13. Save plots as PDFs
ggsave(file.path(out_dir_d50_QC,"diff132_d50_PCA_byGenotype.pdf"), d50plot1,width =15, height = 15, units = "cm", dpi=600)
ggsave(file.path(out_dir_d50_QC,"diff132_d50_PCA_byCelltype.pdf"), d50plot2, width =15, height = 15, units = "cm", dpi=600)
ggsave(file.path(out_dir_d50_QC,"diff132_d50_PCA_byDay.pdf"), d50plot3, width =15, height = 15, units = "cm", dpi=600)

ggsave(file.path(out_dir_d50_QC,"diff132_d50_noQC_PCA_byGenotype.pdf"), d50plot1_noQC,width =15, height = 15, units = "cm", dpi=600)
ggsave(file.path(out_dir_d50_QC,"diff132_d50_noQC_PCA_byCelltype.pdf"), d50plot2_noQC, width =15, height = 15, units = "cm", dpi=600)
ggsave(file.path(out_dir_d50_QC,"diff132_d50_noQC_PCA_byDay.pdf"), d50plot3_noQC, width =15, height = 15, units = "cm", dpi=600)


# save pivoted df (d50_wide) 
#write.csv(d50_df_wide, file = file.path(out_dir_d50_QC, "d50_wide.csv"),row.names = FALSE)

```



### IVb. QC plots for supplements
``` {r}
# --------------------------------------------------- #
# QC plots for supplements  
# --------------------------------------------------- #

# --- Step 1. Average number of ProteinIDs per type on neuron
gene_counts_neuron <- cleaned_df %>%
  group_by(neuron) %>%
  summarise(quantified_genes = n_distinct(Genes), .groups = "drop")

neuronquant <- ggplot(gene_counts_neuron, aes(x = neuron, y = quantified_genes, fill = neuron)) +
  geom_bar(stat = "identity", width = 0.6) +
  scale_fill_manual(values = c("iN" = "grey60", "iDA" = "grey80", "QC" = "grey30")) +
  labs(
    title = "Total Number of Quantified ProteinIDs per Neuron Type",
    y = "ProteinIDs", x = "Neuron"
  ) +
  theme_bw() +
  theme(
    legend.position = "none",
    panel.grid = element_blank()
  )

neuronquant


# --- Step 2. plot  protein IDs vs  per genotype / neuron type ----
genotype_colors_noQC_2 <- colorRampPalette(brewer.pal(11, "RdYlBu"))(2*n_genotypes_noQC)

gene_seq_data <- diff132_d50_PCA_df %>%
  mutate(
    genotype = ifelse(is.na(genotype) & neuron == "QC", "QC", genotype),
    replicate = ifelse(genotype == "QC", NA, replicate)
  ) %>%
  filter(genotype != "QC") %>%  # <-- this line removes QC
  group_by(Genes, genotype, neuron) %>%
  summarise(
    total_sequences = sum(N.Sequences, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(group = interaction(genotype, neuron))


peptide_ID_QC <- ggplot(gene_seq_data, aes(x = Genes, y = log2(total_sequences), color = group)) +
  geom_point(alpha = 0.7) +
  scale_color_manual(values = genotype_colors_noQC_2) +
  labs(
    title = "Number N.Sequences vs IDs by Genotype × Neuron",
    x = "Genes",
    y = "Log2 Total N.Sequences"
  ) +
  theme_bw() +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_text(angle = 0, hjust = 1),
    panel.grid = element_blank(),
    legend.position = "bottom"
  )


# --- Step 3. plot average protein IDs per genotype / neuron type ---- 
# First, compute quantified genes per replicate (if replicate column exists)
# calculate the average for all QC IDs
gene_counts_per_rep <- cleaned_df %>%
  mutate(genotype = ifelse(is.na(genotype) & neuron == "QC", "QC", genotype),
    replicate = ifelse(genotype == "QC", NA, replicate)) %>%
  group_by(genotype, neuron, replicate) %>%
  summarise(quantified_genes = n_distinct(Genes), .groups = "drop")

# Separate QC and non-QC
qc_summary <- gene_counts_per_rep %>%
  filter(genotype == "QC") %>%
  group_by(genotype, neuron) %>%
  summarise(quantified_genes = sum(quantified_genes), .groups = "drop")

non_qc_summary <- gene_counts_per_rep %>%
  filter(genotype != "QC") %>%
  group_by(genotype, neuron) %>%
  summarise(quantified_genes = mean(quantified_genes), .groups = "drop")

# Combine
gene_counts_summary <- bind_rows(qc_summary, non_qc_summary)

# Then, calculate mean and SD across replicates per genotype × neuron group
gene_counts_genotype <- gene_counts_summary %>%
  group_by(genotype, neuron) %>%
  summarise(
    total_genes = sum(quantified_genes),
    sd_genes = ifelse(n() == 1, 0, sd(quantified_genes)),
    .groups = "drop"
    ) %>% 
  mutate(group = interaction(genotype, neuron))

# add "QC" in neuron column for color matching
gene_counts_genotype <- gene_counts_genotype %>%
  mutate(genotype = replace_na(genotype, "QC"))

# Plot with SD error bars
ProteinID_genotype_neurontype <- ggplot(gene_counts_genotype, aes(x = group, y = total_genes, fill = neuron)) +
  geom_bar(stat = "identity", width = 0.6) +
  geom_errorbar(aes(ymin = total_genes - sd_genes, ymax = total_genes + sd_genes), width = 0.2) +
  scale_fill_manual(values = c("iN" = "grey60", "iDA" = "grey80", "QC" = "grey30")) +
  labs(
    title = "Number of Quantified Genes per Genotype and Neuron Type",
    y = "Number of ProteinIDs", x = "Genotype × Neuron"
  ) +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1),
    panel.grid = element_blank()
  )

ProteinID_genotype_neurontype


# --- Step 4. Save QC plots as PDFs in homedir of the project
ggsave(file.path(out_dir_d50_QC,"diff132_d50_QC_neuronquant.pdf"), neuronquant,width =15, height = 15, units = "cm", dpi=600)
ggsave(file.path(out_dir_d50_QC,"diff132_d50_QC_ProteinID_genotype_neurontypee.pdf"), ProteinID_genotype_neurontype, width =25, height = 10, units = "cm", dpi=600)



# --- Step 5. Combine Plots 
# save three main plots for QC under each other 
# Force consistent theme and remove legends
p1 <- d50plot2 + theme(legend.position = "bottom")
p2 <- d50plot3 + theme(legend.position = "bottom")
p3 <- ProteinID_genotype_neurontype + theme(legend.position = "none")
p4 <- peptide_ID_QC + theme(legend.position = "none")

# Combine layout: (p1 | p2) / p3
combined_plot_QC <- ((p1 | p2) / p3 / p4) +
  plot_layout(heights = c(1, 1,0.5)) & 
  theme(plot.margin = margin(0.01, 10, 0.01, 10)) # Top, Right, Bottom, Left padding


# save three main plots for QC under each other 
# Force consistent theme and remove legends
p5 <- d50plot2_noQC + theme(legend.position = "bottom")
p6 <- d50plot3_noQC + theme(legend.position = "bottom")
p7 <- d50plot1_noQC + theme(legend.position = "bottom")

# Combine layout: (p5 | p6) / p7
combined_plot <- ((p5 | p6) / p7) +
  plot_layout(heights = c(1, 1)) & 
  theme(plot.margin = margin(0.01, 10, 0.01, 10)) # Top, Right, Bottom, Left padding



# View or save
combined_plot
combined_plot_QC

# Save as PDF
ggsave(file.path(out_dir_d50_QC,"diff132_d50_QC_combined_plot.pdf"), combined_plot_QC, width = 12, height = 12, device = cairo_pdf)
ggsave(file.path(out_dir_d50_QC,"diff132_d50_combined_plot.pdf"), combined_plot, width = 12, height = 12, device = cairo_pdf)


```



# V. Read in main df & Heatmaps of data day 30 & day 50
use the full dataset for plotting volcano and heatmaps etc 
each measured protein has mean ctrl, mean ko and fold-change and p/q value associated with it
probably makes sense to have it in tibble for easy data manipulation 
```{r}
# --------------------------------------------------- #
# iN/iDA: Day 50 Proteomics Heatmap Pipeline
# --------------------------------------------------- #
library(ComplexHeatmap)
detach("package:ComplexHeatmap", unload = TRUE, character.only = TRUE)
library(pheatmap)
library(RColorBrewer) # For color palettes

# --- Step 1. Load and Inspect Data
# Define the path to the input CSV file
input_LSD_file <- "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/datasets/lsd_fc_pv.csv"

# Read the CSV file into a data frame
diff132_d50_df <- read.csv(input_LSD_file, header = TRUE, sep = ",", stringsAsFactors = FALSE)

# Inspect the structure of the data
str(diff132_d50_df)


# --- Step 2. Data Cleaning
# Remove unnecessary columns: Protein.Group (1), Protein.Name (2), First.Protein.Description (4)
diff132_d50_df <- diff132_d50_df[, -c(1, 2, 4,14,15,16,17,18,19,21)]

# Filter out rows with missing or empty 'Genes' entries
clean_d50_df <- diff132_d50_df %>%
  filter(!is.na(Genes) & Genes != "")


# --- Step 3. Prepare Data for Heatmap
# Create a unique identifier for each sample by combining genotype and neuron
clean_d50_df<- clean_d50_df %>%
  mutate(sample_id = paste(genotype, neuron, sep = "_"))

# Pivot the data to have genes as rows and samples as columns
heatmap_d50_data <- clean_d50_df %>%
  select(Genes, sample_id, fold_change) %>%
  pivot_wider(
    names_from = sample_id,
    values_from = fold_change,
    values_fill = list(fold_change = 0),
    values_fn = list(fold_change = sum)
  )

# Convert the data frame to a matrix and set row names to gene names
rownames_df <- heatmap_d50_data$Genes  # Extract rownames before dropping the column
heatmap_matrix_d50 <- as.matrix(heatmap_d50_data[, -1])
rownames(heatmap_matrix_d50) <- rownames_df
heatmap_matrix_d50[is.na(heatmap_matrix_d50)] <- 0

# Remove rows/columns with zero variance
heatmap_matrix_d50 <- heatmap_matrix_d50[apply(heatmap_matrix_d50, 1, var) != 0, ]
heatmap_matrix_d50 <- heatmap_matrix_d50[, apply(heatmap_matrix_d50, 2, var) != 0]



# --- Step 4. Create Annotations for Heatmap & save as csv
# Extract sample information for annotations
sample_d50_info <- clean_d50_df %>%
  select(sample_id, genotype, neuron) %>%
  distinct() %>%
  column_to_rownames("sample_id")


df_day30 <- clean_d50_df %>% filter(day == 30)
df_day50 <- clean_d50_df %>% filter(day == 50)

write.csv(df_day30, file = file.path(out_dir_d50_dataframes, "df_day30_heatmap.csv"),row.names = FALSE)
write.csv(df_day50, file = file.path(out_dir_d50_dataframes, "df_day50_heatmap.csv"),row.names = FALSE)


# --- Step 5. Define a function to generate heatmaps
generate_heatmap <- function(df, day_label) {
  heatmap_data <- df %>%
    mutate(sample_id = paste(genotype, neuron, sep = "_")) %>%
    select(Genes, sample_id, fold_change) %>%
    pivot_wider(
      names_from = sample_id,
      values_from = fold_change,
      values_fill = list(fold_change = 0),
      values_fn = list(fold_change = sum)
    )

  # Extract matrix and rownames
  rownames_mat <- heatmap_data$Genes
  mat <- as.matrix(heatmap_data[, -1])
  rownames(mat) <- rownames_mat
  storage.mode(mat) <- "numeric"
  mat[!is.finite(mat)] <- 0
  mat <- mat[apply(mat, 1, var) != 0, , drop = FALSE]
  mat <- mat[, apply(mat, 2, var) != 0, drop = FALSE]

  # Annotations
  sample_info <- df %>%
    mutate(sample_id = paste(genotype, neuron, sep = "_")) %>%
    select(sample_id, genotype, neuron) %>%
    distinct() %>%
    column_to_rownames("sample_id")

  annotation_col <- data.frame(
    Genotype = sample_info$genotype,
    Neuron = sample_info$neuron
  )
  rownames(annotation_col) <- rownames(sample_info)

  genotypes <- unique(sample_info$genotype)
  neurons <- unique(sample_info$neuron)

  ann_colors <- list(
    Genotype = setNames(colorRampPalette(brewer.pal(9, "Set1"))(length(genotypes)), genotypes),
    Neuron = setNames(colorRampPalette(c("grey30", "grey60", "grey80"))(length(neurons)), neurons)
  )

  pheatmap(
    mat = mat,
    scale = "row",
    color = colorRampPalette(rev(brewer.pal(n = 11, name = "RdYlBu")))(100),
    annotation_col = annotation_col,
    annotation_colors = ann_colors,
    breaks = seq(-4, 4, length.out = 101),
    cluster_rows = TRUE,
    cluster_cols = TRUE,
    show_rownames = FALSE,
    show_colnames = TRUE,
    use_raster = FALSE,
    angle_col = "90",
    main = paste("Day", day_label, "iN / iDA Data"),
    fontsize = 10,
    border_color = NA
  )
}


heatmap_d30 <- generate_heatmap(df_day30, 30)
heatmap_d50 <- generate_heatmap(df_day50, 50)



# --- Step 6. save single heatmaps 
# Save Day 30 heatmap
pdf(file.path(out_dir_d50_heatmaps, "heatmap_day30.pdf"), width = 3, height = 6)
grid::grid.draw(heatmap_d30$gtable)
dev.off()

# Save Day 50 heatmap
pdf(file.path(out_dir_d50_heatmaps, "heatmap_day50.pdf"), width = 6, height = 6)
grid::grid.draw(heatmap_d50$gtable)
dev.off()



# --- Step 7. Combine Plots & save as PDF
# have to use gridExtra, since do not use ggplot objects, but pheatmap() returns a grid object, not a ggplot. To arrange multiple pheatmap() plots, use gridExtra::grid.arrange() instead:
library(gridExtra)

# Define the output file path
output_file_50 <- file.path(out_dir_d50_heatmaps, "diff132_d30_d50_combined_heatmap.pdf")

# Save the heatmap to a PDF file
pdf(output_file_50, width = 40 / 2.54, height = 30 / 2.54)
gridExtra::grid.arrange(
  heatmap_d30$gtable,
  heatmap_d50$gtable,
  ncol = 2,
  widths = c(1, 3)  # Adjust for 25% / 75% layout
)
dev.off()


```


# VI. Day 30 & Day 50 base eval
### VIa. Add Subcell annotation to dataset
add subcell annotation to df and save
sub sub-matrix for d30 and d50
export heatmap as csv file
add all colums of interest: FC, mean intensity, q-value
```{r}
# --------------------------------------------------- #
# Subcell annotation to df for QC and Organelle Violin Plots 
# add annotations do df and split by day and save as .csv files  
# --------------------------------------------------- #

# --- Step 0: Define contaminant list
contaminant_genes <- c(
  "KRT8", "KRT19", "KRT9", "KRT10", "KRT2", "KRT18", "KRT1", "KRT5",
  "COL10A1", "COL13A1", "COL14A1", "COL18A1", "COL1A1", "COL1A2",
  "COL26A1", "COL2A1", "COL4A1", "COL4A2", "COL5A1", "COL6A1", "COL6A2"
  )


# --- Step 1. Transform columns
clean_d50_transformed_df <- clean_d50_df %>%
  mutate(
    log2_fold_change = ifelse(fold_change > 0, log2(fold_change), NA),
    neg_log10_q_value = ifelse(q_value > 0, -log10(q_value), NA),
    neg_log10_p_value = ifelse(p_value > 0, -log10(p_value), NA)
  ) %>%
  filter(!Genes %in% contaminant_genes)


#  --- Step 2: Load and prepare annotation matrix (only once)
cols_to_read <- c(1,2,3,4,5,6,7,9,10,12,15,16,17,18,19,20,21,22,23,25,26,27,28,29,30,31,32,33)
subcell_df <- read.csv("/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/neuroLSDgit/proteome/SubCellAnnotation.csv", stringsAsFactors = FALSE)[, cols_to_read]
subcell_df[] <- lapply(subcell_df, as.character)

long_subcell_df <- subcell_df %>%
  pivot_longer(
    cols = everything(),
    names_to = "Localization",
    values_to = "Genes"
  ) %>%
  filter(!is.na(Genes) & Genes != "") %>%
  mutate(Genes = trimws(Genes)) %>%
  distinct()

binary_matrix <- long_subcell_df %>%
  mutate(value = TRUE) %>%
  pivot_wider(
    names_from = Localization,
    values_from = value,
    values_fill = list(value = FALSE)
  )


# --- Step 3: Function to process each day independently
process_day_data <- function(df, day_value, save_path) {
  df_day <- df %>% filter(day == day_value)

  complete_data <- df_day %>%
    select(Genes, sample_id, log2_fold_change, mean_ctrl, mean_ko, neg_log10_q_value, neg_log10_p_value) %>%
    pivot_wider(
      names_from = sample_id,
      values_from = c(log2_fold_change, mean_ctrl, mean_ko, neg_log10_q_value, neg_log10_p_value),
      names_glue = "{sample_id}_{.value}",
      values_fill = list(
        log2_fold_change = 0, mean_ctrl = 0, mean_ko = 0,
        neg_log10_q_value = 0, neg_log10_p_value = 0
      ),
      values_fn = list(
        log2_fold_change = sum, mean_ctrl = mean, mean_ko = mean,
        neg_log10_q_value = mean, neg_log10_p_value = mean
      )
    )

  complete_data_annotated <- complete_data %>%
    left_join(binary_matrix, by = "Genes")
  complete_data_annotated[is.na(complete_data_annotated)] <- 0

  # Save to CSV
  write.csv(complete_data_annotated, save_path, row.names = FALSE)

  return(complete_data_annotated)
}

# --- Step 4: Run for Day 30 and Day 50
complete_data_annotated_day30 <- process_day_data(
  clean_d50_transformed_df, 30,
  file.path(out_dir_d50_dataframes, "diff132_complete_annotated_day30.csv")
)


complete_data_annotated_day50 <- process_day_data(
  clean_d50_transformed_df, 50,
  file.path(out_dir_d50_dataframes, "diff132_complete_annotated_day50.csv")
)

```



### VIb. Plot LSD protein abundnace across genotypes
plan is to plot a heatmap of all LSD proteins of interest across the dataset -> check that these are KOs
```{r}
# --------------------------------------------------- #
# Plot LSD protein abundance in their respective KOs
# barplots
# --------------------------------------------------- #

# ---- Define LSD Gene List ----
LSDgenes <- c("ASAH1", "PPT1", "CTSD", "GRN", "ATP13A2", "CTSF", "TPP1", "CLN3", 
              "DNAJC5", "CLN5", "CLN6", "MFSD8", "CLN8", "CTNS", "GAA", "GALNS", 
              "GBA1", "GLB1", "HEXA", "HEXB", "LIPA", "MCOLN1", "NPC1", "NPC2", 
              "PSAP", "SMPD1")

# ---- Prepare Long Format Data ----
# Filter for LSD genes and pivot to long format
df_clean_heatmap <- clean_d50_transformed_df %>%
  filter(Genes %in% LSDgenes) %>%
  select(Genes, genotype, neuron, day, mean_ctrl, mean_ko) %>%
  pivot_longer(cols = c(mean_ctrl, mean_ko), names_to = "condition", values_to = "value") %>%
  mutate(day = as.integer(day))

# ---- Filter for Matching Gene-Genotype Combinations at Day 50 ----
# Only keep rows where the gene matches the genotype (e.g., GBA1 expression in GBA1 KO)
plot_df <- df_clean_heatmap %>%
  filter(Genes == genotype, day == 50)

# ---- Replace NAs with 0 ----
plot_df <- plot_df %>%
  mutate(value = ifelse(is.na(value), 0, value))

# ---- Create DataFrame for Annotating Undetected Proteins ----
label_df <- plot_df %>%
  group_by(Genes) %>%
  mutate(max_y = max(value, na.rm = TRUE)) %>%
  filter(condition == "mean_ko" & value == 0) %>%
  mutate(
    label = "not detected",
    y_label = max_y * 0.5,                          # Position label at 50% of max height
    x_shift = as.numeric(factor(neuron)) + 0.2      # Shift x position slightly for clarity
  )

# ---- Plot Bar Plot with Facets per Gene ----
LSDgene_Abundance <- ggplot(plot_df, aes(x = neuron, y = value, fill = condition)) +
  geom_bar(stat = "summary", fun = mean, position = position_dodge(width = 0.6), width = 0.6) +
  geom_text(                                         # Add labels for undetected mean_ko
    data = label_df,
    aes(x = x_shift, y = y_label, label = label),
    inherit.aes = FALSE,
    angle = 90,
    size = 3,
    color = "red"
  ) +
  facet_wrap(~Genes, scales = "free_y") +
  scale_fill_manual(values = c("mean_ctrl" = "grey70", "mean_ko" = "steelblue")) +
  scale_color_manual(values = c("mean_ctrl" = "grey40", "mean_ko" = "steelblue4")) +
  labs(
    title = "LSD Protein Abundance (ctrl vs KO)",
    x = "Neuron Type",
    y = "Abundance (raw)",
    fill = "Condition"
  ) +
  theme_bw() +
  theme(
    legend.position = "bottom",
    panel.grid = element_blank()
  )

# ---- Display Plot ----
LSDgene_Abundance

# ---- Save Plot and Data ----
ggsave( file.path(out_dir_d50_QC,
  "diff132_LSDgene_Abundance.pdf"),
  LSDgene_Abundance,
  width = 12, height = 12, device = cairo_pdf
)

write.csv(
  df_clean_heatmap, file = file.path(out_dir_d50_QC,
  "LSD_sorted.csv"),
  row.names = FALSE
)




# --------------------------------------------------- #
# Plot LSD protein abundance in their respective KOs
# heatmaps
# --------------------------------------------------- #
# --- 0. Define expected genotype list (from your LSD gene list)
expected_genes <- c("ASAH1", "PPT1", "CTSD", "GRN", "ATP13A2", "CTSF", "TPP1", "CLN3", 
                    "DNAJC5", "CLN5", "CLN6", "MFSD8", "CLN8", "CTNS", "GAA", "GALNS", 
                    "GBA1", "GLB1", "HEXA", "HEXB", "LIPA", "MCOLN1", "NPC1", "NPC2", 
                    "PSAP", "SMPD1")

# --- 1. Construct all combinations of neuron × condition × gene
all_rows <- expand.grid(
  neuron    = c("iN", "iDA"),
  condition = c("mean_ctrl", "mean_ko"),
  Genes     = expected_genes,
  stringsAsFactors = FALSE
) %>%
  mutate(RowID = paste(condition, neuron, sep = "_"))

# --- 2. Get actual values from df_clean_heatmap
values_df <- df_clean_heatmap %>%
  filter(day == 50, Genes == genotype) %>%
  group_by(Genes, neuron, condition) %>%
  summarise(value = mean(value, na.rm = TRUE), .groups = "drop") %>%
  mutate(RowID = paste(condition, neuron, sep = "_"))

# --- 3. Left join to preserve full layout and reshape
heatmap_matrix_abundance <- all_rows %>%
  left_join(values_df, by = c("Genes", "neuron", "condition", "RowID")) %>%
  select(Genes, RowID, value) %>%
  pivot_wider(names_from = Genes, values_from = value) %>%
  column_to_rownames("RowID") %>%
  as.matrix()

# --- 4. Plot heatmap
lsdkoheatmap <- pheatmap(
  heatmap_matrix_abundance,
  color = colorRampPalette(c("white", "firebrick"))(100),
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  na_col = "grey70",  # marks undetected proteins
  cellheight = 15,
  cellwidth = 15,
  border_color = "black",
  lwd = 0.25,
  main = "LSD Protein Abundance (Control vs KO) at Day 50"
)

  
# --- 3. Save heatmap
ggsave(file.path(out_dir_d50_QC, "LSDgene_Abundance_Heatmap.pdf"),lsdkoheatmap,
       width = 8, height = 6, device = cairo_pdf)


```

### VIc. Sorted Heatmap of average neuro-releated annotations
```{r}
# --------------------------------------------------- #
# Heatmap of neuro-related annotations
# plot by genotype and split for iN and iDA
# --------------------------------------------------- #
loc_ann <- c("Lysosome","RecyclingEndosome", "Endo_iN_curated_Hundley","EarlyEndosome",
             "SynapseSVs","Presynaptic","Postsynaptic",
             "SVfusion","Svendocytosis","Svexocytosis","vATPase")

# --- helper function for one neuron type ---
make_ann_heatmap <- function(df, neuron_type, loc_ann, out_file) {
  
  long_df <- df %>%
    pivot_longer(
      cols = matches(paste0("_", neuron_type, "_log2_fold_change$")),
      names_to = "Condition",
      values_to = "log2FC"
    ) %>%
    mutate(genotype = sub("_.*", "", Condition)) %>%
    pivot_longer(cols = all_of(loc_ann),
                 names_to = "Annotation", values_to = "is_annotated") %>%
    filter(is_annotated == 1)
  
  ann_matrix <- long_df %>%
    group_by(genotype, Annotation) %>%
    summarise(mean_log2FC = mean(log2FC, na.rm = TRUE), .groups = "drop") %>%
    pivot_wider(names_from = Annotation, values_from = mean_log2FC) %>%
    column_to_rownames("genotype")
  
  ann_mat <- as.matrix(ann_matrix)
  ann_mat <- ann_mat[, loc_ann, drop = FALSE]
  ann_mat[!is.finite(ann_mat)] <- NA
  ann_mat <- ann_mat[rowSums(!is.na(ann_mat)) > 0, ]
  
  pheatmap(
    mat = ann_mat,
    scale = "row",
    color = colorRampPalette(rev(brewer.pal(11, "RdYlBu")))(100),
    cluster_rows = TRUE,
    cluster_cols = FALSE,
    show_rownames = TRUE,
    show_colnames = TRUE,
    border_color = NA,
    fontsize = 6,
    cellheight = 8,
    cellwidth = 8,
    main = paste("Mean log2FC per Genotype –", neuron_type),
    filename = out_file 
  )
}

# Call the function
make_ann_heatmap(
  complete_data_annotated_day50, 
  "iN", loc_ann,
  file.path(out_dir_d50_ascd_avg, "heatmap_d50_iN_rowZ_byGenotype.pdf")
)

make_ann_heatmap(
  complete_data_annotated_day50, 
  "iDA", loc_ann,
  file.path(out_dir_d50_ascd_avg, "heatmap_d50_iDA_rowZ_byGenotype.pdf")
)




# --------------------------------------------------- #
# Line plots of Sph mutants of interest 
# plot by genotype and split for iN and iDA
# --------------------------------------------------- #
highlight_blue <- c("SMPD1","ASAH1","GBA1","PSAP","HEXA","HEXB")
highlight_thick <- c("SMPD1","ASAH1","GBA1","CTSD","CLN6","ATP13A2","PPT1")

make_lineplot_all <- function(df, neuron_type, loc_ann, out_file) {
  
  # 1. reshape to long
  long_df <- df %>%
    pivot_longer(
      cols = matches(paste0("_", neuron_type, "_log2_fold_change$")),
      names_to = "Condition",
      values_to = "log2FC"
    ) %>%
    mutate(genotype = sub("_.*", "", Condition))
  
  # 2. attach annotations
  long_df <- long_df %>%
    pivot_longer(cols = all_of(loc_ann),
                 names_to = "Annotation", values_to = "is_annotated") %>%
    filter(is_annotated == 1)
  
  # 3. summarise mean log2FC per genotype × annotation
  plot_df <- long_df %>%
    group_by(genotype, Annotation) %>%
    summarise(mean_log2FC = mean(log2FC, na.rm = TRUE), .groups = "drop") %>%
    mutate(Annotation = factor(Annotation, levels = loc_ann))
  
  # 4. flag highlight sets
  plot_df <- plot_df %>%
    mutate(
      highlight_color = case_when(
        genotype %in% highlight_blue ~ "dodgerblue",
        TRUE ~ "grey80"
      ),
      highlight_size = case_when(
        genotype %in% highlight_thick ~ 1.2,
        TRUE ~ 0.4
      ),
      highlight_label = ifelse(genotype %in% union(highlight_blue, highlight_thick),
                               genotype, NA)
    )
  
  # 5. plot
  p <- ggplot(plot_df, aes(x = Annotation, y = mean_log2FC, group = genotype)) +
    geom_line(aes(color = highlight_color, size = highlight_size)) +
    scale_color_identity() +
    scale_size_identity() +
    geom_text_repel(
      data = plot_df %>% filter(!is.na(highlight_label)) %>% group_by(genotype) %>% slice_tail(n = 1),
      aes(label = highlight_label, color = highlight_color),
      size = 2, nudge_x = 0.5, direction = "y", hjust = 0
    ) +
    theme_bw(base_size = 7) +
    theme(
      panel.grid = element_blank(),
      axis.text.x = element_text(angle = 45, hjust = 1)
    ) +
    labs(
      title = paste("Mean log2FC across annotations –", neuron_type),
      x = "Annotation",
      y = expression("Mean log"[2]*"(KO / Ctrl)")
    )
  
  ggsave(out_file, p, width = 4, height = 4, device = cairo_pdf)
  
  return(p)
}

# Run for iN and iDA
p_iN <- make_lineplot_all(
  complete_data_annotated_day50, "iN", loc_ann,
  file.path(out_dir_d50_ascd_avg, "lineplot_allGenotypes_iN.pdf")
)

p_iDA <- make_lineplot_all(
  complete_data_annotated_day50, "iDA", loc_ann,
  file.path(out_dir_d50_ascd_avg, "lineplot_allGenotypes_iDA.pdf")
)



```


# VII. Neuro QC plots
Aimed to plot neuro markers to plot differences between neuron types

### VIIa. Plot pre / post synaptic marker
```{r}
# --------------------------------------------------- #
# neuro QC plots
# plot pre / post synaptic markers of ctrl iN vs iDA & plot 
# --------------------------------------------------- #

# --- Step 1. add annotation to cleaned_df (from PCA calculation, since has raw intensities for each gene in it)
PCAclean_d50_transformed_df <- cleaned_df %>%
  filter(!Genes %in% contaminant_genes)


# --- Step 2. Join localization annotations into the filtered df
PCAclean_d50_annotated <- PCAclean_d50_transformed_df %>%
  left_join(binary_matrix, by = "Genes")


# --- Step 3. Fill NAs with FALSE for localization columns
PCAclean_d50_annotated[is.na(PCAclean_d50_annotated)] <- FALSE


# --- Step 4. Dunction for plotting proteins of Interest 
plot_multiple_genes <- function(genes, data = PCAclean_d50_annotated) {
  gene_df <- data %>%
    filter(Genes %in% genes, genotype == "ctrl", neuron %in% c("iN", "iDA"), day == 50)

  ggplot(gene_df, aes(x = neuron, y = quan, fill = neuron)) +
    geom_bar(stat = "summary", fun = mean, position = position_dodge(width = 0.6), width = 0.5) +
    geom_jitter(aes(color = neuron), width = 0.15, size = 1.8, alpha = 0.6) +
    geom_errorbar(
      stat = "summary",
      fun.data = mean_se,
      width = 0.2,
      position = position_dodge(width = 0.6)
    ) +
    scale_fill_manual(values = c("iN" = "grey60", "iDA" = "grey80")) +
    scale_color_manual(values = c("iN" = "grey30", "iDA" = "grey10")) +
    facet_wrap(~Genes, scales = "free_y") +
    labs(
      title = "Expression of Selected Proteins in Ctrl Neurons day 50",
      x = "Neuron Type",
      y = "Quantified Intensity (quan)"
    ) +
  theme_bw() +
    theme(
    legend.position = "none",
    panel.grid = element_blank()
    )
}

# --- Step 5. Call function and plot proteins of Interest 
Neuro_QC_Proteins <- plot_multiple_genes(c("TH", "SYP", "SYN1", "SNCA", "NEFH", "BSN", "SNX5", "VAMP2", "CPLX1"))
ggsave(file.path(out_dir_d50_QC, "diff132_d50_Neuro_QC_Proteins.pdf"), Neuro_QC_Proteins, width = 12, height = 12, device = cairo_pdf)


```


### VIIb. Neuro annotation plot by neuon x genotype; ascending order 
```{r}
# --------------------------------------------------- #
# neuro QC plots
# Function for all annotations. By neuron type, in ascending order  
# --------------------------------------------------- #

# --- Define annotation list ---
# all_ann <- c("Mito", "MitoIMS", "MitoMatrix", "MitoMIM", "MitoMOM", "OXPHOS",
#              "mtComplexI", "Golgi", "Lysosome", "ER", "Cytoplasm", "Nucleus",
#              "Autophagy", "SynGO", "Endo_iN_curated_Hundley", "SynapseSVs",
#              "Presynaptic", "Postsynaptic", "NeuroDev", "EndoLyso", "EarlyEndosome",
#              "RecyclingEndosome", "SVfusion", "Svendocytosis", "Svexocytosis", "vATPase")

all_ann <- c("Svendocytosis")

# --- 1. Reshape log2FC data into long format ---
ascd_ann_long_df <- complete_data_annotated_day50 %>%
  pivot_longer(
    cols = matches("_log2_fold_change$"),
    names_to = "Condition",
    values_to = "log2FC"
  ) %>%
  mutate(
    neuron = ifelse(grepl("_iDA_", Condition), "iDA", "iN"),
    genotype = sub("_.*", "", Condition),  # everything before first "_" is genotype
    group = paste(genotype, neuron, sep = "_")
  ) %>%
  # pivot annotations
  pivot_longer(cols = all_of(all_ann), names_to = "Annotation", values_to = "is_annotated") %>%
  filter(is_annotated == 1)

# --- 2. Compute average log2FC per annotation per group ---
ascd_avg_ann_fc_summary <- ascd_ann_long_df %>%
  group_by(group, neuron, Annotation) %>%
  summarise(avg_log2FC = mean(log2FC, na.rm = TRUE), .groups = "drop")

# --- 3. Order groups within each neuron ---
ascd_avg_ann_fc_summary <- ascd_avg_ann_fc_summary %>%
  arrange(neuron, avg_log2FC) %>%
  group_by(neuron) %>%
  mutate(group = factor(group, levels = unique(group)))

# --- 4. Merge ordering back into main df ---
ascd_ann_long_df <- ascd_ann_long_df %>%
  inner_join(ascd_avg_ann_fc_summary %>% select(group, neuron), 
             by = c("group", "neuron")) %>%
  mutate(group = factor(group, levels = levels(ascd_avg_ann_fc_summary$group)))

# --- 5. Plot ---
d50_ascd_ann_plot <- ggplot(ascd_ann_long_df, aes(x = group, y = log2FC, group = Genes)) +
  geom_line(color = "grey70", size = 0.3, alpha = 0.6) +
  geom_point(color = "grey70", size = 0.5, alpha = 0.6) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  geom_line(data = ascd_avg_ann_fc_summary,
            aes(x = group, y = avg_log2FC, group = Annotation),
            color = "red", size = 1.2, inherit.aes = FALSE) +
  facet_wrap(~neuron, scales = "free_x") +
  theme_bw(base_size = 8) +
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
    panel.grid = element_blank()
  ) +
  labs(
    title = "Functional Annotations: log2FC Summary by Genotype × Neuron",
    x = "Genotype × Neuron (sorted by mean log2FC)",
    y = expression(log[2]*"(KO / Ctrl)")
  )

d50_ascd_ann_plot

# --- 6. Save PDF ---
ggsave(file.path(out_dir_d50_ascd_avg, "diff132_d50_ascending_Avg_SVendo.pdf"), d50_ascd_ann_plot, width = 4, height = 3, device = cairo_pdf)



# --- 7. Zoom into first 6 groups per neuron ---
ascd_top10_summary <- ascd_avg_ann_fc_summary %>%
  group_by(neuron) %>%
  slice_head(n = 6) %>%
  ungroup()

ascd_top10_long_df <- ascd_ann_long_df %>%
  filter(group %in% ascd_top10_summary$group)

# ensure factor order matches the subset
ascd_top10_long_df <- ascd_top10_long_df %>%
  mutate(group = factor(group, levels = levels(ascd_avg_ann_fc_summary$group))) 

# --- 8. Plot top 10 ---
d50_ascd_ann_plot_top10 <- ggplot(ascd_top10_long_df, aes(x = group, y = log2FC, group = Genes)) +
  geom_line(color = "grey70", size = 0.3, alpha = 0.6) +
  geom_point(color = "grey70", size = 0.5, alpha = 0.6) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  geom_line(data = ascd_top10_summary,
            aes(x = group, y = avg_log2FC, group = Annotation),
            color = "red", size = 1.2, inherit.aes = FALSE) +
  facet_wrap(~neuron, scales = "free_x") +
  theme_bw(base_size = 8) +
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
    panel.grid = element_blank()
  ) +
  labs(
    title = "Top Genotypes (by avg log2FC)",
    x = "Genotype × Neuron (Top 6)",
    y = expression(log[2]*"(KO / Ctrl)")
  )

# --- 9. Save second PDF ---
ggsave(file.path(out_dir_d50_ascd_avg, "diff132_d50_Top5_Avg_SVendo.pdf"), d50_ascd_ann_plot_top10, width = 2, height = 3, device = cairo_pdf)

```

#### VIIb1. Plot vATPase by neuon x genotype; ascending order 
```{r}
# --------------------------------------------------- #
# neuro QC plots
# vATPase plots 
# --------------------------------------------------- #
vatpase_genes <- c("ATP6V1G1", "ATP6AP2", "ATP6V1B2", "ATP6V1C1", "ATP6V1E1", "ATP6V1A", "ATP6V0D1",
                   "ATP6AP1", "ATP6V1F", "ATP6V0A1", "ATP6V0A2", "ATP6V1H", "ATP6V1D", "ROGDI",
                   "SYP", "DMXL1", "DMXL2", "PODXL", "PODXL2")
				   
# --- 1. Filter and compute log2FC ---
vatpase_long_df <- clean_d50_transformed_df %>%
  filter(Genes %in% vatpase_genes, day == 50) %>%
  mutate(log2FC = log2(mean_ko / mean_ctrl)) %>%
  mutate(group = paste(genotype, neuron, sep = "_"))

# --- 2. Compute average log2FC per group ---
avg_fc_summary <- vatpase_long_df %>%
  group_by(group, neuron) %>%
  summarise(avg_log2FC = mean(log2FC, na.rm = TRUE), .groups = "drop")

# --- 3. Order by increasing avg log2FC ---
avg_fc_summary <- avg_fc_summary %>%
  arrange(neuron, avg_log2FC) %>%
  group_by(neuron) %>%
  mutate(group = factor(group, levels = unique(group)))

# --- 4. Merge ordering into main data frame ---
vatpase_long_df <- vatpase_long_df %>%
  inner_join(avg_fc_summary %>% select(group, neuron), by = c("group", "neuron")) %>%
  mutate(group = factor(group, levels = levels(avg_fc_summary$group)))

# --- 5. Plot ---
d50_vATPase_plot <- ggplot(vatpase_long_df, aes(x = group, y = log2FC, group = Genes)) +
  geom_line(color = "grey70", size = 0.3, alpha = 0.8) +
  geom_hline(yintercept =0, linetype = "dashed", color = "black") +
  geom_point(color = "grey70", size = 0.5, alpha = 0.8) +
  geom_line(data = avg_fc_summary, 
            aes(x = group, y = avg_log2FC, group = 1),
            color = "red", size = 1.2, inherit.aes = FALSE) +
  facet_wrap(~neuron, scales = "free_x") +
  theme_bw(base_size = 8) +
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
    panel.grid = element_blank()
  ) +
  labs(
    title = "v-ATPase Genes: log2FC Summary by Genotype × Neuron",
    x = "Genotype × Neuron (sorted by mean log2FC)",
    y = expression(log[2]*"(KO / Ctrl)")
  )

d50_vATPase_plot

# --- 6. save pdf ---
ggsave(file.path(out_dir_d50_ascd_avg, "diff132_d50_Neuro_vATPase.pdf"), d50_vATPase_plot, width = 4, height = 3, device = cairo_pdf)


```

#### VIIb2. SV & SNARE plot by neuon x genotype; ascending order 
```{r}
# --------------------------------------------------- #
# neuro QC plots
# SV snare plots 
# --------------------------------------------------- #
svsnare_genes <- c("SYP", "VAMP2", "STXBP1", "CPLX1", "SYT1", "SNAP25","SNAP","STX1A", "STX1")

# --- 1. Filter and compute log2FC ---
svsnare_long_df <- clean_d50_transformed_df %>%
  filter(Genes %in% svsnare_genes, day == 50) %>%
  mutate(log2FC = log2(mean_ko / mean_ctrl)) %>%
  mutate(group = paste(genotype, neuron, sep = "_"))

# --- 2. Compute average log2FC per group ---
avg_svsnare_fc_summary <- svsnare_long_df %>%
  group_by(group, neuron) %>%
  summarise(avg_log2FC = mean(log2FC, na.rm = TRUE), .groups = "drop")

# --- 3. Order by increasing avg log2FC ---
avg_svsnare_fc_summary <- avg_svsnare_fc_summary %>%
  arrange(neuron, avg_log2FC) %>%
  group_by(neuron) %>%
  mutate(group = factor(group, levels = unique(group)))

# --- 4. Merge ordering into main data frame ---
vsvsnare_long_df <- svsnare_long_df %>%
  inner_join(avg_svsnare_fc_summary %>% select(group, neuron), by = c("group", "neuron")) %>%
  mutate(group = factor(group, levels = levels(avg_svsnare_fc_summary$group)))

# --- 5. Plot ---
d50_svsnare_plot <- ggplot(svsnare_long_df, aes(x = group, y = log2FC, group = Genes)) +
  geom_line(color = "grey70", size = 0.3, alpha = 0.8) +
  geom_hline(yintercept =0, linetype = "dashed", color = "black") +
  geom_point(color = "grey70", size = 0.5, alpha = 0.8) +
  geom_line(data = avg_svsnare_fc_summary, 
            aes(x = group, y = avg_log2FC, group = 1),
            color = "red", size = 1.2, inherit.aes = FALSE) +
  facet_wrap(~neuron, scales = "free_x") +
  theme_bw(base_size = 8) +
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
    panel.grid = element_blank()
  ) +
  labs(
    title = "SV SNARE Genes: log2FC Summary by Genotype × Neuron",
    x = "Genotype × Neuron (sorted by mean log2FC)",
    y = expression(log[2]*"(KO / Ctrl)")
  )

d50_svsnare_plot

# --- 6. save pdf ---
ggsave(file.path(out_dir_d50_ascd_avg, "diff132_d50_Neuro_SVSNSARE.pdf"), d50_svsnare_plot, width = 4, height = 3, device = cairo_pdf)

```





### VIId. Abundance of neuromarkers in Ctrl iN/iDA day 30 & day 50
```{r}
# --------------------------------------------------- #
# neuro QC plots
# Abundance of neuromarkers in Ctrl day 30 & day 50
# --------------------------------------------------- #


# --- Step 1. Define Developmental Marker Gene List ----
dev_genes <- c("BDNF", "CAMK2B", "CRTC1", "DCX", "JUN", "MAP2", "NCAM1",
               "NEFH", "NEFL", "NEFM", "NES", "POU3F2", "SLC17A7", "SYN1",
               "SYP", "TUBB3", "TH", "BSN", "SYNJ1", "GAP43", "PSD95", "VGLUT",
               "SYN2", "SYN3", "NGN")


# --- Step 2. Prepare Data ----
dev_plot_df <- clean_d50_transformed_df %>%
  filter(Genes %in% dev_genes) %>%
  select(Genes, neuron, day, mean_ctrl) %>%
  mutate(day = as.factor(day))  # Ensure day is treated as categorical for plotting


# --- Step 3.Plot ----
Dev_Marker_Abundance <- ggplot(dev_plot_df, aes(x = neuron, y = mean_ctrl, fill = day)) +
  geom_bar(stat = "summary", fun = mean, position = position_dodge(width = 0.6), width = 0.6) +
  facet_wrap(~Genes, scales = "free_y") +
  scale_fill_manual(values = c("30" = "grey70", "50" = "steelblue")) +
  labs(
    title = "Neuronal Marker Abundance (Control, day 30 vs 50)",
    x = "Neuron Type",
    y = "Abundnace (mean_ctrl)",
    fill = "Day"
  ) +
  theme_bw() +
  theme(
    legend.position = "bottom",
    panel.grid = element_blank()
  )


# --- Step 4. Display ----
Dev_Marker_Abundance


# --- Step 5. Save ----
ggsave(file.path(out_dir_d50_QC, 
  "diff132_NeuroMarkers_ctrl_d30_d50.pdf"),
  Dev_Marker_Abundance,
  width = 12, height = 12, device = cairo_pdf
)
```


### VIIe. Abundance of Pre/Post Synaptic Markers in Ctrl iN/iDA day 30 & day 50
``` {r}
# --------------------------------------------------- #
# neuro QC plots
# Abundance of Pre/Post Synaptic Markers in Ctrl day 30 & day 50
# --------------------------------------------------- #

# --- Step 1. Define Developmental Marker Gene List ----
presyn_genes <- c("BSN", "CPLX1", "CPLX2", "ELKS1", "MUNC13A", "MUNC13B", "MUNC18", "NRXN1", 
                  "NRXN2", "NRXN3", "PCLO", "RAB3A", "RIM1", "RIM2", "RIMBP2", "SNAP25", "STX1A", 
                  "STX1B", "SV2A", "SV2B", "SV2C", "SYN1", "SYN2", "SYP", "SYT1", "SYT2", "SYT7", 
                  "VAMP1", "VAMP2", "VGLUT1", "VGLUT2", "VGLUT3"
)


postsyn_genes <- c(
"DLG4", "DLG3", "DLG2", "SHANK1", "SHANK2", "SHANK3", "HOMER1", "HOMER2", "HOMER3", "NLGN1", 
"NLGN2", "NLGN3", "NLGN4X", "GPHN", "SYNGAP1", "GRIN1", "GRIN2A", "GRIN2B", "GRIA1", "GRIA2", 
"GRIA3", "GRIA4", "GABRA1", "GABRA2", "GABRA3", "GABRA5", "GABRB1", "GABRB2", "GABRB3", "GABRG2", 
"CAMK2A", "CAMK2B", "PPP1R9B", "NRGN", "NPTX2"
)


# --- Step 2. Define presynaptic and postsynaptic gene lists ---
presyn_df <- tibble::tibble(Genes = presyn_genes, marker_type = "Presynaptic")
postsyn_df <- tibble::tibble(Genes = postsyn_genes, marker_type = "Postsynaptic")
synapse_genes_df <- bind_rows(presyn_df, postsyn_df)


# --- Step 3. Filter and transform data for control samples at Day 30/50 ---
synapse_long <- clean_d50_transformed_df %>%
  filter(Genes %in% synapse_genes_df$Genes) %>%
  select(Genes, neuron, day, mean_ctrl) %>%
  inner_join(synapse_genes_df, by = "Genes") %>%
  mutate(
    day = paste("Day", day),                  # Convert numeric to "Day X"
    log2_abundance = log2(mean_ctrl)          # Apply log2 transform
  )


# --- Step 4.  Summarize per gene and reshape to wide for change calculation ---
delta_df <- synapse_long %>%
  group_by(Genes, neuron, marker_type, day) %>%
  summarise(log2_abundance = mean(log2_abundance, na.rm = TRUE), .groups = "drop") %>%
  pivot_wider(names_from = day, values_from = log2_abundance) %>%
  filter(!is.na(`Day 30`) & !is.na(`Day 50`)) %>%
  mutate(direction = ifelse(`Day 50` > `Day 30`, "up", "down"))


# --- Step 5. Reshape back to long format for plotting ---
long_with_direction <- delta_df %>%
  pivot_longer(cols = c(`Day 30`, `Day 50`), names_to = "day", values_to = "log2_abundance") %>%
  mutate(day = factor(day, levels = c("Day 30", "Day 50")))


# --- Step 6.  Plot function with per-gene trajectories and group average overlays ---
SynapseTrajectoryPlot <- function(df) {
  ggplot(df, aes(x = day, y = log2_abundance)) +
    # Individual gene lines by direction
    geom_line(aes(group = Genes, color = direction), alpha = 0.3, linewidth = 0.4) +
    
    # Overlay group mean lines
    stat_summary(
      aes(group = interaction(marker_type, neuron)),
      fun = mean, geom = "line",
      color = "grey40", linewidth = 2
    ) +
    stat_summary(
      aes(group = interaction(marker_type, neuron)),
      fun = mean, geom = "point",
      color = "grey30", size = 4
    ) +
    facet_grid(marker_type ~ neuron) +
    scale_color_manual(values = c("up" = "#e31a1c", "down" = "#1f78b4")) +
    theme_bw() +
    labs(
      title = "log2 Abundance Trajectories of \n Synaptic Genes (Control Neurons)",
      x = "Day", y = "log2(Abundance)",
      color = "Direction"
    ) +
    theme(
      panel.grid = element_blank(),
      legend.position = "bottom",
      )
}


# --- Step 7.  Generate and save plot ---
Synaptic_Marker_Abundance <- SynapseTrajectoryPlot(long_with_direction)
Synaptic_Marker_Abundance

ggsave(file.path(out_dir_d50_QC, 
  "diff132_SynapticMarkers_ctrl_d30_d50.pdf"),
  Synaptic_Marker_Abundance,
  width = 4, height = 8, device = cairo_pdf
)

```


### VIIf. "NeuroDev" protein-list trajectory for day 30 & day 50 for select genotypes
```{r}
# --------------------------------------------------- #
# neuro QC plots
# NeuroDev protein trajectory for day 30 & day 50 for select genotypes 
# --------------------------------------------------- #

# For Ctrl, GRN, ASAH1, GBA1 and SMPD1 have both day30 and day50 data. plot neuronal markers etc and see if they increase.
# Define your gene sets
es_drivers <- c("ATF1", "CUX1", "MKI67", "NANOG", "POU5F1", "SOX2")
neuron_drivers <- c(
  "BDNF", "CAMK2B", "CRTC1", "DCX", "JUN", "MAP2", "NCAM1",
  "NEFH", "NEFL", "NEFM", "NES", "POU3F2", "SLC17A7", "SYN1",
  "SYP", "TUBB3", "TH", "BSN", "SYNJ1", "GAP43", "PSD95", "VGLUT",
  "SYN2", "SYN3", "NGN"
)
# --- Step 1. Create marker label dataframe
marker_genes_df <- tibble(
  Genes = c(es_drivers, neuron_drivers),
  marker_type = c(rep("ES-driver", length(es_drivers)),
                  rep("Neuron-driver", length(neuron_drivers)))
)
# --- Step 2. Filter for NeuroDev == TRUE
d30_neurodev <- complete_data_annotated_day30 %>% filter(NeuroDev == TRUE)
d50_neurodev <- complete_data_annotated_day50 %>% filter(NeuroDev == TRUE)


# --- Step 3.  Reshape to long format and add 'day'
pivot_neurodev <- function(df, day_label) {
  df %>%
    select(Genes, matches("_log2_fold_change$")) %>%
    pivot_longer(
      cols = -Genes,
      names_to = "sample",
      values_to = "log2FC"
    ) %>%
    mutate(
      day = day_label,
      sample = str_remove(sample, "_log2_fold_change$"),
      genotype = str_extract(sample, "^[^_]+"),
      neuron = str_extract(sample, "(?<=_)(iDA|iN)$")
    )
}

d30_long <- pivot_neurodev(d30_neurodev, "Day 30")
d50_long <- pivot_neurodev(d50_neurodev, "Day 50")


# --- Step 4. Combine
combined_df <- bind_rows(d30_long, d50_long)

# Join annotation info
combined_df_annotated <- combined_df %>%
  inner_join(marker_genes_df, by = "Genes")

# Now you can summarize or plot
summary_df <- combined_df_annotated %>%
  filter(genotype %in% c("ctrl", "ASAH1", "GBA1", "SMPD1", "GRN")) %>%
  group_by(marker_type, genotype, neuron, day) %>%
  summarise(mean_log2FC = mean(log2FC, na.rm = TRUE), .groups = "drop")


# --- Step 5. Plot
NeuoDevd30d50 <- ggplot(
  combined_df_annotated %>% filter(genotype %in% c("ctrl", "ASAH1", "GBA1", "SMPD1", "GRN")),
  aes(x = day, y = log2FC, group = interaction(Genes, neuron), marker_type = marker_type)
) +
  # Individual traces
  geom_line(aes(color = neuron), alpha = 0.2, linewidth = 0.5) +
  geom_point(aes(color = neuron), alpha = 0.4, size = 1) +

  # Mean lines
  stat_summary(
    aes(group = neuron, color = neuron),
    fun = mean, geom = "line", linewidth = 1.2
  ) +
  stat_summary(
    aes(group = neuron, fill = neuron),
    fun = mean, geom = "point", size = 2.5, color = "black", shape = 21
  ) +

  facet_grid(rows = vars(marker_type), cols = vars(genotype)) +
  scale_color_manual(values = c("iN" = "grey60", "iDA" = "grey80")) +
  scale_fill_manual(values = c("iN" = "grey60", "iDA" = "grey80")) +
  labs(
    title = "log2FC of NeuroDev Genes by Marker Type and Genotype",
    x = "Day", y = "log2 Fold Change"
  ) +
  theme_bw() +
  theme(
    strip.text = element_text(face = "bold"),
    panel.grid = element_blank()
  )

NeuoDevd30d50


# --- Step 6. Save
ggsave(file.path(out_dir_d50_QC,
  "diff132_NeuoDevd30d50.pdf"),
  NeuoDevd30d50,
  width = 8, height = 6, device = cairo_pdf)

```


### VIIg. Violin Plot Function for LSD Organelle Proteomics
``` {r}
# --------------------------------------------------- #
# Violin Plot Function for LSD Organelle Proteomics 
# This function creates violin plots of log2 fold change values for proteins
# grouped by subcellular annotation, genotype, and neuron type.
# --------------------------------------------------- #

# --- 0. create output directory 
out_dir_d50_violins <- "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/Organelle_Violin"
dir.create(out_dir_d50_violins, recursive = TRUE, showWarnings = FALSE)

# --- Step 1. create plotting function violins 
plot_log2fc_violin <- function(data, annotations, genotypes) {

  # 1. Gather gene identifiers for each annotation
  annotation_genes <- map_dfr(annotations, function(ann) {
    data %>%
      filter(!!sym(ann)) %>%      # Select genes with the current annotation
      select(Genes) %>%
      mutate(annotation = ann)    # Label them with the annotation name
  })

  # 2. Join gene annotations back to the full dataset
  plot_df <- annotation_genes %>%
    left_join(data, by = "Genes")

  # 3. Generate column names for iDA and iN comparisons for selected genotypes
  fc_cols <- unlist(lapply(genotypes, function(g) {
    paste0(g, c("_iDA_log2_fold_change", "_iN_log2_fold_change"))
  }))

  # 4. Reshape data into long format for plotting
  plot_df_long <- plot_df %>%
    select(Genes, annotation, all_of(fc_cols)) %>%
    pivot_longer(
      cols = -c(Genes, annotation),
      names_to = "sample", values_to = "log2FC"
    ) %>%
    separate(sample, into = c("genotype", "neuron", NA), sep = "_")

  # 5. Trim y-axis: focus on core 75% of distribution
  full_range <- range(plot_df_long$log2FC, na.rm = TRUE)
  midpoint <- median(plot_df_long$log2FC, na.rm = TRUE)
  range_width <- diff(full_range)
  scaled_half_range <- 0.15 * range_width  # 75% total span
  lower_lim <- midpoint - scaled_half_range
  upper_lim <- midpoint + scaled_half_range

  # 6. Generate the violin plot
  ggplot(plot_df_long, aes(x = neuron, y = log2FC, fill = annotation)) +
    geom_jitter(color = "grey80", width = 0.1, size = 0.5, alpha = 0.5) +  # White dots for individual values
    geom_violin(scale = "width", trim = FALSE, color = NA, width = 0.85) +
    geom_boxplot(width = 0.2, fill = "white", outlier.shape = NA, color = "black", linewidth = 0.3) +
    geom_hline(yintercept = 0, linetype = "dashed", color = "black", linewidth = 0.3) +
    facet_grid(rows = vars(genotype), cols = vars(annotation), scales = "free_y") +
    scale_fill_brewer(palette = "Paired") +
    labs(
      title = "log2 Fold Change of Proteins by Annotation and Genotype",
      x = "Neuron Type", y = "log2 Fold Change"
    ) +
    coord_cartesian(ylim = c(lower_lim, upper_lim)) +
    theme_bw() +
    theme(
      strip.text = element_text(size = 6, face = "bold"),
      axis.text.x = element_text(angle = 0, hjust = 0.5),
      panel.grid = element_blank()
    )
}

# --- Step 2. Run and Save Plot of select Genotypes 
LSD_d50_Violin_plot <- plot_log2fc_violin(
  data = complete_data_annotated_day50,
  #annotations = c("Mito","Mito.IMS","Mito.Matrix","Mito.MIM","Mito.MOM","OXPHOS","mtComplexI"),
  annotations = c("Lysosome","Endo_iN_curated_Hundley","EarlyEndosome","RecyclingEndosome", "SynGO","Presynaptic","Postsynaptic", "SynapseSVs","SVfusion","Svendocytosis","Svexocytosis"),
  genotypes = c("ASAH1", "ATP13A2","SMPD1", "GBA1", "MCOLN1")
)
LSD_d50_Violin_plot


# Annotations:
# "Mito","MitoIMS","MitoMatrix","MitoMIM","MitoMOM","OXPHOS","mtComplexI","Golgi","Lysosome","ER","Cytoplasm","Nucleus","Autophagy","SynGO","Endo_iN_curated_Hundley","SynapseSVs","Presynaptic","Postsynaptic","NeuroDev","EndoLyso","EarlyEndosome","RecyclingEndosome","SVfusion","Svendocytosis","Svexocytosis","vATPase"     

#annotations = c("Mito","Mito.IMS","Mito.Matrix","Mito.MIM","Mito.MOM","OXPHOS","mtComplexI"),
#annotations = c("Mito","Golgi","Lysosome","ER","Autophagy","Endo_iN_curated_Hundley","SynGO")
#annotations = c("EndoLyso","Presynaptic","Postsynaptic", "SynGO")


# --- Step 3. Save as square-format PDF
ggsave(file.path(out_dir_d50_violins, 
  "diff132_d50_LSD_Violin_plot_ASAH1-ATP13A2-SMPD1-GBA1-MCOLN1_detailedEndoLysoSynGO_SV.pdf"),
  LSD_d50_Violin_plot,
  width = 12, height = 9, device = cairo_pdf)
```



# VIII. Organelle Cross-DF correlations
have now complete_data_annotated_day50, which contains all the organelle annotations across all genotypes
easiest way now is to calculate the correlations of log2fc across all organelles across all genotypes
maybe get a heatmap for each organelle? Strategy is to get a function that asks for the organelle / annotation to correlate across the whole set of genotypes. 


### VIIIa. Correlation: User-Select organelle annotation  
```{r}
# Load required libraries
library(dplyr)
library(pheatmap)
library(RColorBrewer)
library(dplyr)
library(stringr)

# --------------------------------------------------- #
# Organelle Cross-DF correlations 
# Generate  log2FC_d50_annotated dataframe
# --------------------------------------------------- #

# --- Step 1: Extract log2FC columns (columns 1–47)
log2fc_d50 <- complete_data_annotated_day50[, 1:48]

# --- Step 2: Extract annotation columns
annotation_cols <- c("Mito", "MitoIMS", "MitoMatrix", "MitoMIM", "MitoMOM", "OXPHOS",
                     "mtComplexI", "Golgi", "Lysosome", "ER", "Cytoplasm", "Nucleus",
                     "Autophagy", "SynGO", "Endo_iN_curated_Hundley", "SynapseSVs",
                     "Presynaptic", "Postsynaptic", "NeuroDev", "EndoLyso", "EarlyEndosome",
                     "RecyclingEndosome", "SVfusion", "Svendocytosis", "Svexocytosis", "vATPase")

annotation_d50 <- complete_data_annotated_day50[, annotation_cols]

# --- Step 3: Clean column names: remove "_log2_fold_change" suffix
colnames(log2fc_d50) <- str_replace(colnames(log2fc_d50), "_log2_fold_change$", "")

# --- Step 4: Combine cleaned log2FC values with annotations
log2FC_d50_annotated <- bind_cols(log2fc_d50, annotation_d50)
write.csv(log2FC_d50_annotated, file = file.path(out_dir_d50_dataframes, "log2FC_d50_annotated.csv"),row.names = FALSE)


# --------------------------------------------------- #
# Organelle Cross-DF correlations 
# Function for user selected correlation of annotation
# --------------------------------------------------- #

# This function computes and visualizes the correlation of log2 fold changes (log2FC)
# across multiple genotypes for genes annotated to selected organelles.
# It generates both a correlation matrix (as CSV) and a heatmap (as PDF).

# --- Step 5. Define function: 
correlate_log2fc_annotations <- function(data, annotations, basedir, prefix = "diff132_d50_neuroLSD_correlation") {

  # Step 1: Filter genes belonging to any of the selected annotations
  filtered_data <- data %>%
    filter(if_any(all_of(annotations), ~ .x == TRUE))

  # Step 2: Extract log2FC values (columns 2–47), replace NAs with 0
  log2fc_matrix <- filtered_data[, 2:47]
  log2fc_matrix[is.na(log2fc_matrix)] <- 0
  rownames(log2fc_matrix) <- filtered_data$Genes  # set gene names as rownames

  # Step 3: Compute correlation matrix (genotype × genotype)
  correlation_matrix <- cor(log2fc_matrix, use = "pairwise.complete.obs")
  correlation_matrix[is.na(correlation_matrix)] <- 0  # ensure no missing values

  # Step 4: Create sample metadata from column names (genotype and neuron type)
  meta <- str_match(colnames(correlation_matrix), "^(.+?)_(iDA|iN)")
  annotation_df <- data.frame(
    Genotype = meta[, 2],
    Neuron = meta[, 3]
  )
  rownames(annotation_df) <- colnames(correlation_matrix)

  # Step 5: Define color mappings for annotation
  genotype_colors <- setNames(
    colorRampPalette(brewer.pal(8, "Paired"))(length(unique(annotation_df$Genotype))),
    unique(annotation_df$Genotype)
  )
  neuron_colors <- c("iN" = "grey50", "iDA" = "grey80")
  ann_colors <- list(Genotype = genotype_colors, Neuron = neuron_colors)

  # Step 6: Construct file paths using input annotations
  annotation_label <- paste(annotations, collapse = "_")
  csv_path <- file.path(basedir, paste0(prefix, "_", annotation_label, ".csv"))
  pdf_path <- file.path(basedir, paste0(prefix, "_", annotation_label, ".pdf"))

  # Step 7: Save correlation matrix as CSV
  write.csv(correlation_matrix, file = csv_path, row.names = TRUE)

  print(dim(correlation_matrix))
  print(head(annotation_df))

  # Step 8: Plot heatmap and save as PDF
  pdf(pdf_path, width = 8, height = 7)  
  pheatmap(
    mat = correlation_matrix,
    color = colorRampPalette(rev(brewer.pal(11, "RdYlBu")))(100),
    annotation_col = annotation_df,
    annotation_row = annotation_df,
    annotation_colors = ann_colors,
    cluster_rows = TRUE,
    cluster_cols = TRUE,
    show_rownames = TRUE,
    show_colnames = TRUE,
    border_color = NA,
    fontsize = 6,
    main = paste("Correlation –", annotation_label)
    # cellheight = 15, cellwidth = 15 # Uncomment for fixed-size cells
  )
  dev.off()

  return(correlation_matrix)
}


# --- Step 6. Run the Function
# This example correlates log2FC across genotypes for SynGO and Lysosomal genes
# run dev.off to clear plotting space
dev.off()
correlate_log2fc_annotations(
  data = log2FC_d50_annotated,
  annotations = c("EndoLyso","Presynaptic","Postsynaptic", "SynGO", "SynapseSVs","SVfusion","Svendocytosis", "Svexocytosis"),
  basedir = out_dir_d50_CrossCorr
)


# Annotations:
# "Mito", "MitoIMS", "MitoMatrix", "MitoMIM", "MitoMOM", "OXPHOS",
#                      "mtComplexI", "Golgi", "Lysosome", "ER", "Cytoplasm", "Nucleus",
#                      "Autophagy", "SynGO", "Endo_iN_curated_Hundley", "SynapseSVs",
#                      "Presynaptic", "Postsynaptic", "NeuroDev", "EndoLyso", "EarlyEndosome",
#                      "RecyclingEndosome", "SVfusion", "Svendocytosis", "Svexocytosis", "vATPase"




```


### VIII???? Disease Impact Scoring from Correlation Analysis
```{r}
###########################################################
# Disease Impact Scoring from Correlation Analysis
# ---------------------------------------------------------
# Goal: Rank genotypes by their average correlation pattern
# across selected organelle annotations. Lowest correlation
# → highest impact. Separate scoring for iN and iDA.
###########################################################

# --- Function: Compute impact scores for a neuron type ----
impact_score_from_corr <- function(corr_mat, neuron_type) {
  
  # 1. Select correlation submatrix for the neuron type
  neuron_cols <- grep(paste0("_", neuron_type, "$"), 
                      colnames(corr_mat), value = TRUE)
  corr_sub <- corr_mat[neuron_cols, neuron_cols, drop = FALSE]
  
  # 2. Compute mean correlation for each genotype
  mean_corr <- rowMeans(corr_sub, na.rm = TRUE)
  
  # 3. Rank genotypes (lowest correlation = highest impact)
  ranks <- rank(mean_corr, ties.method = "average")
  
  # 4. Return tidy table
  tibble(
    Genotype = gsub(paste0("_", neuron_type), "", names(mean_corr)),
    Neuron   = neuron_type,
    MeanCorr = mean_corr,
    Rank     = ranks
  )
}


# --- Step 1: Generate correlation matrix ------------------
corr_mat <- correlate_log2fc_annotations(
  data = log2FC_d50_annotated,
  annotations = c("Endo_iN_curated_Hundley","EarlyEndosome", "RecyclingEndosome", 
                  "Presynaptic", "Postsynaptic", "SynGO",
                  "SynapseSVs", "SVfusion", "Svendocytosis", "Svexocytosis", "vATPase"),
  basedir = out_dir_d50_CrossCorr
)


# --- Step 2: Compute impact scores for iN and iDA ---------
impact_scores_iN  <- impact_score_from_corr(corr_mat, "iN")
impact_scores_iDA <- impact_score_from_corr(corr_mat, "iDA")

# Combine into one dataframe
impact_scores <- bind_rows(impact_scores_iN, impact_scores_iDA)


# --- Function: Plot impact heatmap for one neuron type ----
plot_impact_heatmap <- function(impact_scores, neuron_type, out_dir) {
  
  # 1. Subset for the neuron type
  df_sub <- impact_scores %>% filter(Neuron == neuron_type)
  
  # 2. Order by rank (lowest = top)
  df_sub <- df_sub %>% arrange(Rank)
  
  # 3. Build matrix for heatmap (rows = Genotype, col = Rank)
  impact_mat <- df_sub %>%
    select(Genotype, Rank) %>%
    column_to_rownames("Genotype") %>%
    as.matrix()
  
  # 4. Save heatmap as PDF
  pdf(file.path(out_dir, paste0("disease_impact_scoring_", neuron_type, ".pdf")), 
      width = 4, height = 5)
  pheatmap(
    mat            = impact_mat,
    color          = colorRampPalette(c("red","white"))(100),
    cluster_rows   = FALSE,       # keep custom order
    cluster_cols   = FALSE,
    main           = paste("Disease Impact Scoring –", neuron_type),
    fontsize       = 7,
    border_color   = "grey80",
    legend         = FALSE,
    display_numbers= TRUE,        # show rank values
    cellwidth      = 15,
    cellheight     = 15
  )
}


# --- Step 3: Create heatmaps for both neuron types --------
plot_impact_heatmap(impact_scores, "iN",  out_dir_d50_CrossCorr)
plot_impact_heatmap(impact_scores, "iDA", out_dir_d50_CrossCorr)

dev.off()
dev.off()
```


### VIIIb. Correlation: All organelle annotations
```{r}
# --------------------------------------------------- #
# Organelle Cross-DF correlations 
# All Organelle-annotation correlation of all genotypes
# --------------------------------------------------- #

# idea is that to calculate correlation of annotated organelles across all genotypes
# the organelles that have high corr do not change much between the genotypes
# the organelles that do anti-correlate change more between them ==> more interesting biology? 

# --- Step 1. define function 
run_all_organelle_corr <- function(df, annotations) {
  # KO‐effect columns = everything that ends with “_iDA” or “_iN”
  ko_cols <- grep("_(iDA|iN)$", names(df), value = TRUE)

  purrr::map_dfr(annotations, function(ann) {
    purrr::map_dfr(ko_cols, function(ko) {
      x <- df[[ko]]                 # log2-FC vector
      y <- as.numeric(df[[ann]])    # 1/0 membership
      keep <- !(is.na(x) | is.na(y))
      if (sum(keep) < 5) return(NULL)

      ct <- suppressWarnings(cor.test(x[keep], y[keep], method = "spearman"))
      tibble(
        KO        = ko,
        Organelle = ann,
        r         = unname(ct$estimate),
        p         = ct$p.value
      )
    })
  })
}


# --- Step 2. define annotations to correlate  
org_corr_df <- run_all_organelle_corr(
  log2FC_d50_annotated,
  annotations = c("Mito", "MitoIMS", "MitoMatrix", "MitoMIM", "MitoMOM", "OXPHOS",
                     "mtComplexI", "Golgi", "Lysosome", "ER", "Cytoplasm", "Nucleus",
                     "Autophagy", "SynGO", "Endo_iN_curated_Hundley", "SynapseSVs",
                     "Presynaptic", "Postsynaptic", "NeuroDev", "EndoLyso", "EarlyEndosome",
                     "RecyclingEndosome", "SVfusion", "Svendocytosis", "Svexocytosis", "vATPase")
)


# --- Step 3. convert into martix and define color schmes + plotting  
# Convert to wide matrix: KO × Organelle
org_corr_mat <- org_corr_df %>%
  select(KO, Organelle, r) %>%
  pivot_wider(names_from = Organelle, values_from = r) %>%
  column_to_rownames("KO") %>%
  as.matrix()

# Replace NA with 0
org_corr_mat[is.na(org_corr_mat)] <- 0

# Define KO type (iN vs iDA) from KO names
ko_type <- data.frame(CellType = ifelse(grepl("_iDA$", rownames(org_corr_mat)), "iDA", "iN"))
rownames(ko_type) <- rownames(org_corr_mat)

# Color scheme for celltypes 
celltype_colors <- c(iDA = "grey80", iN = "grey40")

# Plot the heatmap
annotCorrLSD <- pheatmap::pheatmap(
  org_corr_mat,
  color = rev(RColorBrewer::brewer.pal(11, "RdYlBu")),
  na_col = "grey90",
  cluster_rows = TRUE,
  cluster_cols = TRUE,
  angle_col = 90,
  cellheight = 15,
  cellwidth  = 15,
  main = paste("Organelle Correlation"),
  fontsize = 10,
  border_color = NA,
  annotation_row = ko_type,
  annotation_colors = list(CellType = celltype_colors)
)


annotCorrLSD


# --- Step 4. Save pdf and csv 
pdf(file.path(out_dir_d50_CrossCorr,"diff132_annotCorrLSD.pdf"),
    width = 12, height = 16, useDingbats = FALSE)
print(annotCorrLSD)
dev.off()

## save org_corr_mat as csv file in the same directory
write.csv(org_corr_mat, file = file.path(out_dir_d50_CrossCorr, "diff132_organelle_corr_matrix.csv"),row.names = TRUE)





# --------------------------------------------------- #
# Organelle Cross-DF correlations 
# Cross-correlation matrix of genotypes for each organelle
# --------------------------------------------------- #

# --- Step 5. Function: compute KO × KO correlation matrix for a given organelle
plot_ko_corr_matrix <- function(organelle_name, df = log2FC_d50_annotated) {
  ko_cols <- grep("_(iDA|iN)$", names(df), value = TRUE)
  gene_filter <- df[[organelle_name]] == 1
  mat <- df[gene_filter, ko_cols, drop = FALSE]

  # Drop if insufficient data
  if (nrow(mat) < 5) return(NULL)

  corr_mat <- cor(mat, use = "pairwise.complete.obs", method = "spearman")

  # Build heatmap object
  pheatmap::pheatmap(
    corr_mat,
    main = organelle_name,
    color = rev(RColorBrewer::brewer.pal(11, "RdYlBu")),
    silent = TRUE,
    cellheight = 6,
    cellwidth  = 6,
    na_col = "grey90",
    cluster_rows = TRUE,
    cluster_cols = TRUE,
    #angle_col = 90,
    border_color = NA,
    fontsize = 6,
    annotation_row = ko_type,
    annotation_colors = list(CellType = celltype_colors)
  )
}


# --- Step 6. Annotations for plotting
all_ann <- c(
  "Mito", "MitoIMS", "MitoMatrix", "MitoMIM", "MitoMOM", "OXPHOS",
                     "mtComplexI", "Golgi", "Lysosome", "ER", "Cytoplasm", "Nucleus",
                     "Autophagy", "SynGO", "Endo_iN_curated_Hundley", "SynapseSVs",
                     "Presynaptic", "Postsynaptic", "NeuroDev", "EndoLyso", "EarlyEndosome",
                     "RecyclingEndosome", "SVfusion", "Svendocytosis", "Svexocytosis", "vATPase" 
)


# --- Step 7. per-organelle KO×KO heatmaps
heatmap_list <- lapply(all_ann, function(org) {
  if (!org %in% names(log2FC_d50_annotated)) return(NULL)   # skip if column absent
  plot_ko_corr_matrix(org, df = log2FC_d50_annotated)
})
heatmap_list <- Filter(Negate(is.null), heatmap_list)       # drop NULLs


# --- Step 8.  Arrange into a multi-panel figure (adjust ncol as needed) & save as pdf
pdf(file.path(out_dir_d50_CrossCorr,"diff132_annotCorrLSD_facet.pdf"),
    width = 38, height = 38, useDingbats = FALSE)

gridExtra::grid.arrange(
  grobs = lapply(heatmap_list, `[[`, "gtable"),
  ncol = 4
)

dev.off()

```




### VIIIc. Average correlation per annotation across genotypes
```{r}
# --------------------------------------------------- #
# Organelle Cross-DF correlations 
# Plot average correlation per annotation across genotypes
# --------------------------------------------------- #

# --- Step 1. Define function for correlation caclculation based on user input annotations 
plot_avg_corr_per_genotype <- function(corr_mat, annotations, out_path = NULL) {
  # Ensure annotations are present in the matrix
  valid_annotations <- annotations[annotations %in% colnames(corr_mat)]
  if (length(valid_annotations) == 0) {
    stop("None of the specified annotations are present in the correlation matrix.")
  }

  # Label for title and filename
  ann_label <- paste(valid_annotations, collapse = "_")
  ann_title <- paste(valid_annotations, collapse = ", ")

  # Subset matrix and compute mean and SEM per genotype (row)
  corr_subset <- corr_mat[, valid_annotations, drop = FALSE]
  avg_corr <- rowMeans(corr_subset, na.rm = TRUE)
  sem_corr <- apply(corr_subset, 1, function(x) sd(x, na.rm = TRUE) / sqrt(sum(!is.na(x))))

  avg_corr_df <- data.frame(
    Genotype = rownames(corr_mat),
    AvgCorr = avg_corr,
    SEM = sem_corr
  )

  p <- ggplot(avg_corr_df, aes(x = reorder(Genotype, AvgCorr), y = AvgCorr)) +
    geom_bar(stat = "identity", fill = "grey70", width = 0.7) +
    geom_errorbar(aes(ymin = AvgCorr - SEM, ymax = AvgCorr + SEM), width = 0.2) +
    geom_hline(yintercept = 0, linetype = "dashed", color = "black", linewidth = 0.3) +
    theme_bw(base_size = 6) +
    labs(
      title = paste("Average Organelle Correlation per Genotype -", ann_title),
      x = "Genotype", y = "Average Correlation (r)"
    ) +
    theme(
      axis.text.x = element_text(angle = 90, hjust = 1),
      panel.grid = element_blank()
    )

  # Save if output path is provided
  if (!is.null(out_path)) {
    out_file <- file.path(out_path, paste0("avg_corr_per_genotype_", ann_label, ".pdf"))
    ggsave(out_file, p, width = 5, height = 5, device = cairo_pdf)
  }

  return(p)
}

# --- Step 2. Call plotting function and input annotation of interest to plot 
avg_corr_plot <- plot_avg_corr_per_genotype(
  corr_mat = org_corr_mat,
  annotations = c("SVfusion","Svendocytosis", "Svexocytosis"),
  out_path = out_dir_d50_CrossCorr_annotavg
)


# all_ann <- c("Mito", "MitoIMS", "MitoMatrix", "MitoMIM", "MitoMOM", "OXPHOS",
#                      "mtComplexI", "Golgi", "Lysosome", "ER", "Cytoplasm", "Nucleus",
#                      "Autophagy", "SynGO", "Endo_iN_curated_Hundley", "SynapseSVs",
#                      "Presynaptic", "Postsynaptic", "NeuroDev", "EndoLyso", "EarlyEndosome",
#                      "RecyclingEndosome", "SVfusion", "Svendocytosis", "Svexocytosis", "vATPase")


```


### VIIId. Average correlation per annotation across genotypes (disease class color)
```{r}
# --------------------------------------------------- #
# Organelle Cross-DF correlations 
# Plot average correlation per annotation across genotypes
# color by disease class color 
# can facet wrap 
# split into graph for iN and iDA
# --------------------------------------------------- #

# --- Step 1. Define colors for boxplots
col_boxplots_corr <- c(
  ASAH1 = "#D53E4F",
  ATP13A2 = "#E6F598",
  CLN3 = "#E6F598",
  CLN5 = "#FEE08B",
  CLN6 = "#FEE08B",
  CLN8 = "#FEE08B",
  CTSF = "#FEE08B",
  CTSD = "#FEE08B",
  DNAJC5 = "#FEE08B",
  GAA = "#66C2A5",
  GBA1 = "#D53E4F",
  GRN = "#FEE08B",
  HEXA = "#D53E4F",
  HEXB = "#D53E4F",
  LIPA = "#66C2A5",
  MCOLN1 = "#E6F598",
  MFSD8 = "#FEE08B",
  NPC1 = "#E6F598",
  NPC2 = "#E6F598",
  PSAP = "#D53E4F",
  SMPD1 = "#D53E4F",
  TPP1 = "#FEE08B",
  PTT1 = "#FEE08B"
)

# Expand color map to include iN and iDA variants
col_boxplots_corr_expanded <- unlist(lapply(names(col_boxplots_corr), function(g) {
  setNames(rep(col_boxplots_corr[[g]], 2), paste0(g, c("_iN", "_iDA")))
}))

# --- Step 2. Bargraph function of average correlation per annotation and genotype ---
plot_bar_corr_split_neurons <- function(corr_mat, annotations, color_map, out_path = NULL) {
  # Step 1. Filter annotations
  valid_annotations <- annotations[annotations %in% colnames(corr_mat)]
  if (length(valid_annotations) == 0) stop("None of the annotations found in matrix.")
  
  # Step 2. Prepare data
  present_genotypes <- rownames(corr_mat)
  filtered_colors <- color_map[names(color_map) %in% present_genotypes]
  
  corr_long <- as.data.frame(corr_mat[, valid_annotations, drop = FALSE]) %>%
    rownames_to_column("Genotype") %>%
    pivot_longer(-Genotype, names_to = "Annotation", values_to = "Correlation") %>%
    filter(Genotype %in% names(filtered_colors)) %>%
    mutate(
      neuron_type = ifelse(str_detect(Genotype, "_iN$"), "iN",
                     ifelse(str_detect(Genotype, "_iDA$"), "iDA", "Other")),
      base_genotype = str_remove(Genotype, "_iN$|_iDA$")
    ) %>%
    group_by(Genotype, base_genotype, neuron_type, Annotation) %>%
    summarise(
      mean_corr = mean(Correlation, na.rm = TRUE),
      sem_corr = sd(Correlation, na.rm = TRUE) / sqrt(n()),
      .groups = "drop"
    )
  
  ann2_label <- paste(valid_annotations, collapse = "_")
  ann2_title <- paste(valid_annotations, collapse = ", ")
  
  # Helper to plot one neuron type
  plot_one <- function(df_sub, neuron_type) {
    df_sub <- df_sub %>% arrange(mean_corr) %>%
      mutate(base_genotype = factor(base_genotype, levels = unique(base_genotype)))
    
    ggplot(df_sub, aes(x = base_genotype, y = mean_corr, fill = Genotype)) +
      geom_bar(stat = "identity", color = "black", width = 0.6, linewidth = 0.2) +
      geom_errorbar(aes(ymin = mean_corr - sem_corr, ymax = mean_corr + sem_corr), width = 0.2) +
      scale_fill_manual(values = filtered_colors) +
      geom_hline(yintercept = 0, linetype = "dashed", color = "black", linewidth = 0.3) +
      labs(
        title = paste("Average Organelle Correlation per Genotype –", neuron_type, "-", ann2_title),
        x = "Genotype", y = "Mean Correlation (±SEM)"
      ) +
      theme_bw(base_size = 6) +
      theme(
        axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
        legend.position = "none",
        panel.grid = element_blank()
      )
  }
  
  # Generate iN and iDA plots separately
  p_iN <- plot_one(filter(corr_long, neuron_type == "iN"), "iN")
  p_iDA <- plot_one(filter(corr_long, neuron_type == "iDA"), "iDA")
  
  # Save if output path given
  if (!is.null(out_path)) {
    ggsave(file.path(out_path, paste0("barplot_corr_per_genotype_", ann2_label, "_iN.pdf")),
           plot = p_iN, width = 2, height = 2, device = cairo_pdf)
    ggsave(file.path(out_path, paste0("barplot_corr_per_genotype_", ann2_label, "_iDA.pdf")),
           plot = p_iDA, width = 2, height = 2, device = cairo_pdf)
  }
  
  return(list(iN = p_iN, iDA = p_iDA))
}

# --- Step 3. Call plotting function & define input annotations 
plots <- plot_bar_corr_split_neurons(
  corr_mat = org_corr_mat,
  annotations = c("SynapseSVs"),
  color_map = col_boxplots_corr_expanded,
  out_path = out_dir_d50_CrossCorr_annotavg
)





 # all_ann <- c("Mito", "MitoIMS", "MitoMatrix", "MitoMIM", "MitoMOM", "OXPHOS",
 #                     "mtComplexI", "Golgi", "Lysosome", "ER", "Cytoplasm", "Nucleus",
 #                     "Autophagy", "SynGO", "Endo_iN_curated_Hundley", "SynapseSVs",
 #                     "Presynaptic", "Postsynaptic", "NeuroDev", "EndoLyso", "EarlyEndosome",
 #                     "RecyclingEndosome", "SVfusion", "Svendocytosis", "Svexocytosis", "vATPase")



```


### VIIIe. Average correlation per nMOST GO cluster across genotypes (disease class color)
```{r}
# --------------------------------------------------- #
# nMOST LSD GO signatures of select Clusters (Neurons)
# --------------------------------------------------- #
# --- Step 1. Load GO annotation
nMOST_GOannot <- read.csv("/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/datasets/cell_protein_clusters_20250711KAO.csv",
                          header = TRUE, sep = ',', stringsAsFactors = FALSE)

# --- Step 2. Partial string matching function
get_cluster_by_partial_match <- function(gene, reference_df) {
  match_row <- reference_df[str_detect(reference_df$Gene.names, paste0("\\b", gene, "\\b")), ]
  if (nrow(match_row) > 0) return(match_row$protein_hclust_clusters[1])
  return(NA)
}

# --- Step 3. Annotate clusters using partial match
log2FC_d50_annotated_GO <- log2FC_d50_annotated %>%
  rowwise() %>%
  mutate(Cluster = get_cluster_by_partial_match(Genes, nMOST_GOannot)) %>%
  ungroup()

# --- Step 4. Save merged dataframe
write.csv(log2FC_d50_annotated_GO, file.path(out_dir_d50_CrossCorr_nMOSTGOavgannnot, "log2FC_d50_annotated_GO.csv"), row.names = FALSE)
write.csv(log2FC_d50_annotated_GO, file.path(out_dir_d50_dataframes, "log2FC_d50_annotated_GO.csv"), row.names = FALSE)

# --- Step 5. Split iN and iDA into separate long-format dataframes
iN_cols <- grep("_iN$", colnames(log2FC_d50_annotated_GO), value = TRUE)
iDA_cols <- grep("_iDA$", colnames(log2FC_d50_annotated_GO), value = TRUE)
shared_cols <- c("Genes", "Cluster")

log2FC_iN_df <- log2FC_d50_annotated_GO %>%
  select(all_of(c(shared_cols, iN_cols))) %>%
  pivot_longer(cols = ends_with("_iN"), names_to = "Group", values_to = "Score") %>%
  mutate(
    KO = str_replace(Group, "_iN$", ""),
    KO_Cell = Group,
    CellType = "iN"
  ) %>%
  filter(!is.na(Cluster), is.finite(Score))

log2FC_iDA_df <- log2FC_d50_annotated_GO %>%
  select(all_of(c(shared_cols, iDA_cols))) %>%
  pivot_longer(cols = ends_with("_iDA"), names_to = "Group", values_to = "Score") %>%
  mutate(
    KO = str_replace(Group, "_iDA$", ""),
    KO_Cell = Group,
    CellType = "iDA"
  ) %>%
  filter(!is.na(Cluster), is.finite(Score))

write.csv(log2FC_iN_df, file.path(out_dir_d50_CrossCorr_nMOSTGOavgannnot, "log2FC_iN_long.csv"), row.names = FALSE)
write.csv(log2FC_iDA_df, file.path(out_dir_d50_CrossCorr_nMOSTGOavgannnot, "log2FC_iDA_long.csv"), row.names = FALSE)

# --- Step 6. Define and expand color palette
col <- c(AGA="grey76", ARSA="grey76", ARSB="grey76", ASAH1="#D53E4F", PPT1="#FEE08B", CTSD="#FEE08B", GRN="#FEE08B",
         ATP13A2="#E6F598", CTSF="#FEE08B", KCTD7="grey76", TPP1="#FEE08B", CLN3="#E6F598", DNAJC5="#FEE08B", 
         CLN5="#FEE08B", CLN6="#FEE08B", MFSD8="#FEE08B", CLN8="#FEE08B", CTNS="#E6F598", CTSA="grey76", FUCA="grey76", GAA="#66C2A5",
         GALC="grey76", GALNS="#F46D43", GBA1="#D53E4F", GLA="grey76", GLB1="#D53E4F", GM2A="grey76", GNPTAB="grey76", GNPTG="grey76", 
         GNS="grey76", GUSB="grey76", HEXA="#D53E4F", HEXB="#D53E4F", HGSNAT="grey76", HYAL1="grey76", IDS="grey76", IDUA="grey76",
         LAMP2="grey76", LIPA="#66C2A5", MAN2B1="grey76", MANBA="grey76", MCOLN1="#E6F598", NAGA="grey76", NAGLU="grey76", NEU1="grey76",
         NPC1="#E6F598", NPC2="#E6F598", PSAP="#D53E4F", SCARB2="grey76", SGSH="grey76", SLC17A5="grey76", SMPD1="#D53E4F", SUMF1="grey76")

expand_color_dict <- function(base_colors) {
  suffixes <- c("_iN", "_iDA")
  expanded <- unlist(lapply(names(base_colors), function(gene) {
    setNames(rep(base_colors[gene], 2), paste0(gene, suffixes))
  }))
  return(expanded)
}

col_expanded <- expand_color_dict(col)

# --- Step 7. Function: Barplot with SEM for iN or iDA, includes CSV output
NeuroClusterBarplot <- function(df_long, cluster_name = 2, cell_type = "iN") {
  df_sub <- df_long %>%
    filter(Cluster == cluster_name, CellType == cell_type)

  group_order_df <- df_sub %>%
    group_by(KO, KO_Cell) %>%
    summarise(
      mean_score = mean(Score, na.rm = TRUE),
      sem = sd(Score, na.rm = TRUE) / sqrt(n()),
      .groups = "drop"
    ) %>%
    arrange(mean_score)

  # Ensure character for plotting and matching
  group_order_df$KO_Cell <- as.character(group_order_df$KO_Cell)
  group_order_df$KO <- factor(group_order_df$KO, levels = unique(group_order_df$KO))

  # Assert color mapping is valid
  stopifnot(all(unique(group_order_df$KO_Cell) %in% names(col_expanded)))

  p <- ggplot(group_order_df, aes(x = KO, y = mean_score, fill = KO_Cell)) +
    geom_bar(stat = "identity", color = "black", size = 0.3) +
    geom_errorbar(aes(ymin = mean_score - sem, ymax = mean_score + sem),
                  width = 0.2, size = 0.3) +
    scale_fill_manual(values = col_expanded) +
    theme_bw(base_size = 10) +
    labs(title = paste0("Mean Score ± SEM – ", cluster_name, " (", cell_type, ")"),
         x = NULL, y = "Mean Score") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1),
          panel.grid = element_blank(),
          legend.position = "none")

  file_tag <- paste0(gsub(" ", "", cluster_name), "_", cell_type)

  ggsave(file.path(out_dir_d50_CrossCorr_nMOSTGOavgannnot, paste0("nMOST_LSD_Corr_Barplot_", file_tag, ".pdf")),
         p, width = 4, height = 4, device = cairo_pdf)

  write.csv(group_order_df,
            file = file.path(out_dir_d50_CrossCorr_nMOSTGOavgannnot, paste0("Barplot_Mean_SEM_", file_tag, ".csv")),
            row.names = FALSE)
}

# --- Step 8. call function and plot cluster
plot_cluster <- 7
NeuroClusterBarplot(log2FC_iN_df, cluster_name = plot_cluster, cell_type = "iN")
NeuroClusterBarplot(log2FC_iDA_df, cluster_name = plot_cluster, cell_type = "iDA")
```




### VIIIf. Average correlation per genotype across annotation (disease class color)
```{r}
# --------------------------------------------------- #
# For a selected genotype (e.g. GBA1_iN), plot mean 
# annotation correlation values across organelle annotations
# --------------------------------------------------- #

# --- Step 1. Define annotation color classes
annotation_classes_corrgeno <- list(
  Mito = c("Mito", "MitoIMS", "MitoMatrix", "MitoMIM", "MitoMOM", "OXPHOS", "mtComplexI"),
  Synaptic = c("SynGO", "SynapseSVs", "Presynaptic", "Postsynaptic", "NeuroDev", "SVfusion", "Svendocytosis", "Svexocytosis"),
  Endo = c("Endo_iN_curated_Hundley", "EarlyEndosome", "RecyclingEndosome"),
  Lyso = c("Lysosome", "vATPase", "EndoLyso", "Autophagy"),
  Golgi = "Golgi",
  ER = "ER",
  Misc = c("Cytoplasm", "Nucleus")
)

annotation_class_colors_corrgeno <- c(
  Synaptic = "dodgerblue3",
  Endo = "dodgerblue2",
  Lyso = "dodgerblue",
  Mito = "grey30",
  Golgi = "grey50",
  ER = "grey70",
  Misc = "grey90"
)


# Map annotation to classes
annotation_to_class_corrgeno <- enframe(annotation_classes_corrgeno, name = "Class", value = "Annotation") %>%
  unnest(Annotation)



# --- Step 2. Function: Barplot of annotation correlation for multiple genotypes
plot_bar_corr_per_annotation_multi <- function(corr_mat, selected_genotypes, annot_class_map, class_colors, out_path = NULL) {
  # Filter for valid genotypes
  valid_genos <- selected_genotypes[selected_genotypes %in% rownames(corr_mat)]
  if (length(valid_genos) == 0) stop("No valid genotypes found in matrix")

  for (geno in valid_genos) {
    # Extract correlation vector
    corr_vec <- corr_mat[geno, ]
    corr_df <- tibble(Annotation = names(corr_vec), Correlation = corr_vec) %>%
      left_join(annot_class_map, by = "Annotation") %>%
      filter(!is.na(Correlation)) %>%
      mutate(Class = factor(Class, levels = names(class_colors)))

    # Compute summary
    summary_df <- corr_df %>%
      group_by(Annotation, Class) %>%
      summarise(
        mean_corr = mean(Correlation, na.rm = TRUE),
        sem_corr = sd(Correlation, na.rm = TRUE) / sqrt(n()),
        .groups = "drop"
      ) %>%
      arrange(mean_corr)

    # Plot
    p <- ggplot(summary_df, aes(x = reorder(Annotation, mean_corr), y = mean_corr, fill = Class)) +
      geom_bar(stat = "identity", color = "black", width = 0.7, linewidth = 0.2) +
      geom_errorbar(aes(ymin = mean_corr - sem_corr, ymax = mean_corr + sem_corr), width = 0.2) +
      scale_fill_manual(values = class_colors) +
      geom_hline(yintercept = 0, linetype = "dashed") +
      labs(
        title = paste("Annotation Correlation for", geno),
        x = "Annotation", y = "Pearson Correlation (±SEM)"
      ) +
      theme_bw(base_size = 8) +
      theme(
        axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
        panel.grid = element_blank()
      )

    # Save to file
    if (!is.null(out_path)) {
      ggsave(file.path(out_path, paste0("barplot_", geno, "_correlations.pdf")),
             plot = p, width = 4, height = 4, device = cairo_pdf)
    }

    print(p)  # Optional: display in R session
  }
}


# --- Step 3. Call the function
plot_bar_corr_per_annotation_multi(
  corr_mat = org_corr_mat,
  selected_genotypes = c("CTSD_iDA","ATP13A2_iDA","SMPD1_iDA","HEXB_iDA","NPC2_iDA","NPC1_iDA","CLN5_iDA","HEXA_iDA","CLN8_iDA","GAA_iDA","LIPA_iDA","ASAH1_iDA","DNAJC5_iDA","MFSD8_iDA","GBA1_iDA","PSAP_iDA","CLN6_iDA","PTT1_iDA","CLN3_iDA","CTSF_iDA","TPP1_iDA","GRN_iDA","MCOLN1_iDA","MFSD8_iN","CTSD_iN","TPP1_iN","LIPA_iN","HEXB_iN","GAA_iN","CLN3_iN","CTSF_iN","GBA1_iN","CLN5_iN","HEXA_iN","PSAP_iN","CLN6_iN","GRN_iN","CLN8_iN","DNAJC5_iN","SMPD1_iN","ASAH1_iN","NPC1_iN","PTT1_iN","MCOLN1_iN","NPC2_iN","ATP13A2_iN"),
  annot_class_map = annotation_to_class_corrgeno,
  class_colors = annotation_class_colors_corrgeno,
  out_path = out_dir_d50_CrossCorr_genoavg
)


```


### VIIIg. Bubble plot of annotation corr of iN vs iDA neuron by genotype or annotation
```{r}
# --------------------------------------------------- #
# Scatter plot by disease class 
# facet wrapped by annotation
# --------------------------------------------------- #

# --- Step 1. Define Disease Class Map
disease_classes <- list(
  Sphigolipidoses = c("ARSA", "ASAH1", "GALC", "GBA1", "GLA", "GLB1", "GM2A", "HEXA", "HEXB", "PSAP", "SMPD1"),
  Mucopolysaccharidoses = c("GLB1", "ARSB", "GALNS", "GNS", "GUSB", "HGSNAT", "HYAL1", "IDS", "IDUA", "NAGLU", "SGSH"),
  Glycoproteinoses = c("AGA", "CTSA", "FUCA", "MAN2B1", "MANBA", "NAGA", "NEU1"),
  Neuronal.ceroid.lipofucinoses = c("PPT1", "CTSD", "GRN", "ATP13A2", "CTSF", "KCTD7", "TPP1", "CLN3", "DNAJC5", "CLN5", "CLN6", "MFSD8", "CLN8"),
  Integral.membrane.protein.disorders = c("ATP13A2", "CLN3", "CTNS", "LAMP2", "MCOLN1", "NPC1", "NPC2", "SCARB2", "SLC17A5"),
  PTM.defects = c("GNPTAB", "GNPTG", "SUMF1"),
  Lipid.storage.diseases = c("GAA", "LIPA")
)


# seven_color_gradient <- colorRampPalette(c("dodgerblue3", "lightblue", "grey50"))(7)
# disease_colors <- c(
disease_colors = c(Sphigolipidoses= "#1874CD",	
        Mucopolysaccharidoses="#4995D5",
        Glycoproteinoses="#7BB6DD" , 
        Neuronal.ceroid.lipofucinoses="#ADD8E6"  ,	
        Integral.membrane.protein.disorders="#9DBAC3",	
        PTM.defects="#8E9CA1" ,
        Lipid.storage.diseases= "#7F7F7F") 
        
# disease_colors <- c(
#   Sphigolipidoses = "dodgerblue3",
#   Neuronal.ceroid.lipofucinoses = "lightblue",
#   Integral.membrane.protein.disorders = "grey70"
# )
disease_class_df <- enframe(disease_classes) %>% unnest(value) %>% rename(KO = value, DiseaseClass = name)


# --- Step 2. Define plotting function (facet wrap by annotation)
plot_corr_bubble_by_annotation <- function(corr_mat, disease_class_df, disease_colors, out_path = NULL) {
  # Extract genotypes
  all_genos <- intersect(rownames(corr_mat), paste0(disease_class_df$KO, "_iN"))
  genos_iN <- grep("_iN$", all_genos, value = TRUE)
  genos_iDA <- sub("_iN$", "_iDA", genos_iN)

  # Build long dataframe
  df_list <- lapply(seq_along(genos_iN), function(i) {
    tibble(
      KO = sub("_iN$", "", genos_iN[i]),
      Genotype_iN = genos_iN[i],
      Genotype_iDA = genos_iDA[i],
      Annotation = colnames(corr_mat),
      Cor_iN = corr_mat[genos_iN[i], ],
      Cor_iDA = corr_mat[genos_iDA[i], ]
    )
  })
  bubble_df <- bind_rows(df_list) %>%
    left_join(disease_class_df, by = "KO") %>%
    mutate(DiseaseClass = factor(DiseaseClass, levels = names(disease_colors)))

  # -------------------------
  # Facet-wrapped plot
  # -------------------------
  p_facet <- ggplot(bubble_df, aes(x = Cor_iN, y = Cor_iDA, color = DiseaseClass)) +
    geom_point(alpha = 0.8, size = 2) +
    ggrepel::geom_text_repel(
      aes(label = KO),
      size = 2,
      max.overlaps = 50,
      force = 2,
      min.segment.length = 0,
      box.padding = 0.3,
      point.padding = 0.1
    ) +
    geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "black", linewidth = 0.3) +
    scale_color_manual(values = disease_colors) +
    facet_wrap(~ Annotation, scales = "fixed") +
    coord_fixed(ratio = 1) +
    theme_bw(base_size = 6) +
    theme(panel.grid = element_blank()) +
    labs(
      x = "iN Correlation", y = "iDA Correlation",
      title = "iN vs iDA Annotation Correlations per Genotype"
    )

  if (!is.null(out_path)) {
    ggsave(file.path(out_path, "facet_bubbleplot_iN_vs_iDA_by_annotation.pdf"),
           plot = p_facet, width = 20, height = 15, device = cairo_pdf)
  }

  # -------------------------
  # Individual plots per annotation
  # -------------------------
  unique_annot <- unique(bubble_df$Annotation)
  axis_lim <- range(c(bubble_df$Cor_iN, bubble_df$Cor_iDA), na.rm = TRUE)

  for (annot in unique_annot) {
    df_annot <- filter(bubble_df, Annotation == annot)

    p <- ggplot(df_annot, aes(x = Cor_iN, y = Cor_iDA, color = DiseaseClass)) +
      geom_point(alpha = 0.8, size = 2) +
      ggrepel::geom_text_repel(
        aes(label = KO),
        size = 2,
        max.overlaps = 50,
        force = 2,
        min.segment.length = 0,
        box.padding = 0.3,
        point.padding = 0.1
      ) +
      geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "black", linewidth = 0.3) +
      scale_color_manual(values = disease_colors) +
      coord_fixed(ratio = 1, xlim = axis_lim, ylim = axis_lim) +
      theme_bw(base_size = 6) +
      theme(panel.grid = element_blank()) +
      labs(
        title = paste("iN vs iDA Genotype Correlation –", annot),
        x = "iN Correlation", y = "iDA Correlation"
      )

    if (!is.null(out_path)) {
      ggsave(
        filename = file.path(out_path, paste0("iN_vs_iDA_Genotype_", annot, ".pdf")),
        plot = p, width = 5, height = 5, device = cairo_pdf
      )
    }
  }

  return(p_facet)
}

plot_corr_bubble_by_annotation(
  corr_mat = org_corr_mat,
  disease_class_df = disease_class_df,
  disease_colors = disease_colors,
  out_path = out_dir_d50_CrossCorr_bubble
)


# --------------------------------------------------- #
# Scatter plot of within-annotation variance of iN - iDA corr
#  annotations show the most biologically meaningful variation
# --------------------------------------------------- #

# --- Prepare data (same structure as before)
genos_iN <- grep("_iN$", rownames(org_corr_mat), value = TRUE)
genos_iDA <- sub("_iN$", "_iDA", genos_iN)

bubble_df <- map_dfr(seq_along(genos_iN), function(i) {
  tibble(
    KO = sub("_iN$", "", genos_iN[i]),
    Annotation = colnames(org_corr_mat),
    Cor_iN = org_corr_mat[genos_iN[i], ],
    Cor_iDA = org_corr_mat[genos_iDA[i], ]
  )
}) %>%
  left_join(disease_class_df, by = "KO") %>%
  pivot_longer(cols = c(Cor_iN, Cor_iDA), names_to = "Celltype", values_to = "Correlation") %>%
  mutate(Celltype = recode(Celltype, Cor_iN = "iN", Cor_iDA = "iDA"),
         DiseaseClass = factor(DiseaseClass, levels = names(disease_colors)))

# --- Summary: Mean and SD of correlation per Annotation × Celltype × DiseaseClass
summary_df <- bubble_df %>%
  group_by(Annotation, Celltype, DiseaseClass) %>%
  summarise(
    MeanCor = mean(Correlation, na.rm = TRUE),
    SDCor = sd(Correlation, na.rm = TRUE),
    .groups = "drop"
  )

# --- Plotting function
plot_corr_line_per_celltype <- function(celltype_label) {
  ggplot(filter(summary_df, Celltype == celltype_label),
         aes(x = Annotation, y = MeanCor, color = DiseaseClass, group = DiseaseClass)) +
    geom_hline(yintercept = 0,  linetype = "dashed", color = "black", linewidth = 0.3)+
    geom_line(linewidth = 0.75) +
    geom_ribbon(aes(ymin = MeanCor - SDCor, ymax = MeanCor + SDCor, fill = DiseaseClass),
                alpha = 0.2, color = NA) +
    scale_color_manual(values = disease_colors, drop = FALSE) +
    scale_fill_manual(values = disease_colors, drop = FALSE) +
    theme_bw(base_size = 6) +
    theme(
      panel.grid = element_blank(),
      axis.text.x = element_text(angle = 45, hjust = 1),
      legend.position = "bottom") +
    labs(
      title = paste("Mean ± SD Correlation –", celltype_label),
      x = "Annotation", y = "Correlation"
    )
}

# --- Generate plots
p_iN <- plot_corr_line_per_celltype("iN")
p_iDA <- plot_corr_line_per_celltype("iDA")

# --- Show plots
print(p_iN)
print(p_iDA)

# --- Save PDFs
ggsave(file.path(out_dir_d50_CrossCorr_bubble, "iN_iDA_corr_variance_annotation_iN.pdf"), p_iN, width = 6, height = 4, device = cairo_pdf)
ggsave(file.path(out_dir_d50_CrossCorr_bubble, "iN_iDA_corr_variance_annotation_iDA.pdf"), p_iDA, width = 6, height = 4, device = cairo_pdf)

# --------------------------------------------------- #
# Bubble plot by annotation 
# facet wrapped by genotype 
# --------------------------------------------------- #

# --- Step 4. Data preparations 
# --- Step 4.1. Extract gene counts per annotation
annotation_cols <- colnames(log2FC_d50_annotated_GO)[which(colnames(log2FC_d50_annotated_GO) == "Mito"):which(colnames(log2FC_d50_annotated_GO) == "vATPase")]

# --- Step 4.2. Count number of genes per annotation (non-NA or non-zero entries)
gene_count_df <- log2FC_d50_annotated_GO %>%
  select(all_of(annotation_cols)) %>%
  summarise(across(everything(), ~ sum(., na.rm = TRUE))) %>% 
  pivot_longer(everything(), names_to = "Annotation", values_to = "GeneCount")

# --- Step 4.3. Define annotation color classes
annotation_classes_corrgeno <- list(
  Mito = c("Mito", "MitoIMS", "MitoMatrix", "MitoMIM", "MitoMOM", "OXPHOS", "mtComplexI"),
  Synaptic = c("SynGO", "SynapseSVs", "Presynaptic", "Postsynaptic", "NeuroDev", "SVfusion", "Svendocytosis", "Svexocytosis"),
  Endo = c("Endo_iN_curated_Hundley", "EarlyEndosome", "RecyclingEndosome"),
  Lyso = c("Lysosome", "vATPase", "EndoLyso", "Autophagy"),
  Golgi = "Golgi",
  ER = "ER",
  Misc = c("Cytoplasm", "Nucleus")
)

annotation_class_colors_corrgeno <- c(
  Mito = "grey30",
  Synaptic = "dodgerblue3",
  Endo = "dodgerblue2",
  Lyso = "dodgerblue",
  Golgi = "grey50",
  ER = "grey70",
  Misc = "grey90"
)

# --- Step 4.4. Map annotation to classes
annotation_to_class_corrgeno <- enframe(annotation_classes_corrgeno, name = "Class", value = "Annotation") %>%
  unnest(Annotation)


# --- Step 5. Function: Facet by Genotype, Save All
plot_corr_iN_vs_iDA_by_genotype <- function(corr_mat, annot_class_df, annot_colors, gene_count_df, out_dir) {
  # Ensure matrix is a data frame
  corr_mat <- as.data.frame(corr_mat)

  # Get all genotypes (must have both iN and iDA)
  geno_base <- unique(gsub("_(iN|iDA)$", "", rownames(corr_mat)))
  valid_genos <- geno_base[
    paste0(geno_base, "_iN") %in% rownames(corr_mat) &
    paste0(geno_base, "_iDA") %in% rownames(corr_mat)
  ]

  # ---------- COLLECT ALL FOR FACET ----------
  all_df <- map_dfr(valid_genos, function(g) {
    iN_vec  <- corr_mat[paste0(g, "_iN"), ]
    iDA_vec <- corr_mat[paste0(g, "_iDA"), ]

    tibble(
      Genotype = g,
      Annotation = names(iN_vec),
      Cor_iN = as.numeric(iN_vec),
      Cor_iDA = as.numeric(iDA_vec)
    )
  }) %>%
    left_join(annot_class_df, by = "Annotation") %>%
    left_join(gene_count_df, by = "Annotation") %>%
    mutate(Class = factor(Class, levels = names(annot_colors)))

  # ---------- FACET-WRAPPED PLOT ----------
   p_facet <- ggplot(all_df, aes(x = Cor_iN, y = Cor_iDA, color = Class)) +
    geom_point(aes(size = GeneCount), alpha = 0.8) +
    scale_size(range = c(1, 8), breaks = c(10, 50, 100, 250, 500, 750, 1000), name = "Gene Count") +
    #scale_size_continuous(trans = "log10", range = c(1.5, 5), name = "Gene Count") +
    geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "black", linewidth = 0.3) +
    scale_color_manual(values = annot_colors, drop = FALSE) +
    coord_fixed(ratio = 1) +
    facet_wrap(~ Genotype, scales = "fixed") +
    theme_bw(base_size = 6) +
    theme(panel.grid = element_blank()) +
    labs(x = "iN Correlation", y = "iDA Correlation", title = "Annotation Correlation: iN vs iDA by Genotype")

  ggsave(file.path(out_dir, "facet_bubbleplot_iN_vs_iDA_all.pdf"), p_facet, width = 15, height = 15, device = cairo_pdf)

  # ---------- INDIVIDUAL PLOTS ----------
  for (g in valid_genos) {
    df_g <- filter(all_df, Genotype == g)
    
    # Label only annotations from specific classes
    df_label_select <- df_g %>% filter(Class %in% c("Synaptic", "Endo", "Lyso"))
    axis_lim <- range(c(all_df$Cor_iN, all_df$Cor_iDA), na.rm = TRUE)
    
    p <- ggplot(df_g, aes(x = Cor_iN, y = Cor_iDA, color = Class)) +
      geom_point(aes(size = GeneCount), alpha = 0.8) +
      scale_size(range = c(1, 8), breaks = c(10, 50, 100, 250, 500, 750, 1000), name = "Gene Count") +
      #scale_size_continuous(trans = "log2", range = c(1, 8), name = "Gene Count") +
      geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "black", linewidth = 0.3) +
      scale_color_manual(values = annot_colors, drop = FALSE) +
      coord_fixed(ratio = 1, xlim = axis_lim, ylim = axis_lim) +
      theme_bw(base_size = 6) +
      theme(panel.grid = element_blank()) +
      labs(
        title = paste("iN vs iDA Correlation —", g),
        x = "iN Correlation", y = "iDA Correlation"
      ) +
      ggrepel::geom_text_repel(
      data = df_label_select,
      aes(label = Annotation),
      size = 3,
      max.overlaps = 50,
      force = 1.5,              # increase spread (default = 1)
      force_pull = 0.1,       # optional: keep labels closer to origin
      box.padding = 0.5,      # space around label box
      point.padding = 0.2,    # space around data point
      min.segment.length = 0  # always draw connector
    )

    ggsave(
      filename = file.path(out_dir, paste0("iN_vs_iDA_bubble_", g, ".pdf")),
      plot = p, width = 5, height = 5, device = cairo_pdf
    )
  }
}


# --- Step 6. call function 
plot_corr_iN_vs_iDA_by_genotype(
  corr_mat = org_corr_mat,
  annot_class_df = annotation_to_class_corrgeno,
  annot_colors = annotation_class_colors_corrgeno,
  gene_count_df = gene_count_df,
  out_dir = out_dir_d50_CrossCorr_bubble
)


```



### ?? VIIIh. Pairwise protein–protein correlations
```{r}
# ─────────────────────────────────────────────
# 1. Load required packages
# ─────────────────────────────────────────────
library(tidyverse)
library(furrr)
library(qs)
library(pheatmap)

#log2FC_d50_annotated <- read.csv("/Users/felix/HMS Dropbox/Felix Kraus/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/dataframes/log2FC_d50_annotated.csv")

# ─────────────────────────────────────────────
# 2. Define disease class mapping (used for metadata)
# ─────────────────────────────────────────────
disease_classes <- list(
  Sphigolipidoses = c("ARSA", "ASAH1", "GALC", "GBA1", "GLA", "GLB1", "GM2A", "HEXA", "HEXB", "PSAP", "SMPD1"),
  Mucopolysaccharidoses = c("GLB1", "ARSB", "GALNS", "GNS", "GUSB", "HGSNAT", "HYAL1", "IDS", "IDUA", "NAGLU", "SGSH"),
  Glycoproteinoses = c("AGA", "CTSA", "FUCA", "MAN2B1", "MANBA", "NAGA", "NEU1"),
  Neuronal.ceroid.lipofucinoses = c("PPT1", "CTSD", "GRN", "ATP13A2", "CTSF", "KCTD7", "TPP1", "CLN3", "DNAJC5", "CLN5", "CLN6", "MFSD8", "CLN8"),
  Integral.membrane.protein.disorders = c("ATP13A2", "CLN3", "CTNS", "LAMP2", "MCOLN1", "NPC1", "NPC2", "SCARB2", "SLC17A5"),
  PTM.defects = c("GNPTAB", "GNPTG", "SUMF1"),
  Lipid.storage.diseases = c("GAA", "LIPA")
)

# ─────────────────────────────────────────────
# 3. Prepare annotation and log2FC matrix
# ─────────────────────────────────────────────
annotation_meta <- log2FC_d50_annotated %>%
  select(Genes, all_of(annotation_cols))

log2fc_protcorr <- log2FC_d50_annotated %>%
  select(-any_of(annotation_cols)) %>%
  column_to_rownames("Genes")

# Filter out flat genes (zero variance)
gene_sds <- apply(log2fc_protcorr, 1, sd, na.rm = TRUE)
log2fc_protcorr_filtered <- log2fc_protcorr[gene_sds > 0, ]

# Subset full matrix
log2fc_subset <- log2fc_protcorr_filtered[, colnames(log2fc_protcorr_filtered)]

# ─────────────────────────────────────────────
# 4. Create metadata for plotting and downstream grouping
# ─────────────────────────────────────────────
genotype_metadata <- tibble(sample = colnames(log2fc_subset)) %>%
  mutate(
    KO = str_extract(sample, "^[^_]+"),
    Neuron = str_extract(sample, "iN|iDA"),
    DiseaseClass = map_chr(KO, function(ko) {
      matched <- names(disease_classes)[map_lgl(disease_classes, ~ ko %in% .x)]
      ifelse(length(matched) > 0, matched[1], NA_character_)
    })
  )

# Save metadata
write_csv(genotype_metadata, file.path(out_dir_d50_corrProtein, "genotype_metadata.csv"))
write_csv(annotation_meta, file.path(out_dir_d50_corrProtein, "annotation_meta.csv"))
qs::qsave(annotation_meta, file.path(out_dir_d50_corrProtein, "annotation_meta.qs"))
qs::qsave(genotype_metadata, file.path(out_dir_d50_corrProtein, "genotype_metadata.qs"))



# ─────────────────────────────────────────────
# 5. Compute all pairwise protein–protein correlations ==> write as blocks on HDD
# ─────────────────────────────────────────────
plan(multisession, workers = 8)

gene_combinations <- combn(rownames(log2fc_subset), 2, simplify = FALSE)
block_size <- 750000
blocks <- split(gene_combinations, ceiling(seq_along(gene_combinations) / block_size))

stream_dir <- file.path(out_dir_d50_corrProtein, "streamed_blocks")
dir.create(stream_dir, showWarnings = FALSE, recursive = TRUE)

# Compute and stream correlation blocks
future_walk2(
  blocks,
  seq_along(blocks),
  .f = function(pair_block, block_idx) {
    block_results <- map_dfr(pair_block, function(pair) {
      g1 <- pair[1]; g2 <- pair[2]
      v1 <- as.numeric(log2fc_subset[g1, ])
      v2 <- as.numeric(log2fc_subset[g2, ])
      if (all(is.na(v1)) | all(is.na(v2))) {
        return(tibble(Gene1 = g1, Gene2 = g2, Correlation = NA_real_))
      }
      r <- cor(v1, v2, use = "pairwise.complete.obs")
      tibble(Gene1 = g1, Gene2 = g2, Correlation = r)
    })

    qs::qsave(block_results, file.path(stream_dir, paste0("block_", block_idx, ".qs")))
  },
  .progress = TRUE
)


# # ─────────────────────────────────────────────────────────────
# # RAM-based pairwise protein correlation (no disk I/O)
# # ─────────────────────────────────────────────────────────────
# # Set up parallel workers
# plan(multisession, workers = 8)
# 
# # Create gene pairs
# gene_combinations <- combn(rownames(log2fc_subset), 2, simplify = FALSE)
# 
# # Run all correlations and store in memory
# results_all <- future_map_dfr(
#   gene_combinations,
#   function(pair) {
#     g1 <- pair[1]; g2 <- pair[2]
#     v1 <- as.numeric(log2fc_subset[g1, ])
#     v2 <- as.numeric(log2fc_subset[g2, ])
#     if (all(is.na(v1)) | all(is.na(v2))) {
#       return(tibble(Gene1 = g1, Gene2 = g2, Correlation = NA_real_))
#     }
#     r <- cor(v1, v2, use = "pairwise.complete.obs")
#     tibble(Gene1 = g1, Gene2 = g2, Correlation = r)
#   },
#   .progress = TRUE
# )
# 
# # Optional: Save to disk once after all blocks are complete
# qs::qsave(results_all, file.path(out_dir_d50_corrProtein, "pairwise_corr_results.qs"))
# write_csv(results_all, file.path(out_dir_d50_corrProtein, "pairwise_corr_results.csv"))




# ======================================================================
#  Protein–Protein Correlation Analysis and Heatmap Visualization
# ======================================================================

# --- Define paths
stream_dir <- file.path(out_dir_d50_corrProtein, "streamed_blocks")
annotation_meta <- qs::qread(file.path(out_dir_d50_corrProtein, "annotation_meta.qs"))

# ----------------------------------------------------------------------
# 1. Combine all correlation blocks
# ----------------------------------------------------------------------
corr_files <- list.files(stream_dir, full.names = TRUE, pattern = "\\.qs$")
results <- map_dfr(corr_files, qs::qread)

# Save full result
qs::qsave(results, file.path(out_dir_d50_corrProtein, "pairwise_corr_results.qs"))
write_csv(results, file.path(out_dir_d50_corrProtein, "pairwise_corr_results.csv"))

# ----------------------------------------------------------------------
# 2. Quick QC: Correlation density plot
# ----------------------------------------------------------------------
results_clean <- results %>% filter(!is.na(Correlation))

qc_plot <- ggplot(results_clean, aes(x = Correlation)) +
  geom_density(adjust = 1.2) +
  labs(title = "Correlation density (all gene pairs)",
       x = "Pearson correlation", y = "Density") +
  theme_minimal()

ggsave(file.path(out_dir_d50_corrProtein, "correlation_density_plot.pdf"),
       plot = qc_plot, width = 6, height = 4)


dev.off()

# ----------------------------------------------------------------------
# Filter, Cluster, Plot, and Save Correlation Heatmap by Annotation
# ----------------------------------------------------------------------

plot_corr_heatmap_by_annotation <- function(
    results_df,
    annotation_df,
    annot_name,
    save_dir = ".",
    show_all = TRUE,
    top_n = 50,
    annotation_metadata = NULL
) {
  message("Filtering correlations where both genes are annotated as: ", annot_name)

  # Step 1: Filter for both genes being annotated
  filtered <- results_df %>%
    left_join(annotation_df, by = c("Gene1" = "Genes")) %>%
    filter(.data[[annot_name]] == 1) %>%
    left_join(annotation_df, by = c("Gene2" = "Genes"), suffix = c("_G1", "_G2")) %>%
    filter(.data[[paste0(annot_name, "_G2")]] == 1)

  if (nrow(filtered) == 0) {
    warning("No valid gene pairs for annotation: ", annot_name)
    return(NULL)
  }

  # Step 2: Create symmetric correlation matrix (deduplicated)
  filtered_unique <- filtered %>%
    filter(!is.na(Correlation)) %>%
    distinct(Gene1, Gene2, .keep_all = TRUE)

  mat_df <- filtered_unique %>%
    pivot_wider(names_from = Gene2, values_from = Correlation)

  rownames(mat_df) <- make.unique(mat_df$Gene1)  # avoid duplicate rownames
  mat <- as.matrix(mat_df[,-1])  # drop Gene1 column after rownames

  # Step 3: Symmetrize if needed
  if (!isSymmetric(mat)) {
    mat[lower.tri(mat)] <- t(mat)[lower.tri(mat)]
  }

  # Step 4: Optionally subset to top N genes by avg abs correlation
  if (!show_all) {
    gene_scores <- rowMeans(abs(mat), na.rm = TRUE)
    top_genes <- names(sort(gene_scores, decreasing = TRUE))[1:min(top_n, length(gene_scores))]
    mat <- mat[top_genes, top_genes, drop = FALSE]
  }

  # Step 5: Add KO / neuron / disease annotations (columns only)
  ann_col <- NULL
  if (!is.null(annotation_metadata)) {
    overlapping <- intersect(colnames(mat), annotation_metadata$sample)
    ann_col <- annotation_metadata %>%
      filter(sample %in% overlapping) %>%
      column_to_rownames("sample") %>%
      select(KO, Neuron, DiseaseClass)
  }

  # Step 6: Save heatmap
  out_file <- file.path(save_dir, paste0("corr_heatmap_", annot_name, ".pdf"))
  pheatmap::pheatmap(
    mat,
    scale = "none",
    color = colorRampPalette(rev(RColorBrewer::brewer.pal(11, "RdYlBu")))(100),
    annotation_col = ann_col,
    cluster_rows = TRUE,
    cluster_cols = TRUE,
    show_rownames = FALSE,
    show_colnames = TRUE,
    use_raster = TRUE,
    angle_col = 90,
    main = paste("Correlation Heatmap:", annot_name),
    fontsize = 10,
    border_color = NA,
    filename = out_file
  )

  # Step 7: Save filtered correlation table
  write_csv(filtered_unique, file.path(save_dir, paste0("correlations_", annot_name, ".csv")))
}




## call function 
plot_corr_heatmap_by_annotation(
  results_df = results,
  annotation_df = annotation_meta,
  annot_name = "SynapseSVs",
  save_dir = out_dir_d50_corrProtein,
  show_all = TRUE,  # or FALSE
  top_n = 50,
  annotation_metadata = genotype_metadata
)



 # all_ann <- c("Mito", "MitoIMS", "MitoMatrix", "MitoMIM", "MitoMOM", "OXPHOS",
 #                     "mtComplexI", "Golgi", "Lysosome", "ER", "Cytoplasm", "Nucleus",
 #                     "Autophagy", "SynGO", "Endo_iN_curated_Hundley", "SynapseSVs",
 #                     "Presynaptic", "Postsynaptic", "NeuroDev", "EndoLyso", "EarlyEndosome",
 #                     "RecyclingEndosome", "SVfusion", "Svendocytosis", "Svexocytosis", "vATPase")


```


# ??? IX. PRM of synaptic annotatons
```{r}
# --------------------------------------------------- #
# PRM on select synaptic / endolyso annotation list 
# PART 1: data import, wrangling and add annotations 
# --------------------------------------------------- #

# --- Step 1: Read in the data from the CSV file
# The CSV file has been pre-processed in Excel to replace all NA values with 0.
diff132_d50_prm_synaptic <- read.csv('/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/datasets/prm_protein_synapse.tsv', 
                                    header = TRUE, sep = '\t', stringsAsFactors = FALSE)

# --- Step 2: Parse sample metadata from column names
sample_info <- tibble(Sample = colnames(diff132_d50_prm_synaptic)[-(1:4)]) %>%
  mutate(
    Time = "d50",
    NeuronType = str_extract(Sample, "_i[DN]A_") %>% str_remove_all("_"),
    Genotype = str_extract(Sample, "_(Ctrl|ASAH1|MCOLN1|GBA1|GRN)_") %>% str_remove_all("_"),
    Replicate = str_extract(Sample, "rep[1-3]"),
    NewName = paste(Time, NeuronType, Genotype, Replicate, sep = "_")
  )

# Rename columns with parsed metadata
colnames(diff132_d50_prm_synaptic)[-(1:4)] <- sample_info$NewName

# --- Step 3: Calculate mean per genotype x neuron type
# Identify the columns containing intensities only
intensity_cols <- colnames(diff132_d50_prm_synaptic)[5:ncol(diff132_d50_prm_synaptic)]

# Now reshape only intensity containing columns
long_prm <- diff132_d50_prm_synaptic %>%
  pivot_longer(cols = all_of(intensity_cols), names_to = "Sample", values_to = "Intensity") %>%
  separate(Sample, into = c("Time", "NeuronType", "Genotype", "Replicate"), sep = "_") %>%
  mutate(Genes = rep(diff132_d50_prm_synaptic$Genes, times = length(intensity_cols))) %>%
  group_by(Genes, NeuronType, Genotype) %>%
  summarise(MeanIntensity = mean(Intensity, na.rm = TRUE), .groups = "drop")

# --- Step 4: Compute log2FC to Ctrl within neuron type
SynPRM_log2fc_df <- long_prm %>%
  pivot_wider(names_from = Genotype, values_from = MeanIntensity) %>%
  mutate(
    log2FC_ASAH1 = log2(ASAH1 / Ctrl),
    log2FC_GBA1 = log2(GBA1 / Ctrl),
    log2FC_GRN = log2(GRN / Ctrl),
    log2FC_MCOLN1 = log2(MCOLN1 / Ctrl)
  ) %>%
  select(Genes, NeuronType, starts_with("log2FC"))

# --- Step 5: Load Subcellular Annotation
cols_to_read <- c(1,2,3,4,5,6,7,9,10,12,15,16,17,18,19,20,21,22,23,25,26,27,28,29,30,31,32,33)
subcell_df <- read.csv(
  "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/neuroLSDgit/proteome/SubCellAnnotation.csv",
  stringsAsFactors = FALSE
)[, cols_to_read]
subcell_df[] <- lapply(subcell_df, as.character)

long_subcell_df <- subcell_df %>%
  pivot_longer(
    cols = everything(),
    names_to = "Localization",
    values_to = "Genes"
  ) %>%
  filter(!is.na(Genes) & Genes != "") %>%
  mutate(Genes = trimws(Genes)) %>%
  distinct()

# --- Step 6: Annotate PRM data
SynPRM_log2fc_annotated <- SynPRM_log2fc_df %>%
  left_join(long_subcell_df, by = "Genes")

# --- Step 7: Save outputs
write.csv(SynPRM_log2fc_annotated, file = file.path(out_dir_d50_dataframes, "log2fc_prm_synaptic_annotated.csv"), row.names = FALSE)
write.csv(SynPRM_log2fc_annotated, file = file.path(out_dir_d50_SynPRM, "log2fc_prm_synaptic_annotated.csv"), row.names = FALSE)



# --------------------------------------------------- #
# PRM on select synaptic / endolyso annotation list 
# PART 2: heatmaps, k-means clustering, Violin plots  
# --------------------------------------------------- #

# --- Step 0: Start from replicate-level intensities
df_raw <- read.csv('/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/datasets/prm_protein_synapse.tsv', 
                                    header = TRUE, sep = '\t', stringsAsFactors = FALSE)


# --- Step 1: pivot replicate columns
library(tidyverse)

SynPRM_replicate_long <- df_raw %>%
  pivot_longer(
    cols = starts_with("aa05"),  # your replicate columns
    names_to = "Sample",
    values_to = "Intensity"
  ) %>%
  mutate(
    Sample = str_remove(Sample, "aa[0-9]+_YH_PRMLSD200_"),  # remove prefix
    Time = str_extract(Sample, "d\\d+"),
    NeuronType = str_extract(Sample, "i[AD]A"),
    Genotype = str_extract(Sample, "ASAH1|MCOLN1|GBA1|GRN|Ctrl"),
    Replicate = str_extract(Sample, "rep\\d+")
  ) %>%
  select(Genes, NeuronType, Genotype, Replicate, Intensity) %>%
  filter(!is.na(Genes) & !is.na(Intensity))

# --- Step 2: get Ctrl reference
ctrl_medians <- SynPRM_replicate_long %>%
  filter(Genotype == "Ctrl") %>%
  group_by(NeuronType, Genes) %>%
  summarise(Ctrl_Intensity = list(Intensity), .groups = "drop")

# --- Step 3: compute stats for KO vs Ctrl
SynPRM_pval_df <- SynPRM_replicate_long %>%
  filter(Genotype != "Ctrl") %>%
  group_by(NeuronType, Genotype, Genes) %>%
  summarise(KO_Intensity = list(Intensity), .groups = "drop") %>%
  left_join(ctrl_medians, by = c("NeuronType", "Genes")) %>%
  rowwise() %>%
  mutate(
    p_value = if (length(KO_Intensity) > 0 && length(Ctrl_Intensity) > 0) {
      tryCatch(wilcox.test(KO_Intensity, Ctrl_Intensity)$p.value, error = function(e) NA_real_)
    } else NA_real_,
    log2FC = if (length(KO_Intensity) > 0 && length(Ctrl_Intensity) > 0) {
      median(KO_Intensity, na.rm = TRUE) - median(Ctrl_Intensity, na.rm = TRUE)
    } else NA_real_
  ) %>%
  ungroup() %>%
  mutate(FDR = p.adjust(p_value, method = "BH"))


# --- Step 4: Volcano plot
library(ggplot2)

ggplot(SynPRM_pval_df, aes(x = log2FC, y = -log10(FDR), color = FDR < 0.05)) +
  geom_point(alpha = 0.7) +
  facet_wrap(~ NeuronType + Genotype) +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed") +
  scale_color_manual(values = c("grey70", "red")) +
  theme_bw() +
  labs(title = "Volcano Plot", x = "log2 Fold Change (KO vs Ctrl)", y = "-log10(FDR)")


```




# IX. Sph mutant investigation
To achieve in this section:
make subset of only Sph mutant in day50 dataframe
plot heatmap w/ z-score norm of genotypes
run correlation matrix on EndoLyso, SynGo, endososme, lysosome, pre and post synaptic 
save the subset with annotation as csv file
save plots as pdfs 
use unique variables, so I can calculate the correlation between neurons and nMOST hela later down in the script

### IXa. Make df, add annotations & heatmap & save csv
```{r}
# --------------------------------------------------- #
# Sph mutant investigation  
# plot heatmap of Sph_mut Subset
# Add annotations & heatmap & save csv
# --------------------------------------------------- #

# --- Step 1.Define SphMut sample IDs
SphMut_samples <- c("Ctrl_iN", "Ctrl_iDA", "GLB1_iN", "GLB1_iDA", "GBA1_iN", "GBA1_iDA", 
                    "ASAH1_iN", "ASAH1_iDA", "SMPD1_iN", "SMPD1_iDA", "PSAP_iN", "PSAP_iDA", 
                    "HEXA_iN", "HEXA_iDA", "HEXB_iN", "HEXB_iDA")


# --- Step 2. Subset and pivot
SphMut_df <- clean_d50_transformed_df %>%
  filter(sample_id %in% SphMut_samples, day == 50)

SphMut_df <- SphMut_df %>%
  mutate(sample_id = paste0(sample_id, "_d", day))

SphMut_wide_df <- SphMut_df %>%
  select(Genes, sample_id, log2_fold_change, mean_ctrl, mean_ko, neg_log10_q_value, neg_log10_p_value) %>%
  pivot_wider(
    names_from = sample_id,
    values_from = c(log2_fold_change, mean_ctrl, mean_ko, neg_log10_q_value, neg_log10_p_value),
    names_glue = "{sample_id}_{.value}",
    values_fill = list(
      log2_fold_change = 0, mean_ctrl = 0, mean_ko = 0,
      neg_log10_q_value = 0, neg_log10_p_value = 0
    ),
    values_fn = list(
      log2_fold_change = sum,
      mean_ctrl = mean,
      mean_ko = mean,
      neg_log10_q_value = mean,
      neg_log10_p_value = mean
    )
  )


# --- Step 3. Add annotations
SphMut_annotated_df <- SphMut_wide_df %>%
  left_join(binary_matrix, by = "Genes") %>%
  replace(is.na(.), 0)


# --- Step 4. Save as CSV
write_csv(SphMut_annotated_df, file.path(out_dir_d50_SphMut, "SphMut_log2FC_day50_annotated.csv"))


# --- Step 5. Prepare variables for plotting  
log2fc_cols <- grep("_d50_log2_fold_change$", names(SphMut_annotated_df), value = TRUE)

SphMut_mat <- SphMut_annotated_df %>%
  select(all_of(log2fc_cols)) %>%
  as.matrix()
rownames(SphMut_mat) <- SphMut_annotated_df$Genes
SphMut_mat[!is.finite(SphMut_mat)] <- 0 

# Sample annotations
SphMut_sample_info <- tibble(sample_id = colnames(SphMut_mat)) %>%
  mutate(
    Genotype = str_extract(sample_id, "^[^_]+"),
    Neuron = str_extract(sample_id, "_i[DN]A") %>% str_remove("^_")
  ) %>%
  column_to_rownames("sample_id")

ann_colors <- list(
  Genotype = setNames(brewer.pal(length(unique(SphMut_sample_info$Genotype)), "Set3"),
                      unique(SphMut_sample_info$Genotype)),
  Neuron = c("iDA" = "grey80", "iN" = "grey40")
)

row_var <- apply(SphMut_mat, 1, var)
SphMut_mat_filtered <- SphMut_mat[row_var > 0, ]


# --- Step 6. Heatmap with internal z-score
Sphmut_hm <- pheatmap(
  SphMut_mat_filtered,
  annotation_col = SphMut_sample_info,
  annotation_colors = ann_colors,
  color = rev(brewer.pal(11, "RdYlBu")),
  cluster_rows = TRUE,
  cluster_cols = TRUE,
  scale = "row",
  show_rownames = FALSE,
  show_colnames = TRUE,
  use_raster = FALSE,
  fontsize = 6,
  #cellheight = 5,
  #cellwidth  = 5,
  border_color = NA,
  na_col = "grey90",
  main = "SphMut Z-Score Log2FC (Day 50)"
)


# --- Step 7. Save Heatmap 
pdf(file.path(out_dir_d50_SphMut, "SphMut_log2FC_heatmap.pdf"), width = 3, height = 10, useDingbats = FALSE)
print(Sphmut_hm)
dev.off()

```



### IXb. Correlation: User-selected organelle annotations 
```{r}
# --------------------------------------------------- #
# Sph mutant investigation  
# plot correlation heatmaps and facet wrap
# --------------------------------------------------- #

# --- Step 1. Correlation analysis on selected annotations
selected_annotations <- c("EndoLyso", "SynGO", "Endo_iN_curated_Hundley",
                          "Lysosome", "Presynaptic", "Postsynaptic","EarlyEndosome","RecyclingEndosome","SynapseSVs","SVfusion","Svendocytosis", "Svexocytosis")

# selected_annotations <- c("Mito", "MitoIMS", "MitoMatrix", "MitoMIM", "MitoMOM", "OXPHOS",
                     "mtComplexI", "Golgi", "Lysosome", "ER", "Cytoplasm", "Nucleus",
                     "Autophagy", "SynGO", "Endo_iN_curated_Hundley", "SynapseSVs",
                     "Presynaptic", "Postsynaptic", "NeuroDev", "EndoLyso", "EarlyEndosome",
                     "RecyclingEndosome", "SVfusion", "Svendocytosis", "Svexocytosis", "vATPase")     
   

log2fc_cols <- grep("log2_fold_change$", names(SphMut_annotated_df), value = TRUE)


# --- Step 2. Plotting function 
SphMut_corr_df <- purrr::map_dfr(selected_annotations, function(ann) {
  x <- as.numeric(SphMut_annotated_df[[ann]])
  purrr::map_dfr(log2fc_cols, function(ko) {
    y <- SphMut_annotated_df[[ko]]
    keep <- !(is.na(x) | is.na(y))
    if (sum(keep) < 5) return(NULL)
    ct <- suppressWarnings(cor.test(x[keep], y[keep], method = "spearman"))
    tibble(KO = ko, Organelle = ann, r = unname(ct$estimate), p = ct$p.value)
  })
})


# --- Step 3. Save Corr results as csv
# Save correlation results
write_csv(SphMut_corr_df, file.path(out_dir_d50_SphMut, "SphMut_annotation_correlation_selected.csv"))


# --- Step 4. Create Corr matrix with KO annotations
SphMut_corr_mat <- SphMut_corr_df %>%
  select(KO, Organelle, r) %>%
  pivot_wider(names_from = Organelle, values_from = r) %>%
  column_to_rownames("KO") %>%
  as.matrix()
SphMut_corr_mat[!is.finite(SphMut_corr_mat)] <- 0

# KO annotation
SphMut_ko_type <- data.frame(CellType = ifelse(grepl("iDA", rownames(SphMut_corr_mat)), "iDA", "iN"))
rownames(SphMut_ko_type) <- rownames(SphMut_corr_mat)


# --- Step 5. Plot correlation matrix
pdf(file.path(out_dir_d50_SphMut, "SphMut_annotation_corr_heatmap_selected.pdf"), width = 10, height = 14, useDingbats = FALSE)
pheatmap(
  SphMut_corr_mat,
  color = rev(brewer.pal(11, "RdYlBu")),
  cluster_rows = TRUE,
  cluster_cols = TRUE,
  annotation_row = SphMut_ko_type,
  annotation_colors = list(CellType = c(iDA = "grey80", iN = "grey40")),
  border_color = NA,
  cellheight = 15,
  cellwidth  = 15,
  main = "SphMut Organelle Correlation"
)
dev.off()

```


### IXc. Correlation: All organelle annotations 
```{r}
# --------------------------------------------------- #
# Sph mutant investigation  
# Cross-correlation matrix of Sph-genotypes for each organelle
# --------------------------------------------------- #

# --- Step 1. Setup 
out_corr_dir <- file.path(out_dir_d50_SphMut, "Organelle_CrossCorr")
dir.create(out_corr_dir, showWarnings = FALSE, recursive = TRUE)

SphMut_sample_cols <- grep("log2_fold_change$", names(SphMut_annotated_df), value = TRUE)
SphMut_ko_type <- data.frame(CellType = ifelse(grepl("iDA", SphMut_sample_cols), "iDA", "iN"))
rownames(SphMut_ko_type) <- SphMut_sample_cols
celltype_colors <- c(iDA = "grey80", iN = "grey40")


# --- Step 2. Function: Compute KO×KO correlation matrix for a given organelle ---
plot_sphmut_corr_matrix <- function(organelle_name, df = SphMut_annotated_df) {
  gene_filter <- df[[organelle_name]] == 1
  mat <- df[gene_filter, SphMut_sample_cols, drop = FALSE]
  if (nrow(mat) < 5) return(NULL)

  corr_mat <- cor(mat, use = "pairwise.complete.obs", method = "spearman")
  corr_mat[!is.finite(corr_mat)] <- 0

  pheatmap::pheatmap(
    corr_mat,
    main = organelle_name,
    color = rev(RColorBrewer::brewer.pal(11, "RdYlBu")),
    silent = TRUE,
    cellheight = 10,
    cellwidth = 10,
    na_col = "grey90",
    cluster_rows = TRUE,
    cluster_cols = TRUE,
    border_color = NA,
    fontsize = 6,
    annotation_row = SphMut_ko_type,
    annotation_colors = list(CellType = celltype_colors)
  )
}


# --- Step 3. Run for all selected organelles 
selected_annotations <- c("Mito","MitoIMS","MitoMatrix","MitoMIM","MitoMOM","OXPHOS","mtComplexI","Golgi","Lysosome"      ,"ER","Cytoplasm","Nucleus","Autophagy","SynGO","Endo_iN_curated_Hundley","SynapseSVs","Presynaptic","Postsynaptic","NeuroDev","EndoLyso","EarlyEndosome","RecyclingEndosome","SVfusion","Svendocytosis","Svexocytosis")
  


# selected_annotations <- c("EndoLyso", "SynGO", "Endo_iN_curated_Hundley",
#                           "Lysosome", "Presynaptic", "Postsynaptic","SVfusion","Svendocytosis", "Svexocytosis")


valid_annotations <- intersect(selected_annotations, colnames(SphMut_annotated_df))
SphMut_ko_corr_hms <- lapply(valid_annotations, plot_sphmut_corr_matrix)

# SphMut_ko_corr_hms <- lapply(selected_annotations, plot_sphmut_corr_matrix)
# SphMut_ko_corr_hms <- Filter(Negate(is.null), SphMut_ko_corr_hms)


# --- Step 4. Save multi-panel heatmap PDF 
pdf(file.path(out_corr_dir, "SphMut_KOxKO_Corr_Heatmaps.pdf"), width = 30, height = 30, useDingbats = FALSE)
gridExtra::grid.arrange(
  grobs = lapply(SphMut_ko_corr_hms, `[[`, "gtable"),
  ncol = 4
)
dev.off()

```



### IXc. diff118 (d23) to diff132 (d50) comparison of ASAH1
```{r}
# --- Step 1. Load and Inspect Data
# Define the path to the input CSV file
input_diff118 <- read.csv("/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/20240801_dif118_iN-iDA_Ctrl-SMPD1-ASAH1_Proteomics/Eval/dataframes/diff118_iN-iDA_d23_Ctrl-ASAH1-SMPD1_wholecellproteome_annotated.csv", 
                          header = TRUE, sep = ',', stringsAsFactors = FALSE)

# --- Subset: ASAH1 vs Ctrl (day 23, from diff118)
asah1_genes <- input_diff118 %>%
  select(Gene.Symbol, SynGO, SynapseSVs, RecyclingEndosome, mtComplexI,
         log2FC_ASAH1_d23_iN.Ctrl_d23_iN, log2FC_ASAH1_d23_iDA.Ctrl_d23_iDA) %>%
  rename(Gene = Gene.Symbol,
         iN_d23 = log2FC_ASAH1_d23_iN.Ctrl_d23_iN,
         iDA_d23 = log2FC_ASAH1_d23_iDA.Ctrl_d23_iDA)

# --- Merge with day 30 and day 50 data by gene
join_cols <- c("Genes", "Gene")  # Matching column names

day30_subset <- complete_data_annotated_day30 %>%
  select(Genes, contains("ASAH1"), SynGO, SynapseSVs, RecyclingEndosome, mtComplexI) %>%
  rename(Gene = Genes)

day50_subset <- complete_data_annotated_day50 %>%
  select(Genes, contains("ASAH1"), SynGO, SynapseSVs, RecyclingEndosome, mtComplexI) %>%
  rename(Gene = Genes)

# --- Long-format merge
merged_all <- list(
  d23 = asah1_genes %>% mutate(Time = "d23"),
  d30 = day30_subset %>%
    select(Gene, iN = ASAH1_iN_log2_fold_change, iDA = ASAH1_iDA_log2_fold_change,
           SynGO, SynapseSVs, RecyclingEndosome, mtComplexI) %>%
    mutate(Time = "d30"),
  d50 = day50_subset %>%
    select(Gene, iN = ASAH1_iN_log2_fold_change, iDA = ASAH1_iDA_log2_fold_change,
           SynGO, SynapseSVs, RecyclingEndosome, mtComplexI) %>%
    mutate(Time = "d50")
) %>% bind_rows()

# --- Define annotation columns
annotation_cols <- colnames(complete_data_annotated_day50)
annotation_cols <- annotation_cols[which(annotation_cols == "Mito"):which(annotation_cols == "vATPase")]


# --- Subset for day 23
asah1_genes <- input_diff118 %>%
  select(Gene.Symbol, all_of(annotation_cols),
         log2FC_ASAH1_d23_iN.Ctrl_d23_iN,
         log2FC_ASAH1_d23_iDA.Ctrl_d23_iDA) %>%
  rename(
    Gene = Gene.Symbol,
    log2FC_iN_ASAH1vsCtrl_d23 = log2FC_ASAH1_d23_iN.Ctrl_d23_iN,
    log2FC_iDA_ASAH1vsCtrl_d23 = log2FC_ASAH1_d23_iDA.Ctrl_d23_iDA
  ) %>%
  select(Gene, log2FC_iN_ASAH1vsCtrl_d23, log2FC_iDA_ASAH1vsCtrl_d23, everything())

# --- Subset for day 30
day30_subset <- complete_data_annotated_day30 %>%
  select(Genes, all_of(annotation_cols),
         ASAH1_iN_log2_fold_change,
         ASAH1_iDA_log2_fold_change) %>%
  rename(
    Gene = Genes,
    log2FC_iN_ASAH1vsCtrl_d30 = ASAH1_iN_log2_fold_change,
    log2FC_iDA_ASAH1vsCtrl_d30 = ASAH1_iDA_log2_fold_change
  ) %>%
  select(Gene, log2FC_iN_ASAH1vsCtrl_d30, log2FC_iDA_ASAH1vsCtrl_d30, everything())

# --- Subset for day 50
day50_subset <- complete_data_annotated_day50 %>%
  select(Genes, all_of(annotation_cols),
         ASAH1_iN_log2_fold_change,
         ASAH1_iDA_log2_fold_change) %>%
  rename(
    Gene = Genes,
    log2FC_iN_ASAH1vsCtrl_d50 = ASAH1_iN_log2_fold_change,
    log2FC_iDA_ASAH1vsCtrl_d50 = ASAH1_iDA_log2_fold_change
  ) %>%
  select(Gene, log2FC_iN_ASAH1vsCtrl_d50, log2FC_iDA_ASAH1vsCtrl_d50, everything())


# --- Merge all (by Gene and annotations)
asah1_ctrl_d233050_wide_df <- list(
  asah1_genes,
  day30_subset,
  day50_subset
) %>%
  reduce(full_join, by = c("Gene", annotation_cols))

# --- Reorder columns
asah1_ctrl_d233050_wide_df <- asah1_ctrl_d233050_wide_df %>%
  select(
    Gene,
    log2FC_iN_ASAH1vsCtrl_d23, log2FC_iDA_ASAH1vsCtrl_d23,
    log2FC_iN_ASAH1vsCtrl_d30, log2FC_iDA_ASAH1vsCtrl_d30,
    log2FC_iN_ASAH1vsCtrl_d50, log2FC_iDA_ASAH1vsCtrl_d50,
    all_of(annotation_cols)
  )
# --- Save to CSV
write_csv(asah1_ctrl_d233050_wide_df, file.path(out_dir_d50_dataframes, "diff118_diff132_d23d30d50_merged_ASAH1vsCtrl_cleanWide.csv"))




# ------------------
# bargaph of annotation abundance 
# ------------------

# ---  Define annotations of interest
annotation_cols_all <- c("SynGO","SynapseSVs",
  "Presynaptic", "Postsynaptic", "EarlyEndosome",
  "RecyclingEndosome", "Svendocytosis", "Svexocytosis", "vATPase"
)

# --- Helper function to reshape and summarize
prep_plot_data <- function(df, celltype) {
  df %>%
    select(Gene, starts_with(paste0("log2FC_", celltype)), all_of(annotation_cols_all)) %>%
    pivot_longer(cols = starts_with(paste0("log2FC_", celltype)), names_to = "Time", values_to = "log2FC") %>%
    mutate(Time = str_extract(Time, "d\\d+")) %>%
    pivot_longer(cols = all_of(annotation_cols_all), names_to = "Annotation", values_to = "in_group") %>%
    filter(in_group == TRUE) %>%
    group_by(Time, Annotation) %>%
    summarise(
      mean_log2FC = mean(log2FC, na.rm = TRUE),
      sem_log2FC = sd(log2FC, na.rm = TRUE) / sqrt(n()),
      .groups = "drop"
    )
}

# --- Prepare data for iN and iDA
plot_data_iN <- prep_plot_data(asah1_ctrl_d233050_wide_df, "iN")
plot_data_iDA <- prep_plot_data(asah1_ctrl_d233050_wide_df, "iDA")

# --- Color mapping
timeline_colors <- c(d50 = "dodgerblue3", d30 = "lightblue", d23 = "grey70")

# --- Plot function
plot_bar <- function(data, title) {
  ggplot(data, aes(x = Time, y = mean_log2FC, fill = Time)) +
    geom_bar(stat = "identity", color = "black", width = 0.7, linewidth = 0.2) +
    geom_errorbar(aes(ymin = mean_log2FC - sem_log2FC, ymax = mean_log2FC + sem_log2FC),
                  width = 0.2) +
    facet_wrap(~Annotation, scales = "free_y") +
    scale_fill_manual(values = timeline_colors) +
    theme_bw(base_size = 6) +
    theme(
      panel.grid = element_blank(),
      axis.text.x = element_text(angle = 45, hjust = 1),
      legend.position = "bottom"
    ) +
    labs(title = title, x = "Timepoint", y = "Mean log2FC")
}

# --- Plot iN and iDA separately
plot_iN_ASAH1Timecomp <- plot_bar(plot_data_iN, "ASAH1 vs Ctrl – iN Neurons")
plot_iDA_ASAH1Timecomp  <- plot_bar(plot_data_iDA, "ASAH1 vs Ctrl – iDA Neurons")

# --- Show plots
print(plot_iN_ASAH1Timecomp)
print(plot_iDA_ASAH1Timecomp)

# --- Save PDF
ggsave(file.path(out_dir_d50_CrossCorr_bubble_ASAH1, "diff118_132_ASAH1vsCtrl_d23d30d50organelleAnnotation_iN_bar.pdf"),  plot_iN_ASAH1Timecomp,  width = 5, height = 6, device = cairo_pdf)
ggsave(file.path(out_dir_d50_CrossCorr_bubble_ASAH1, "diff118_132_ASAH1vsCtrl_d23d30d50organelleAnnotation_iDA_bar.pdf"),  plot_iDA_ASAH1Timecomp,  width = 5, height = 6, device = cairo_pdf)


```


# X. GRN d30/50 DA neuron investigation
we see that the DA neurons of GRN in both day 30 and day50 have differences in their proteome compared to the other genotypes or the iN of the same genotype

- make dataframe of only Ctrl, GRN, GBA1, ASAH1, SMPD1 for day30 and day 50; both iN and iDA
- add annotations to Genes in dataframe
- also calculate the log2FC but also keep the mean_ctrl and mean_ko values in the dataframe => calculate mean of that 

- plot mean_ctrl and mean_ko across the genotypes
- make heatmap containing both timepoints => gene.rows are matched
- plot corr of GRN/Ctrl day30 (x) and GRN/Ctrl day50 (y)
- plot outliers of this corr and see what is different? 
```{r}
# --------------------------------------------------- #
# GRN d30/50 DA neuron investigation  
# Cross-correlation matrix of Sph-genotypes for each organelle
# --------------------------------------------------- #

# --- Step 1. use modified function to loop through clean_50_transformed_df to get genotypes and days and annotations in new dataframe 
process_day_data_combined <- function(df, binary_matrix) {
  selected_samples <- c("Ctrl_iN", "Ctrl_iDA", "GRN_iN", "GRN_iDA", 
                        "GBA1_iN", "GBA1_iDA", "ASAH1_iN", "ASAH1_iDA", 
                        "SMPD1_iN", "SMPD1_iDA")
  
  # Filter to relevant samples only
  df_filtered <- df %>% filter(sample_id %in% selected_samples, day %in% c(30, 50))
  
  # Add time label to sample_id (to avoid collision after pivoting)
  df_filtered <- df_filtered %>%
    mutate(sample_id = paste0(sample_id, "_d", day))
  
  # Pivot to wide format
  complete_data <- df_filtered %>%
    select(Genes, sample_id, log2_fold_change, mean_ctrl, mean_ko, neg_log10_q_value, neg_log10_p_value) %>%
    pivot_wider(
      names_from = sample_id,
      values_from = c(log2_fold_change, mean_ctrl, mean_ko, neg_log10_q_value, neg_log10_p_value),
      names_glue = "{sample_id}_{.value}",
      values_fill = list(
        log2_fold_change = 0, mean_ctrl = 0, mean_ko = 0,
        neg_log10_q_value = 0, neg_log10_p_value = 0
      ),
      values_fn = list(
        log2_fold_change = sum,
        mean_ctrl = mean,
        mean_ko = mean,
        neg_log10_q_value = mean,
        neg_log10_p_value = mean
      )
    )
  
  # Add annotations
  complete_data_annotated <- complete_data %>%
    left_join(binary_matrix, by = "Genes") %>%
    replace(is.na(.), 0)
  
  return(complete_data_annotated)
}

# --- Step 2. Save day 30 and day50 data as csv file 
day3050_subset <- process_day_data_combined(clean_d50_transformed_df, binary_matrix)
write.csv(day3050_subset, file=file.path(out_dir_d50_GRN, "diff132_day3050_subset.csv"),row.names = FALSE)
write.csv(day3050_subset, file=file.path(out_dir_d50_dataframes, "diff132_day3050_subset.csv"),row.names = FALSE)



# --------------------------------------------------- #
# GRN d30/50 DA neuron investigation  
# heatmap of day30/50 dataset
# --------------------------------------------------- #

# --- Step 3. Function for Heatmap plotting
generate_day3050_heatmap <- function(df, title_label = "Combined Heatmap") {
  # Extract log2FC columns
  log2fc_cols <- grep("_log2_fold_change$", names(df), value = TRUE)
  mat <- as.matrix(df[, log2fc_cols])
  rownames(mat) <- df$Genes
  storage.mode(mat) <- "numeric"
  mat[!is.finite(mat)] <- 0

  # Remove invariant rows/columns
  mat <- mat[apply(mat, 1, var) != 0, , drop = FALSE]
  mat <- mat[, apply(mat, 2, var) != 0, drop = FALSE]

  # Sample annotation: extract genotype, neuron type, and day
  sample_info <- data.frame(
    sample_id = colnames(mat)
  ) %>%
    mutate(
      Genotype = str_extract(sample_id, "^[^_]+"),
      Neuron = str_extract(sample_id, "_iDA|_iN") %>% str_remove("^_"),
      Day = str_extract(sample_id, "_d\\d+") %>% str_remove("^_")
    ) %>%
    column_to_rownames("sample_id")

  # Annotation colors
  ann_colors <- list(
    Genotype = setNames(brewer.pal(length(unique(sample_info$Genotype)), "Set1"), unique(sample_info$Genotype)),
    Neuron = setNames(c("grey40", "grey70"), unique(sample_info$Neuron)),
    Day = setNames(c("#3182bd", "#9ecae1"), unique(sample_info$Day))
  )

  # Generate heatmap
  pheatmap(
    mat,
    scale = "row",
    color = colorRampPalette(rev(brewer.pal(n = 11, name = "RdYlBu")))(100),
    annotation_col = sample_info,
    annotation_colors = ann_colors,
    breaks = seq(-4, 4, length.out = 101),
    cluster_rows = TRUE,
    cluster_cols = TRUE,
    show_rownames = FALSE,
    show_colnames = TRUE,
    use_raster = FALSE,
    #angle_col = 90,
    main = title_label,
    fontsize = 10,
    border_color = NA
  )
}

# --- Step 4. call function
day3050_heatmap <- generate_day3050_heatmap(day3050_subset, title_label = "LSD DA Neuron Log2FC – Day30 & Day50")
#day3050_heatmap


# --- Step 5. save heatmap as pdf in both dirs
pdf(file.path(out_dir_d50_heatmaps, "diff132_selectKO_day3050_heatmap.pdf"), width = 8, height = 10, useDingbats = FALSE)
generate_day3050_heatmap(day3050_subset, title_label = "LSD DA Neuron Log2FC – Day30 & Day50")
dev.off()

pdf(file.path(out_dir_d50_GRN, "diff132_selectKO_day3050_heatmap.pdf"), width = 8, height = 10, useDingbats = FALSE)
generate_day3050_heatmap(day3050_subset, title_label = "LSD DA Neuron Log2FC – Day30 & Day50")
dev.off()




# --------------------------------------------------- #
# GRN d30/50 DA neuron investigation  
# Correlation scatterplot of day30 / day 50 DA GRN neurons
# --------------------------------------------------- #

# --- Step 6. Color & facet~wrap by annotation of compartment 
# Create a copy to avoid modifying original
annot_subset <- day3050_subset


# --- Step 7. define protein sub cellular localizations --- 
# Step 7a: Identify annotation columns (logical columns at the end of the dataframe)
annotation_columns <- names(annot_subset)[sapply(annot_subset, is.logical)]

# Step 7b: Remove overly specific or problematic annotations
usable_annotations <- setdiff(annotation_columns, c("Autophagy_det", "EndoDetailLoac"))

# Step 7c: Reshape to long format: Gene - Localization pairs
annotation_long <- annot_subset %>%
  select(Genes, all_of(usable_annotations)) %>%
  pivot_longer(cols = -Genes, names_to = "Localization", values_to = "Present") %>%
  filter(Present) %>%
  select(-Present) %>%
  distinct()


# --- Step 8. define protein sub cellular localizations --- 
# Step 8a: Create full combination of genes and facet localizations
facet_levels <- unique(annotation_long$Localization)

# Step 8c: Expand gene-localization combinations
facet_expanded <- expand.grid(
  Genes = unique(annotation_long$Genes),
  FacetLocalization = facet_levels,
  stringsAsFactors = FALSE
)


# --- Step 9. differentiate between highlights / background for facet~wrap --- 
# Step 9a: Join annotation and expression data
plot_data <- facet_expanded %>%
  left_join(annotation_long, by = "Genes") %>%
  left_join(day3050_subset, by = "Genes") %>%
  mutate(point_color = ifelse(Localization == FacetLocalization, "dodgerblue", "grey80"))

# Step 9b: Separate highlight vs background
highlight_points <- plot_data %>% filter(point_color == "dodgerblue")
background_points <- plot_data %>% filter(point_color == "grey80")



# --- Step 10. plot scatterplot with different highlights, based on annoations ---
# Step 10a: Plot with background and highlight
day3050_GRN <- ggplot() +
  # Background points
  geom_point(data = background_points,
             aes(x = GRN_iDA_d30_log2_fold_change, y = GRN_iDA_d50_log2_fold_change),
             color = "grey80", size = 0.8, alpha = 0.7) +
  # Highlighted points
  geom_point(data = highlight_points,
             aes(x = GRN_iDA_d30_log2_fold_change, y = GRN_iDA_d50_log2_fold_change),
             color = "dodgerblue", size = 0.8, alpha = 0.9) +
  geom_hline(yintercept = 0, linetype = "dashed", linewidth = 0.3) +
  geom_vline(xintercept = 0, linetype = "dashed", linewidth = 0.3) +
  geom_smooth(data = plot_data,
              aes(x = GRN_iDA_d30_log2_fold_change, y = GRN_iDA_d50_log2_fold_change),
              method = "lm", se = FALSE, color = "black", linewidth = 0.3) +
  facet_wrap(~FacetLocalization) +
  theme_classic(base_size = 10) +
  labs(
    title = "GRN iDA: Day 30 vs Day 50 log2FC by Subcellular Localization",
    x = "Day 30 log2FC",
    y = "Day 50 log2FC"
  ) +
      xlim(-4,4) + ylim(-4,4)

day3050_GRN


# --- Step 11. save as pdf 
ggsave(file.path(out_dir_d50_GRN, "diff132_day3050_GRN_DA_scattter.pdf"),  day3050_GRN,  width = 8, height = 8, device = cairo_pdf)





# --------------------------------------------------- #
# GRN d30/50 DA neuron investigation  
# plot DA 30 vs 50, and highlight top 10 enriched proteins in both data frames
# --------------------------------------------------- #

# --- Step 12. Base data
plot_df <- day3050_subset %>%
  select(Genes, GRN_iDA_d30_log2_fold_change, GRN_iDA_d50_log2_fold_change)


# --- Step 13. Define enrichment ranking
# Rank by absolute log2FC sum across both timepoints
top10_genes <- plot_df %>%
  mutate(total_abs = abs(GRN_iDA_d30_log2_fold_change) + abs(GRN_iDA_d50_log2_fold_change)) %>%
  arrange(desc(total_abs)) %>%
  slice_head(n = 50) %>%
  pull(Genes)


# --- Step 14. Annotate color and label
plot_df <- plot_df %>%
  mutate(
    highlight = Genes %in% top10_genes,
    point_color = ifelse(highlight, "red", "grey76"),
    label = ifelse(highlight, Genes, NA)
  )


# --- Step 15. Plot
day3050_GRN_top <- ggplot(plot_df, aes(x = GRN_iDA_d30_log2_fold_change, y = GRN_iDA_d50_log2_fold_change)) +
  geom_point(aes(color = point_color), size = 1.2, alpha = 0.8, show.legend = FALSE) +
  geom_text_repel(aes(label = label), size = 2.5, max.overlaps = 100) +
  geom_smooth(method = "lm", se = FALSE, color = "black", linewidth = 0.3) +
  geom_hline(yintercept = 0, linetype = "dashed", linewidth = 0.3) +
  geom_vline(xintercept = 0, linetype = "dashed", linewidth = 0.3) +
  scale_color_identity() +
  xlim(-4, 4) + ylim(-4, 4) +
  theme_bw(base_size = 10) +
    theme(
      panel.grid = element_blank()
    ) +
    labs(
    title = "Top Enriched Proteins: GRN iDA Day30 vs Day50",
    x = "log2FC Day 30",
    y = "log2FC Day 50"
  )

day3050_GRN_top

# --- Step 16. save as pdf 
ggsave(file.path(out_dir_d50_GRN, "diff132_day3050_GRN_DA_topHits.pdf"),  day3050_GRN_top,  width = 8, height = 8, device = cairo_pdf)


```






# XI. Disease-class-based comparison day50
Focus on disease classes with good coverage 
1. Sphigolipidoses
2. Neuronal.ceroid.lipofucinoses
3. Integral.membrane.protein.disorders


### XIa. Annotation-based corr heatmaps
```{r}
# --------------------------------------------------- #
# Disease-class-based comparison day50  
# Comparison of User-selected annotations across disease classes 
# --------------------------------------------------- #

# --- Step 1. Define Disease Class Map
disease_classes <- list(
  Sphigolipidoses = c("ARSA", "ASAH1", "GALC", "GBA1", "GLA", "GLB1", "GM2A", "HEXA", "HEXB", "PSAP", "SMPD1"),
  Neuronal.ceroid.lipofucinoses = c("PPT1", "CTSD", "GRN", "ATP13A2", "CTSF", "KCTD7", "TPP1", "CLN3", "DNAJC5", "CLN5", "CLN6", "MFSD8", "CLN8"),
  Integral.membrane.protein.disorders = c("ATP13A2", "CLN3", "CTNS", "LAMP2", "MCOLN1", "NPC1", "NPC2", "SCARB2", "SLC17A5")
)
disease_colors <- c(
  Sphigolipidoses = "#D53E4F",
  Neuronal.ceroid.lipofucinoses = "#FEE08B",
  Integral.membrane.protein.disorders = "#E6F598"
)
disease_class_df <- enframe(disease_classes) %>% unnest(value) %>% rename(KO = value, DiseaseClass = name)


# --- Step 2. Add Disease Class to subdataframe, reshape and join back annotations 
annotated_log2fc_df <- complete_data_annotated_day50 %>%
  select(Genes, matches("_iN_log2_fold_change$|_iDA_log2_fold_change$")) %>%
  pivot_longer(cols = -Genes, names_to = "sample", values_to = "log2fc") %>%
  mutate(
    sample = str_remove(sample, "_log2_fold_change$"),
    KO = str_extract(sample, "^[^_]+"),
    celltype = str_extract(sample, "(iN|iDA)$"),
    log2fc = as.numeric(log2fc)
  ) %>%
  left_join(disease_class_df, by = "KO") %>%
  distinct(Genes, sample, .keep_all = TRUE) %>%
  pivot_wider(id_cols = c(Genes, KO, DiseaseClass), names_from = sample, values_from = log2fc)

# Add annotation columns back in
annotation_cols_all <- c(
  "Mito", "MitoIMS", "MitoMatrix", "MitoMIM", "MitoMOM", "OXPHOS",
  "mtComplexI", "Golgi", "Lysosome", "ER", "Cytoplasm", "Nucleus",
  "Autophagy", "SynGO", "Endo_iN_curated_Hundley", "SynapseSVs",
  "Presynaptic", "Postsynaptic", "NeuroDev", "EndoLyso", "EarlyEndosome",
  "RecyclingEndosome", "SVfusion", "Svendocytosis", "Svexocytosis", "vATPase"
)

annotated_log2fc_df <- annotated_log2fc_df %>%
  left_join(
    complete_data_annotated_day50 %>% select(Genes, all_of(annotation_cols_all)),
    by = "Genes"
  )


# --- Step 3. Save the annotated dataframe
write.csv(annotated_log2fc_df, file = file.path(out_dir_d50_DisClass, "Annotated_Log2FC_with_DiseaseClass.csv"), row.names = FALSE)


# --- Step 4. Define correlation and plotting function by annotations
plot_annotation_correlation <- function(annot_df, annotation_cols, out_dir, cellsize = 10) {
  # Calculate average profile per annotation
  annotation_means <- map_dfc(annotation_cols, function(annot_col) {
    genes <- annot_df %>% filter(.data[[annot_col]] == 1) %>% pull(Genes)
    sub <- annot_df %>% filter(Genes %in% genes) %>% select(matches("_(iN|iDA)$"))
    colMeans(sub, na.rm = TRUE)
  })
  colnames(annotation_means) <- annotation_cols
  annotation_cor <- cor(annotation_means, use = "pairwise.complete.obs", method = "pearson")
  
  # Save correlation matrix
  write.csv(annotation_cor, file = file.path(out_dir, "CustomAnnotation_CorrMatrix.csv"))
  
  # Create annotation bar
  annotation_df <- data.frame(DiseaseClass = colnames(annotation_cor)) %>%
    left_join(annotation_cols %>% enframe(name = NULL, value = "Annotation"), by = c("DiseaseClass" = "Annotation")) %>%
    mutate(DiseaseClass = factor(DiseaseClass, levels = names(disease_colors)))
  
  row_annot <- data.frame(DiseaseClass = factor(rep(names(disease_colors), length.out = ncol(annotation_cor)), levels = names(disease_colors)))
  rownames(row_annot) <- colnames(annotation_cor)

  # Plot heatmap
  pdf(file = file.path(out_dir, "CustomAnnotation_AnnotationCorrHeatmap.pdf"), width = 8, height = 8)
  pheatmap(
    annotation_cor,
    color = colorRampPalette(rev(RColorBrewer::brewer.pal(n = 11, name = "RdYlBu")))(100),
    annotation_row = row_annot,
    annotation_colors = list(DiseaseClass = disease_colors),
    cluster_rows = TRUE,
    cluster_cols = TRUE,
    fontsize = 6,
    cellheight = 8,
    cellwidth  = 8,
    border = NA
  )
  dev.off()
}


# --- Step 5. Define annotations of interest and run function
#custom_annotation_cols <- c("RecyclingEndosome", "SVfusion", "Svendocytosis", "Svexocytosis", "vATPase")

# custom_annotation_cols <- c("Mito", "MitoIMS", "MitoMatrix", "MitoMIM", "MitoMOM", "OXPHOS",
#                      "mtComplexI", "Golgi", "Lysosome", "ER", "Cytoplasm", "Nucleus",
#                      "Autophagy", "SynGO", "Endo_iN_curated_Hundley", "SynapseSVs",
#                      "Presynaptic", "Postsynaptic", "NeuroDev", "EndoLyso", "EarlyEndosome",
#                      "RecyclingEndosome", "SVfusion", "Svendocytosis", "Svexocytosis", "vATPase")

custom_annotation_cols <- c("SynGO", "Endo_iN_curated_Hundley", "SynapseSVs",
                     "Presynaptic", "Postsynaptic","EarlyEndosome",
                     "RecyclingEndosome", "SVfusion", "Svendocytosis", "Svexocytosis", "vATPase")

plot_annotation_correlation(annotated_log2fc_df, custom_annotation_cols, out_dir_d50_DisClass)


```


### XIb.  Annotation-based ChordDiagrams of correlations
```{r}
# --------------------------------------------------- #
# Disease-class-based comparison day50  
# Sphigolipidoses, NCL, Integral.membrane.protein.disorders
# Correlations between KO conditions
# --------------------------------------------------- #

library(circlize)
library(ComplexHeatmap)
library(tidyverse)
library(grid)


# --- Step 1. Define color mappings for plotting
neuron_colors <- c("iN" = "dodgerblue", "iDA" = "#D53E4F")
disease_colors <- c(
  Sphigolipidoses = "#D53E4F",
  Neuronal.ceroid.lipofucinoses = "#FEE08B",
  Integral.membrane.protein.disorders = "#E6F598"
)


# --- Step 2. Set Annotations of interest, can corr threshold 
#custom_annotation_cols <- c("EarlyEndosome","RecyclingEndosome", "SVfusion", "Svendocytosis", "Svexocytosis", "vATPase")
custom_annotation_cols <- c("Mito", "MitoIMS", "MitoMatrix", "MitoMIM", "MitoMOM", "OXPHOS",
                     "mtComplexI", "Golgi", "Lysosome", "ER", "Cytoplasm", "Nucleus",
                     "Autophagy", "SynGO", "Endo_iN_curated_Hundley", "SynapseSVs",
                     "Presynaptic", "Postsynaptic", "NeuroDev", "EndoLyso", "EarlyEndosome",
                     "RecyclingEndosome", "SVfusion", "Svendocytosis", "Svexocytosis", "vATPase")

# custom_annotation_cols <- c("Golgi", "Lysosome", "SynGO", "Endo_iN_curated_Hundley", "SynapseSVs",
#                      "Presynaptic", "Postsynaptic","EarlyEndosome",
#                      "RecyclingEndosome", "SVfusion", "Svendocytosis", "Svexocytosis", "vATPase")

min_genes_per_genotype <- 5
cor_threshold <- 0.5



# --- Step 3. Loop through custom annotations, calculate correlations and save as csv file 
for (annot in custom_annotation_cols) {
  message("Processing annotation: ", annot)

  # Step 3.1: Filter for annotated genes
  annot_subset_df <- annotated_log2fc_df %>%
    filter(.data[[annot]] == 1)

  # Step 3.2: Check valid samples with ≥3 annotated genes
  valid_samples <- annot_subset_df %>%
    select(Genes, KO, DiseaseClass, matches("_(iN|iDA)$")) %>%
    pivot_longer(cols = matches("_(iN|iDA)$"), names_to = "sample", values_to = "log2fc") %>%
    group_by(sample) %>%
    filter(!is.na(log2fc)) %>%
    summarise(n_genes = n_distinct(Genes), .groups = "drop") %>%
    filter(n_genes >= min_genes_per_genotype) %>%
    pull(sample)

  if (length(valid_samples) < 2) {
    warning("Skipping ", annot, ": not enough valid samples")
    next
  }

  # Step 3.3: Create filtered log2FC matrix
  log2fc_mat <- annot_subset_df %>%
    select(Genes, all_of(valid_samples)) %>%
    group_by(Genes) %>%
    summarise(across(everything(), ~ mean(.x, na.rm = TRUE)), .groups = "drop") %>%
    column_to_rownames("Genes") %>%
    as.matrix()

  # Step 3.4: Compute Pearson correlation
  corr_mat <- cor(log2fc_mat, use = "pairwise.complete.obs", method = "pearson")

  # Step 3.5: Save matrix
  write.csv(corr_mat, file = file.path(out_dir_d50_DisClass_chord, paste0("CorrMatrix_", annot, ".csv")))

  # Step 3.6: Link table for circos
  corr_links <- expand.grid(from = rownames(corr_mat), to = colnames(corr_mat), stringsAsFactors = FALSE) %>%
    filter(from != to) %>%
    mutate(pair_id = map2_chr(from, to, ~ paste(sort(c(.x, .y)), collapse = "_"))) %>%
    distinct(pair_id, .keep_all = TRUE) %>%
    mutate(correlation = mapply(function(x, y) corr_mat[x, y], from, to)) %>%
    filter(abs(correlation) > cor_threshold)

  # Step 3.7: Save link table
  write.csv(corr_links, file = file.path(out_dir_d50_DisClass_chord, paste0("LinkTable_", annot, "_absCorr", cor_threshold, ".csv")), row.names = FALSE)
}






# --- Step 4. Define plotting function for Circos plot of Disease mutant correlations
plot_annotation_genotype_chorddiagram <- function(annot_df, annotation_cols, disease_class_df, out_dir, min_gene_n = min_genes_per_genotype, corr_thresh = cor_threshold) {
  for (annot in annotation_cols) {
    message("Processing annotation: ", annot)
    
    # Filter genes for the annotation
    genes <- annot_df %>% filter(.data[[annot]] == 1) %>% pull(Genes) %>% unique()
    sub_df <- annot_df %>% filter(Genes %in% genes)

    # Make gene × genotype matrix
    mat_long <- sub_df %>%
      select(Genes, matches("_(iN|iDA)$")) %>%
      pivot_longer(-Genes, names_to = "sample", values_to = "log2fc") %>%
      filter(!is.na(log2fc)) %>%
      group_by(sample) %>%
      filter(n() >= min_gene_n) %>%
      ungroup()

    mat_wide <- mat_long %>%
      pivot_wider(names_from = sample, values_from = log2fc) %>%
      column_to_rownames("Genes")

    if (ncol(mat_wide) < 2) {
      warning("Skipping: Not enough valid samples for ", annot)
      next
    }

    # Compute correlation
    cor_mat <- cor(mat_wide, use = "pairwise.complete.obs", method = "pearson")

    # Save CSV
    write.csv(cor_mat, file = file.path(out_dir, paste0("CorrMatrix_", annot, ".csv")))

    # Make link table
    link_df <- expand.grid(from = colnames(cor_mat), to = colnames(cor_mat), stringsAsFactors = FALSE) %>%
      filter(from != to) %>%
      mutate(pair_id = pmap_chr(list(from, to), ~ paste(sort(c(..1, ..2)), collapse = "_"))) %>%
      distinct(pair_id, .keep_all = TRUE) %>%
      mutate(correlation = mapply(function(x, y) cor_mat[x, y], from, to)) %>%
      filter(abs(correlation) >= corr_thresh)

    if (nrow(link_df) == 0) {
      warning("Skipping: No high-correlation links for ", annot)
      next
    }

    # Group sector ordering by DiseaseClass
    sector_meta_df <- tibble(sample = colnames(cor_mat)) %>%
      mutate(
        KO = str_extract(sample, "^[^_]+"),
        CellType = str_extract(sample, "iN|iDA")
      ) %>%
      left_join(disease_class_df, by = "KO") %>%
      mutate(DiseaseClass = factor(DiseaseClass, levels = names(disease_colors))) %>%
      arrange(DiseaseClass, KO, CellType)  # cluster by DiseaseClass
    
    # Use this as the sector order
    sectors <- sector_meta_df$sample

    
    # Celltype layer
    celltype_df <- tibble(sample = sectors) %>%
      mutate(celltype = str_extract(sample, "iN|iDA"))
    celltype_colors <- setNames(neuron_colors[celltype_df$celltype], celltype_df$sample)

    # Disease class layer
    ko_labels <- str_extract(sectors, "^[^_]+")
    disease_df <- tibble(KO = ko_labels, sample = sectors) %>%
      left_join(disease_class_df, by = "KO") %>%
      mutate(DiseaseColor = disease_colors[DiseaseClass]) %>%
      replace_na(list(DiseaseColor = "grey90"))
    disease_colors_local <- setNames(disease_df$DiseaseColor, disease_df$sample)

    # Start PDF
    pdf(file.path(out_dir, paste0("ChordDiagram_", annot, ".pdf")), width = 10, height = 10)

    # Track colors
    neuron_type_colors <- setNames(neuron_colors[sector_meta_df$CellType], sector_meta_df$sample)
    disease_class_colors <- setNames(disease_colors[sector_meta_df$DiseaseClass], sector_meta_df$sample)
    
    # Clear and configure
    circos.clear()
    circos.par(start.degree = 90, gap.degree = 1)
    
    # Chord Diagram
    chordDiagram(
      link_df,
      order = sectors,
      grid.col = neuron_type_colors,  # Grid = inner = neuron type
      col = alpha(colorRamp2(c(-1, 0, 1), c("blue", "white", "red"))(link_df$correlation), 0.6),
      annotationTrack = "grid",
      transparency = 0,
      preAllocateTracks = list(
        #list(track.height = 0.05),  # Labels
        list(track.height = 0.03),  # Outer: disease type
        list(track.height = 0.03)   # Iner: neuron class
      )
    )
    
    # Track 1: Labels
    circos.trackPlotRegion(track.index = 1, panel.fun = function(x, y) {
      circos.text(CELL_META$xcenter, CELL_META$ylim[1] + mm_y(1),
                  CELL_META$sector.index,
                  facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5), cex = 0.5)
    }, bg.border = NA)
    
    # Track 2: Outer = disease class
    circos.trackPlotRegion(track.index = 2, bg.col = disease_class_colors, panel.fun = function(x, y) {}, bg.border = NA)
    
    # Track 3: Inner = neuron type
    circos.trackPlotRegion(track.index = 3, bg.col = neuron_type_colors, panel.fun = function(x, y) {}, bg.border = NA)
    


    # Title
    grid.text(paste0("Genotype Correlation | ", annot), x = 0.5, y = 0.98, gp = gpar(fontsize = 12, fontface = "bold"))

    # Legends
    draw(Legend(
      at = c(-1, 0, 1),
      col_fun = colorRamp2(c(-1, 0, 1), c("blue", "white", "red")),
      title = "Pearson r",
      direction = "horizontal",
      legend_width = unit(3, "cm")
    ), x = unit(0.5, "npc"), y = unit(0.02, "npc"), just = c("center", "bottom"))

    draw(Legend(labels = names(neuron_colors), legend_gp = gpar(fill = neuron_colors), title = "Neuron Type"),
         x = unit(0.02, "npc"), y = unit(0.02, "npc"), just = c("left", "bottom"))

    draw(Legend(labels = names(disease_colors), legend_gp = gpar(fill = disease_colors), title = "Disease Class"),
         x = unit(1, "npc"), y = unit(0.02, "npc"), just = c("right", "bottom"))

    dev.off()
  }
}



# --- Step 5. Call function and save in outdir 
plot_annotation_genotype_chorddiagram(
  annot_df = annotated_log2fc_df,
  annotation_cols = custom_annotation_cols,
  disease_class_df = disease_class_df,
  out_dir = out_dir_d50_DisClass_chord,
  min_gene_n = min_genes_per_genotype,
  corr_thresh = cor_threshold
)


# detach Compelxhatmap, since it masks pheatmap for later 
detach("package:ComplexHeatmap", unload = TRUE, character.only = TRUE)
```





# XII. Linear regression on neuro nDIA dataset
### XIIa. Linear regression on gene level across neurontypes
```{r}
# --------------------------------------------------- #
# Linear regression on neuro nDIA dataset
# Plot average correlation per annotation across genotypes
# --------------------------------------------------- #

### ---- Per-Gene Linear Modeling ----
# This script performs gene-specific linear regression to identify differential
# expression based on genotype and neuron type, accounting for experimental day.

# --- 1. Prepare and Factorize Data
# Filter out missing values and convert 'neuron' and 'genotype' to factors.
# 'iN' is set as the reference level for 'neuron'.
lm_results_gx2 <- clean_d50_df %>%
  filter(!is.na(fold_change), !is.na(genotype), !is.na(neuron)) %>%
  mutate(
    neuron   = factor(neuron, levels = c("iN", "iDA")),
    genotype = factor(genotype)
  )


# --- Step 2. Fit Per-Gene Linear Models
# Group data by gene, nest, and fit a linear model for 'fold_change' explained by
# 'genotype', 'neuron', their interaction, and 'day'.
lm_results <- lm_results_gx2 %>%
  group_by(Genes) %>%
  nest() %>%
  mutate(
    model = map(data, ~ tryCatch(
      lm(fold_change ~ genotype * neuron + day, data = .x),
      error = function(e) NULL
    ))),
    tidy = map(model, ~ if (!is.null(.x)) broom::tidy(.x) else tibble()
   %>%
  unnest(tidy) %>%
  filter(!is.na(p.value))


# --- Step 3. Add Q-values (FDR Corrected P-values)
# Apply Benjamini-Hochberg (BH) False Discovery Rate (FDR) correction to p-values
# within each 'term' category to control for multiple comparisons.
lm_results_df <- lm_results %>%
  group_by(term) %>%
  mutate(q.value = p.adjust(p.value, method = "BH")) %>%
  ungroup()


# --- Step 4: Filter for Significant Terms
# Filter for terms with a q-value (FDR-adjusted p-value) less than 0.05.
sig_genes_df <- lm_results_df %>%
  filter(q.value < 0.05)


# --- Step 5. Filter and Extract Interaction Terms
# Isolate significant **genotype:neuron interaction terms** and extract the
# genotype and neuron types for easier interpretation.
sig_hits <- sig_genes_df %>%
  filter(str_detect(term, "genotype") & str_detect(term, "neuron")) %>%
  mutate(
    genotype = str_extract(term, "(?<=genotype)[^:]+"),
    neuron = str_extract(term, "(?<=:neuron)[^:]+")
  )


# --- Step 6. Identify Top Genes by Absolute Effect Size
# For each genotype, select the top 5 genes with the largest absolute interaction
# effect size (estimate).
top_hits <- sig_hits %>%
  group_by(genotype) %>%
  slice_max(order_by = abs(estimate), n = 5, with_ties = FALSE) %>%
  ungroup()


# --- Step 7. Plot Results
# Generate a scatter plot showing interaction effect sizes. Point size indicates
# significance (-log10(q-value)), and `ggrepel` labels the top genes.
d50_LinReg_plot <- ggplot(sig_hits, aes(x = interaction(genotype, neuron), y = estimate)) +
  geom_point(aes(size = -log10(q.value)), alpha = 0.7, color = "#1f78b4") +
  geom_text_repel(data = top_hits, aes(label = Genes),
                  size = 2.5, max.overlaps = 100) +
  labs(title = "Top Differential Effects per Genotype:Neuron Interaction",
       x = "Genotype : Neuron", y = "Effect Size",
       size = "-log10(q-value)") +
  theme_bw(base_size = 10) +
  coord_flip()


# --- Step 8. Save Results
# Save the generated plot and the data frame of all significant terms.
ggsave(file.path(out_dir_d50_LinReg,"diff132_d50_LinReg.pdf"), d50_LinReg_plot, width = 8, height = 8, device = cairo_pdf)
write_csv(sig_genes_df, file=file.path(out_dir_d50_LinReg, "diff132_d50_LinReg_significant_genotype_hits.csv"))

```


### XIIb. Stratified linear modeling of genotype effects by neuron type
```{r}
# --------------------------------------------------- #
# Linear regression on neuro nDIA dataset
# Stratified linear modeling of genotype effects by neuron type
# --------------------------------------------------- #

# --- Step 1. Prepare input data
# Filter out incomplete rows and ensure proper factor encoding
lm_input_df <- clean_d50_df %>%
  filter(!is.na(fold_change), !is.na(genotype), !is.na(neuron)) %>%
  mutate(
    genotype = factor(genotype),
    neuron   = factor(neuron)
  )


# --- Step 2. Stratified linear regression function
# This function fits a linear model (fold_change ~ genotype + day)
# for each gene within a specified neuron type (iN or iDA)
fit_stratified_model <- function(df, neuron_label) {
  df %>%
    filter(neuron == neuron_label) %>%
    group_by(Genes) %>%
    nest() %>%
    mutate(
      # Remove NA rows inside nested data
      data = map(data, ~ .x %>% drop_na(fold_change, genotype, day)),

      # Fit model only if gene has sufficient variation
      model = map(data, ~ {
        d <- .x
        if (n_distinct(d$genotype) < 2 || n_distinct(d$day) < 2) return(NULL)
        lm(fold_change ~ genotype + day, data = d)
      }),

      # Extract tidy output if model succeeded
      tidy = map(model, ~ if (!is.null(.x)) broom::tidy(.x) else NULL)
    ) %>%
    filter(!map_lgl(tidy, is.null)) %>%     # keep only successful fits
    select(Genes, tidy) %>%
    unnest(tidy) %>%
    mutate(neuron = neuron_label)
}


# --- Step 3. Run model for each neuron type
lm_in_df  <- fit_stratified_model(lm_input_df, "iN")
lm_ida_df <- fit_stratified_model(lm_input_df, "iDA")

# Combine results from both neuron types
lm_neuronwise_df <- bind_rows(lm_in_df, lm_ida_df)


# --- Step 4. Adjust p-values for multiple testing
# Apply Benjamini-Hochberg correction within each term × neuron group
lm_neuronwise_df <- lm_neuronwise_df %>%
  group_by(term, neuron) %>%
  mutate(q.value = p.adjust(p.value, method = "BH")) %>%
  ungroup()


# --- Step 5. Extract and summarize significant results
# Keep only genotype-related terms (omit intercept), FDR < 0.05
ko_terms_sig <- lm_neuronwise_df %>%
  filter(str_detect(term, "^genotype"), term != "(Intercept)", q.value < 0.05)

# For each genotype × neuron term, get top 3 genes by effect size
top_ko_hits <- ko_terms_sig %>%
  group_by(term, neuron) %>%
  slice_max(order_by = abs(estimate), n = 3, with_ties = FALSE) %>%
  ungroup()


# --- Step 6. Visualization: Effect sizes for significant genotype terms
d50_LinRegNeuron_plot <- ggplot(ko_terms_sig, aes(x = term, y = estimate, fill = neuron)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.6) +
  geom_jitter(width = 0.2, alpha = 0.2, size = 0.3) +
  geom_text_repel(
    data = top_ko_hits,
    aes(label = Genes),
    size = 2.5, max.overlaps = 100
  ) +
  scale_fill_manual(values = c("iDA" = "dodgerblue", "iN" = "#F08080")) +
  labs(
    title = "Significant Genotype Effects by Neuron Type",
    x = "Genotype (KO vs ctrl)", y = "Estimated Effect",
    fill = "Neuron"
  ) +
  theme_bw(base_size = 10) +
  coord_flip()


# --- Step 7. Save output
# Save plot as PDF
ggsave(file.path(out_dir_d50_LinReg,"diff132_d50_LinReg_byNeuron.pdf"), d50_LinRegNeuron_plot, width = 8, height = 8, device = cairo_pdf)

# Export top hits to CSV
write_csv(top_ko_hits, file=file.path(out_dir_d50_LinReg, "diff132_d50_LinReg_significant_genotype_hits_neuron.csv"))

```


### XIIc. Limma linear modeling
Use-Case for limma (Linear Models for Microarray/omics Data)

limma is highly optimized for large-scale omics data where:
	•	Genes are modeled in parallel.
	•	The number of observations per gene is small (e.g. 3–5 replicates per condition).
	•	You want borrowing of variance information across genes to stabilize estimates.

Advantages:
	•	Empirical Bayes moderation of standard errors → improves power when sample size is small.
	•	Efficient for batch comparisons, e.g. all KOs vs ctrl.
	•	Handles complex designs via model.matrix().
	•	Very fast for large matrices.

Best suited if:
	•	Your data is already log-transformed intensities or fold changes.
	•	You want to test contrasts like:
	•	KO vs ctrl in iDA
	•	KO vs ctrl in iN
	•	KO effect shared across both neuron types
	•	Interaction (is KO effect different in iDA vs iN)
	
	
	Design Matrix: 
	design <- model.matrix(~ genotype * neuron, data = sample_meta)
	
	This generates three types of terms in your model:
	1.	Main effect of genotype
  	•	Measures how each genotype differs from the reference genotype in the reference neuron type (e.g. iDA).
  	•	Use when you’re asking: “Does genotype X differ from control in iDA neurons?”
	2.	Main effect of neuron
  	•	Measures the effect of switching from iDA to iN in the reference genotype (e.g. control).
  	•	Use when you’re asking: “Is there a baseline difference between neuron types in controls?”
	3.	Interaction: genotype:neuron
  	•	Tests whether the effect of genotype differs between neuron types.
  	•	Use when you’re asking: “Is the genotype effect different in iN vs iDA?”
  	•	This tells you if there’s a non-additive (context-specific) effect of the mutation in iN.

```{r}
# --------------------------------------------------- #
# Linear regression on neuro nDIA dataset
# Limma linear modeling
# --------------------------------------------------- #
# --- 0. create output directory 
out_dir_d50_LinReg_limma <- "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/LinReg/limma_all_coef"
dir.create(out_dir_d50_LinReg_limma, recursive = TRUE, showWarnings = FALSE)
out_dir_d50_LinReg_limma_select <- "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/LinReg/limma_select"
dir.create(out_dir_d50_LinReg_limma_select, recursive = TRUE, showWarnings = FALSE)

# ─────────────────────────────────────────────────────────────
# Linear model: ~ genotype * neuron
# - Main effect of genotype: difference of KO vs control in reference neuron (here -> iN)
# - Main effect of neuron: difference between iN vs iDA in control genotype
# - Interaction (genotype:neuron): difference in KO effect between iN and iDA
# 
# File explaination 
# - MAplot_iN_genotypeKO ==> effect of  KO vs control in iN (reference neuron)
# - MAplot_iN_genotypeKO.neuroniDA ==> difference in KO effect between iDA and iN. Does the KO behave differently in iDA compared to iN
# - MAplot_iDA_genotype…KOgenotypeKO.neuroniDA ==> effect of  KO vs control in iDA neurons
# ─────────────────────────────────────────────────────────────

diff132_long_reps <- read.csv('/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/datasets/lsd_pro_long.csv', 
                                    header = TRUE, sep = ',', stringsAsFactors = FALSE)


# --- Step 1.Filter out QC samples (NA genotype)
##          Filter out contaminant proteins
contaminant_genes <- c(
  "KRT8", "KRT19", "KRT9", "KRT10", "KRT2", "KRT18", "KRT1", "KRT5",
  "COL10A1", "COL13A1", "COL14A1", "COL18A1", "COL1A1", "COL1A2",
  "COL26A1", "COL2A1", "COL4A1", "COL4A2", "COL5A1", "COL6A1", "COL6A2"
  )

df_day50_filtered <- diff132_long_reps %>%
  filter(!is.na(genotype)) %>%
  filter(!Genes %in% contaminant_genes)



# --- Step 2. Create unique sample IDs from experimental metadata
df_day50_filtered <- df_day50_filtered %>%
  mutate(sample_id = paste(day, genotype, neuron, replicate, sep = "_"))


# --- Step 3. Pivot to wide format using unique sample IDs
expr_df <- df_day50_filtered %>%
  group_by(Genes, sample_id) %>%
  summarise(quan_0 = mean(quan_0, na.rm = TRUE), .groups = "drop") %>%
  pivot_wider(names_from = sample_id, values_from = quan_0) %>%
  column_to_rownames("Genes")


expr_mat <- expr_df %>%
  mutate(across(everything(), as.numeric)) %>%
  as.matrix()

# Log2-transform the expression matrix to stabilize variance
expr_mat <- log2(expr_mat + 1)  # add pseudocount to avoid log(0)



# --- Step 4.  clean df from NA, prepare metadata, and align samples
##          run limma 
# Impute NAs with row means
expr_mat[is.na(expr_mat)] <- rowMeans(expr_mat, na.rm = TRUE)[row(expr_mat)[is.na(expr_mat)]]

# Prepare sample metadata
sample_meta <- df_day50_filtered %>%
  select(sample_id, genotype, neuron) %>%
  distinct() %>%
  mutate(sample_id = make.names(sample_id))

# Align samples
colnames(expr_mat) <- make.names(colnames(expr_mat))
matching_ids <- intersect(colnames(expr_mat), sample_meta$sample_id)
expr_mat <- expr_mat[, matching_ids]
sample_meta <- filter(sample_meta, sample_id %in% matching_ids)

## check metadata: how many replicates per genotype X celltype?
table(sample_meta$genotype, sample_meta$neuron)

# Set reference level
sample_meta <- sample_meta %>%
  mutate(
    genotype = factor(genotype),
    neuron = factor(neuron, levels = c("iN", "iDA"))  # iN as reference
  )

# Full model with interaction
design <- model.matrix(~ genotype * neuron, data = sample_meta)
colnames(design) <- make.names(colnames(design))

# Fit model
fit <- lmFit(expr_mat, design)
fit <- eBayes(fit)

# Construct contrast matrix: iDA KO vs iDA ctrl = genotypeKO + genotypeKO:neuroniDA
contrasts_list <- colnames(design)
ko_levels <- grep("^genotype", contrasts_list, value = TRUE)
interaction_levels <- grep("^genotype.*:neuron", contrasts_list, value = TRUE)

# Extract KO names (excluding 'ctrl')
ko_names <- grep("^genotype(?!ctrl)", colnames(design), value = TRUE, perl = TRUE)

# Build iDA contrasts and store valid entries
ida_contrasts_list <- lapply(ko_names, function(ko) {
  interaction_term <- paste0(ko, ".neuroniDA")
  if (all(c(ko, interaction_term) %in% colnames(design))) {
    return(paste0(ko, " + ", interaction_term))
  } else {
    return(NULL)
  }
})

# Filter out NULLs
valid_idx <- !sapply(ida_contrasts_list, is.null)
ida_contrasts <- unlist(ida_contrasts_list[valid_idx])
names(ida_contrasts) <- gsub("^genotype", "iDA_", ko_names[valid_idx])

# Create contrast matrix
contrast_matrix <- makeContrasts(contrasts = ida_contrasts, levels = design)

# Fit contrasts
fit_contrasts <- contrasts.fit(fit, contrast_matrix)
fit_contrasts <- eBayes(fit_contrasts)



# --- Step 5. save limma results in output dir & save MA plot for each coefficient 
# Initialize list for saving variables 
results_all <- list()

# Loop through coefficients
# Combine all coefficient names: original + iDA contrasts
# Track coefficients from original and contrast fits
all_coef_names <- c(colnames(fit$coefficients), colnames(fit_contrasts$coefficients))
fit_sources <- c(rep("fit", ncol(fit)), rep("fit_contrasts", ncol(fit_contrasts)))

for (i in seq_along(all_coef_names)) {
  coef_name <- all_coef_names[i]
  fit_obj <- if (fit_sources[i] == "fit") fit else fit_contrasts
  prefix <- if (fit_sources[i] == "fit") "iN_" else "iDA_"

  res <- topTable(fit_obj, coef = coef_name, number = Inf, adjust.method = "BH") %>%
    rownames_to_column("Genes")

  matched_idx <- match(res$Genes, rownames(expr_mat))
  valid_idx <- which(!is.na(matched_idx))
  res <- res[valid_idx, ]
  matched_idx <- matched_idx[valid_idx]

  res <- res %>%
    mutate(
      coef = coef_name,
      baseMean = rowMeans(expr_mat[matched_idx, , drop = FALSE], na.rm = TRUE),
      log2FoldChange = log2(abs(logFC) + 1e-6) * sign(logFC),
      baseMean_log2  = log2(baseMean + 1e-6),
      padj = adj.P.Val,
      sig = case_when(
        #padj < 0.05 & log2FoldChange > log2(1.3)  ~ "Up",        # BH-adjusted p-value
        #padj < 0.05 & log2FoldChange < -log2(1.3) ~ "Down",      # BH-adjusted p-value
        P.Value < 0.01 & log2FoldChange > log2(2)  ~ "Up",      # raw p-value
        P.Value < 0.01 & log2FoldChange < -log2(2) ~ "Down",    # raw p-value
        TRUE ~ "NS"
      )
    )

  # Save per-contrast CSV
  write.csv(
    res,
    file = file.path(out_dir_d50_LinReg_limma, paste0("limma_results_", prefix, make.names(coef_name), ".csv")),
    row.names = FALSE
  )

  # Plot
  top_genes <- res %>% filter(sig != "NS") %>%
    slice_max(order_by = abs(log2FoldChange), n = 50)
  df_ns  <- res %>% filter(sig == "NS")
  df_sig <- res %>% filter(sig != "NS")

  p <- ggplot() +
    geom_point(data = df_ns, aes(x = baseMean, y = log2FoldChange),
               color = "gray70", size = 1.5, alpha = 0.5) +
    geom_point(data = df_sig, aes(x = baseMean, y = log2FoldChange, color = sig),
               size = 2.0) +
    geom_text_repel(data = top_genes,
                    aes(x = baseMean, y = log2FoldChange, label = Genes, color = sig),
                    size = 3, box.padding = 0.5, point.padding = 1,
                    max.overlaps = 75, segment.color = "grey50") +
    scale_color_manual(values = c("Down" = "#1465AC", "Up" = "#B31B21")) +
    theme_bw(base_size = 10) +
    labs(
      x = "Mean Abundance",
      y = "Log2 Fold Change",
      title = paste("MA Plot:", prefix, coef_name),
      color = "Significance"
    ) +
    theme(panel.grid = element_blank(), legend.position = "bottom")

  ggsave(
    filename = file.path(out_dir_d50_LinReg_limma, paste0("MAplot_", prefix, make.names(coef_name), ".pdf")),
    plot = p, width = 8, height = 8, device = cairo_pdf
  )

  results_all[[paste0(prefix, coef_name)]] <- res
}

# Combine and save all results
results_all_df <- bind_rows(results_all, .id = "coef")
write.csv(results_all_df, file.path(out_dir_d50_LinReg_limma, "limma_results_all.csv"), row.names = FALSE)


# check results ==> how many are significant etc 
# Check results
summary(results_all_df$P.Value)
sum(results_all_df$P.Value < 0.01)

 


# --- Step 6. Select limma results => if interested in spec. geno / celltype & save 
# List available coefficient names:
colnames(fit$coefficients)

# list of plottable coefficients
# # Intercept
# intercept <- c("X.Intercept.")
# 
# # Main effects: Genotype (in reference cell type iN)
# main_effect <- c(
#   "genotypeATP13A2", "genotypeCLN3", "genotypeCLN5", "genotypeCLN6",
#   "genotypeCLN8", "genotypectrl", "genotypeCTSD", "genotypeCTSF",
#   "genotypeDNAJC5", "genotypeGAA", "genotypeGBA1", "genotypeGRN",
#   "genotypeHEXA", "genotypeHEXB", "genotypeLIPA", "genotypeMCOLN1",
#   "genotypeMFSD8", "genotypeNPC1", "genotypeNPC2", "genotypePPT1",
#   "genotypePSAP", "genotypeSMPD1", "genotypeTPP1"
# )
# 
# # Main effect: Neuron type (iDA vs iN)
# neuron_effect <- c("neuroniDA")
# 
# # Interaction effects: Genotype × Neuron (difference in KO effect between iDA and iN)
# interaction_effect <- c(
#   "genotypeATP13A2.neuroniDA", "genotypeCLN3.neuroniDA", "genotypeCLN5.neuroniDA",
#   "genotypeCLN6.neuroniDA", "genotypeCLN8.neuroniDA", "genotypectrl.neuroniDA",
#   "genotypeCTSD.neuroniDA", "genotypeCTSF.neuroniDA", "genotypeDNAJC5.neuroniDA",
#   "genotypeGAA.neuroniDA", "genotypeGBA1.neuroniDA", "genotypeGRN.neuroniDA",
#   "genotypeHEXA.neuroniDA", "genotypeHEXB.neuroniDA", "genotypeLIPA.neuroniDA",
#   "genotypeMCOLN1.neuroniDA", "genotypeMFSD8.neuroniDA", "genotypeNPC1.neuroniDA",
#   "genotypeNPC2.neuroniDA", "genotypePPT1.neuroniDA", "genotypePSAP.neuroniDA",
#   "genotypeSMPD1.neuroniDA", "genotypeTPP1.neuroniDA"
# )   

# View results for interaction term (e.g., ATP13A2 genotype x iNeuron cell type)
resultsSelect <- topTable(fit, coef = "genotypeMFSD8.neuroniDA", number = Inf)

# Save results
write.csv(resultsSelect, file=file.path(out_dir_d50_LinReg_limma_select, "limma_results_genotypeMFSD8.neuroniDA.csv"), row.names = TRUE)

          
          

# --- Step 7. MA plot using ggplot for select input coefficient 
# Example: coefficient of interest
coef_name <- "genotypeMFSD8.neuroniDA"

resultsSelect <- results_all_df %>% filter(coef == coef_name)

## ggplot implementation 
# Annotate significance
de_df <- resultsSelect %>%
  mutate(
    sig = case_when(
        #padj < 0.05 & log2FoldChange > log2(1.3)  ~ "Up",        # BH-adjusted p-value
        #padj < 0.05 & log2FoldChange < -log2(1.3) ~ "Down",      # BH-adjusted p-value
        P.Value < 0.01 & log2FoldChange > log2(2)  ~ "Up",      # raw p-value
        P.Value < 0.01 & log2FoldChange < -log2(2) ~ "Down",    # raw p-value
      TRUE ~ "NS"
    )
  )

# filter top genes 
top_genes <- de_df %>%
  filter(sig != "NS") %>%
  slice_max(order_by = abs(log2FoldChange), n = 50)

# Split into NS and significant
df_ns  <- de_df %>% filter(sig == "NS")
df_sig <- de_df %>% filter(sig != "NS")

# Plot
neuroMAplot <- ggplot() +
  geom_point(data = df_ns, aes(x = baseMean, y = log2FoldChange), 
             color = "gray70", size = 1.5, alpha = 0.5) +
  geom_point(data = df_sig, aes(x = baseMean, y = log2FoldChange, color = sig), 
             size = 2.0) + 
  geom_text_repel(data = top_genes,
                    aes(x = baseMean, y = log2FoldChange, label = Genes, color = sig),
                    size = 3, box.padding = 0.5, point.padding = 1,
                    max.overlaps = 75, segment.color = "grey50") + 
  scale_color_manual(values = c("Down" = "#1465AC", "Up" = "#B31B21")) +
  theme_bw(base_size = 10) +
  labs(
    x = "Mean Abundance",
    y = "Log2 Fold Change",
    title = paste("MA Plot:", coef_name),
    color = "Significance"
  ) +
  theme(panel.grid = element_blank(),
        legend.position = "bottom")



ggsave(file.path(out_dir_d50_LinReg_limma,"MAplot_SelectGenotype.pdf"),
  neuroMAplot, width = 8, height = 8, device = cairo_pdf
)



```


# ??? XIII --- umap attempty of lin model results
```{r}
# UMAP Parameters Explained
# metric (default: “euclidean”)
# 	•	Defines the distance metric used in high-dimensional space.
# 	•	Common options:
# 	•	"euclidean": straight-line distance.
# 	•	"manhattan": sum of absolute differences.
# 	•	"cosine": angle-based, good for sparse / high-dimensional data.
# 	•	"correlation": clusters based on expression pattern, not magnitude (useful for gene-level analysis).

library(tidyverse)
library(uwot)      # for UMAP
library(ggplot2)
library(RColorBrewer)
library(scales)


# Create output directory
output_dir_umap <- "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/LinReg/umap"
dir.create(output_dir_umap, showWarnings = FALSE, recursive = TRUE)


# 1. Reshape results_all_df into a wide matrix: genes × coefficients
# Pivot to wide format: each gene's logFC across all coefficients
limma_UMAP_logfc_matrix <- results_all_df %>%
  select(Genes, coef, logFC) %>%
  pivot_wider(names_from = coef, values_from = logFC) %>%
  column_to_rownames("Genes")

# Optional: filter genes with too many NAs
limma_UMAP_logfc_matrix <- limma_UMAP_logfc_matrix[rowSums(is.na(limma_UMAP_logfc_matrix)) < 0.5 * ncol(limma_UMAP_logfc_matrix), ]

# Impute missing logFC with 0 or row/column mean (simplest: 0)
limma_UMAP_logfc_matrix[is.na(limma_UMAP_logfc_matrix)] <- 0

# 2. Run UMAP on logFC matrix
set.seed(123)
umap_res <- umap(limma_UMAP_logfc_matrix, n_neighbors = 10, min_dist = 0.1, metric = "manhattan")

umap_df <- as.data.frame(umap_genes$layout)

# 3. K-means clustering
kres <- kmeans(umap_df, centers = 18)

# 4. Create UMAP dataframe
colnames(umap_df) <- c("UMAP1", "UMAP2")
umap_df$cluster <- factor(kres$cluster)
umap_df$Genes <- rownames(limma_UMAP_logfc_matrix)

# 3. Merge with average logFC or metadata (optional)
gene_meta <- results_all_df %>%
  group_by(Genes) %>%
  summarise(mean_logFC = mean(logFC, na.rm = TRUE))

gene_group <- results_all_df %>%
  group_by(Genes) %>%
  slice_max(order_by = abs(log2FoldChange), n = 1, with_ties = FALSE) %>%
  select(Genes, coef)

umap_df <- umap_df %>%
  distinct(Genes, .keep_all = TRUE)
umap_df <- left_join(umap_df, gene_meta, by = "Genes")
umap_df <- left_join(umap_df, gene_group, by = "Genes")


# Create 18-color palette by interpolating
my_colors <- colorRampPalette(brewer.pal(9, "Set3"))(18)
custom_colors <- colorRampPalette(brewer.pal(9, "Set3"))(70)

# Plot 1: Cluster
umap_limma_cluster <- ggplot(umap_df, aes(x = UMAP1, y = UMAP2, color = cluster)) +
  geom_point(size = 1.2) +
  scale_color_manual(values = my_colors) +
  theme_bw(base_size = 10) +
  labs(color = "Cluster", title = "UMAP Clustering of Genes by logFC") +
  theme(panel.grid = element_blank(), legend.position = "bottom")

# Plot 2: logFC
umap_limma_logFC <- ggplot(umap_df, aes(x = UMAP1, y = UMAP2, color = mean_logFC)) +
  geom_point(size = 1.2, alpha = 0.8) +
  scale_color_gradientn(colors = colorRampPalette(rev(brewer.pal(n = 11, name = "RdBu")))(9)) +
  theme_bw(base_size = 10) +
  labs(color = "Mean logFC", title = "UMAP of genes across coefficients") +
  theme(panel.grid = element_blank(), legend.position = "bottom")

# Plot 3: coef
umap_limma_coef <- ggplot(umap_df, aes(x = UMAP1, y = UMAP2, color = coef)) +
  geom_point(alpha = 0.8, size = 1.5) +
  #scale_color_viridis_d()+
  scale_color_manual(values = custom_colors) +
  theme_bw(base_size = 10) +
  labs(color = "Mean logFC", title = "UMAP of Genes by logFC across Conditions", color = "Group (coef)")+
  theme(panel.grid = element_blank(), legend.position = "bottom")


umap_limma_cluster
umap_limma_logFC
umap_limma_coef

# save csv
write.csv(umap_df, file.path(output_dir_umap , "umap_results_genes.csv"), row.names = FALSE)



```



### --- UMAP embedding of combined features 
```{r}
library(uwot)

# feature matrix: rows = proteins, cols = (corr_to_orgX, logFC_genotypeY, …)
feat_mat <- complete_data_annotated_day50 %>% 
  select(Genes, ends_with("_log2_fold_change")) %>% 
  column_to_rownames("Genes") %>% 
  as.matrix() %>% 
  scale(center = TRUE)

set.seed(123)
umap_res <- uwot::umap(feat_mat, n_neighbors = 20, min_dist = 0.3)
umap_df  <- as.data.frame(umap_res) %>% 
            mutate(Gene = rownames(feat_mat)) %>% 
            left_join(binary_matrix, by = "Gene")

ggplot(umap_df, aes(V1, V2, colour = Lysosome.Genes)) +
  geom_point(size = 1, alpha = 0.6) +
  labs(title = "Protein landscape – UMAP")



## --- UMAP embedding of combined features --- ##
library(dplyr)
library(uwot)


feat_mat <- complete_data_annotated_day50 %>%
  select(Genes, ends_with("_log2_fold_change")) %>%
  distinct(Genes, .keep_all = TRUE) %>%  # drop any duplicates
  column_to_rownames("Genes") %>%
  as.matrix() %>%
  scale(center = TRUE)

annotations <- c("Mito", "Mito.IMS", "Mito.Matrix", "Mito.MIM", "Mito.MOM",
                 "OXPHOS", "mtComplexI", "Golgi.Genes", "Lysosome.Genes",
                 "ER.genes", "Cytoplasm", "Nucleus",
                 "Autophagy", "SynGO", "Endo_iN_curated_Hundley",
                 "Presynaptic", "Postsynaptic", "NeuroDev","EndoLyso","EarlyEndosome", "RecyclingEndosome", "SynapseSVs")

binary_matrix <- complete_data_annotated_day50 %>%
  select(Genes, all_of(annotations)) %>%
  distinct(Genes, .keep_all = TRUE) %>%
  tibble::column_to_rownames("Genes")

set.seed(123)
umap_res <- uwot::umap(feat_mat, n_neighbors = 8, min_dist = 0.01, metric = "manhattan")
umap_df <- as.data.frame(umap_res) %>%
  mutate(Genes = rownames(feat_mat)) %>%
  left_join(tibble::rownames_to_column(binary_matrix, "Genes"), by = "Genes")



umap_df <- umap_df %>%
  mutate(Lysosome_Label = factor(Lysosome.Genes, levels = c(FALSE, TRUE),
                                 labels = c("Not Lysosomal", "Lysosomal")))


ggplot(umap_df, aes(V1, V2, color = Lysosome_Label)) +
  geom_point(alpha = 0.7, size = 1) +
  scale_color_manual(values = c("Not Lysosomal" = "grey80", "Lysosomal" = "#D53E4F")) +
  labs(title = "UMAP of Proteins – Lysosomal Membership",
       x = "UMAP1", y = "UMAP2", color = "Membership") +
  theme_bw()



#Facet across organelles
library(tidyr)

# Reshape to long format: one row per Gene × Organelle
umap_long <- umap_df %>%
  select(V1, V2, Genes, all_of(annotations)) %>%
  pivot_longer(cols = all_of(annotations), names_to = "Organelle", values_to = "Membership") %>%
  mutate(Membership = factor(Membership, levels = c(FALSE, TRUE), labels = c("No", "Yes")))

# Plot with facets
ggplot(umap_long, aes(V1, V2, color = Membership)) +
  geom_point(size = 0.5, alpha = 0.7) +
  scale_color_manual(values = c("No" = "grey90", "Yes" = "#2166AC")) +
  facet_wrap(~ Organelle, ncol = 4) +
  labs(title = "UMAP: Organelle Membership by Protein",
       x = "UMAP1", y = "UMAP2", color = "Member") +
  theme_bw(base_size = 8)



#Color all organelle annotations in one UMAP
umap_df <- umap_df %>%
  mutate(OrganelleCount = rowSums(select(., all_of(annotations)), na.rm = TRUE))

ggplot(umap_df, aes(V1, V2, color = OrganelleCount)) +
  geom_point(size = 1, alpha = 0.8) +
  color_scale_gradientn(rev(RColorBrewer::brewer.pal(11, "RdYlBu")))
     labs(title = "UMAP Colored by Organelle Annotation Load",
       x = "UMAP1", y = "UMAP2", color = "# of Organelle Annotations") +
  theme_minimal()



#Color by genotype influence (e.g., average abs(log2FC))
log2fc_magnitude <- rowMeans(abs(feat_mat), na.rm = TRUE)

umap_df$KOeffect <- log2fc_magnitude[umap_df$Genes]

ggplot(umap_df, aes(V1, V2, color = KOeffect)) +
  geom_point(size = 1, alpha = 0.8) +
  scale_color_distiller(palette = "RdYlBu", direction = -1) +
  labs(title = "UMAP Colored by Genotype Effect Size",
       x = "UMAP1", y = "UMAP2", color = "Mean |log2FC|") +
  theme_minimal()
```


### Cross correlation of gene abunace per annotation for UMAP
https://embed.tidymodels.org/reference/step_umap.html

- do not have organelle IP data, but have very rich proteinIDs from the nDIA
- idea now is, for each organelle annotation list, to calculate the correlation of the proteins against each other, based on the log2FC from KO/Ctrl.
- have to embed the effect of the KO/Ctrl into the correlation
- then use these correlations and embed them in an UMAP.
- So in simple terms we embed the correlations of protein abundance influences both by the knockout (KO) and the local, synthetic protein environment (annotations)
```{r}
#install.packages("umap")
#library(umap)
library(ggplot2)
library(dplyr)
library(tidyr)
library(stringr)
#install.packages("uwot")
library(uwot)

# create new df variable, so it will not get corrupted 
UMAP_d50_df <- complete_data_annotated_day50

# Define your annotations
annotation_columns <- names(log2FC_d50_annotated)[(ncol(log2FC_d50_annotated)-19):ncol(log2FC_d50_annotated)]

# Step: Define usable annotations
usable_annotations <- colnames(complete_data_annotated_day50)[
  (ncol(complete_data_annotated_day50) - 17):ncol(complete_data_annotated_day50)
]

# Drop problematic or overly specific annotations
usable_annotations <- setdiff(usable_annotations, c("Autophagy..Detailed.", "EndoDetailed"))

# Function to process one annotation
process_annotation_umap <- function(usable_annotations) {
  # Step 1: Filter by annotation
  filtered <- log2FC_d50_annotated %>% filter(.data[[usable_annotations]] == TRUE)
  
  # Step 2: Extract log2FC matrix
  log2fc_mat <- filtered[, 2:47]
  log2fc_mat[is.na(log2fc_mat)] <- 0
  rownames(log2fc_mat) <- filtered$Genes
  
  # Step 3: Gene correlation
  gene_corr <- cor(t(log2fc_mat), use = "pairwise.complete.obs")
  gene_corr[is.na(gene_corr)] <- 0
  
  # Step 4: UMAP
  if (nrow(gene_corr) < 3) return(NULL)  # Skip tiny sets
  umap_res <- umap(gene_corr, n_neighbors = 10, min_dist = 0.1, metric = "correlation")
  
  # Step 5: Format output
  umap_df <- as.data.frame(umap_res)
  umap_df$Gene <- rownames(gene_corr)
  umap_df$Annotation <- usable_annotations
  return(umap_df)
}

# Run across all annotations
umap_all <- usable_annotations %>%
  map_dfr(~process_annotation_umap(.x))

# Plot UMAP embeddings
ggplot(umap_all, aes(x = V1, y = V2)) +
  geom_point(size = 1.2, alpha = 0.7) +
  facet_wrap(~Annotation, scales = "free") +
  theme_bw() +
  labs(title = "UMAP Embedding of Gene Correlation per Organelle Annotation",
       x = "UMAP1", y = "UMAP2")




# ----- annotation based UMAP ------ # 
# Load required libraries
library(dplyr)
library(stringr)
library(tidyr)
library(uwot)
library(ggplot2)


# --- Step 0: Copy input to avoid corrupting original ---
UMAP_d50_df <- complete_data_annotated_day50

# --- Step 1: Prepare log2FC and annotation matrices ---
log2fc_matrix_d50 <- UMAP_d50_df[, 2:47]
log2fc_matrix_d50[is.na(log2fc_matrix_d50)] <- 0
rownames(log2fc_matrix_d50) <- UMAP_d50_df$Genes

annotation_matrix_d50 <- UMAP_d50_df[, 48:ncol(UMAP_d50_df)]
rownames(annotation_matrix_d50) <- UMAP_d50_df$Genes

# Drop problematic annotations
annotation_matrix_d50 <- annotation_matrix_d50 %>%
  select(-c("Autophagy..Detailed.", "EndoDetailed"))

# --- Step 2: Identify valid annotations with ≥ 3 genes ---
valid_annotations <- annotation_matrix_d50 %>%
  summarise(across(everything(), ~sum(.x == TRUE))) %>%
  pivot_longer(cols = everything(), names_to = "Annotation", values_to = "Count") %>%
  filter(Count >= 3) %>%
  pull(Annotation)

# --- Step 3: Compute flattened correlation matrices ---
organelle_cor_vectors <- list()
max_length <- 0

for (ann in valid_annotations) {
  genes <- rownames(annotation_matrix_d50)[annotation_matrix_d50[[ann]] == TRUE]
  sub_mat <- log2fc_matrix_d50[genes, , drop = FALSE]
  if (nrow(sub_mat) < 3) next

  corr_mat <- cor(t(sub_mat), use = "pairwise.complete.obs")
  corr_mat[is.na(corr_mat)] <- 0

  corr_vec <- as.vector(corr_mat)
  organelle_cor_vectors[[ann]] <- corr_vec

  max_length <- max(max_length, length(corr_vec))
}

# --- Step 4: Pad correlation vectors to uniform length ---
organelle_correlation_matrix <- do.call(rbind, lapply(organelle_cor_vectors, function(v) {
  length(v) <- max_length
  v[is.na(v)] <- 0
  v
}))

# --- Step 5: UMAP embedding with disk-backed temp dir ---
cor_mat_file <- "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/organelle_correlation_matrix.rds"
umap_out_file <- "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/organelle_umap_result.rds"
local_tmp <- "~/umap_tmp"
dir.create(local_tmp, showWarnings = FALSE)

if (!exists("organelle_correlation_matrix")) {
  organelle_correlation_matrix <- readRDS(cor_mat_file)
}

if (!file.exists(umap_out_file)) {
  organelle_umap_result <- umap(
    organelle_correlation_matrix,
    n_neighbors = 5,
    min_dist = 0.1,
    metric = "euclidean",
    n_threads = 1,
    tmpdir = normalizePath(local_tmp),
    verbose = TRUE
  )
  saveRDS(organelle_umap_result, umap_out_file)
} else {
  organelle_umap_result <- readRDS(umap_out_file)
}

rownames(organelle_umap_result) <- rownames(organelle_correlation_matrix)

# --- Step 6: Plot UMAP ---
umap_df <- as.data.frame(organelle_umap_result)
umap_df$Annotation <- rownames(umap_df)

ggplot(umap_df, aes(x = V1, y = V2, label = Annotation)) +
  geom_point(size = 3, color = "grey30") +
  geom_text(size = 3, vjust = 1.2, hjust = 0.5) +
  labs(
    title = "UMAP of Organelle Log2FC Correlation Patterns",
    x = "UMAP1", y = "UMAP2"
  ) +
  theme_minimal()








# ----------- Gene-based UMAP -----------
library(dplyr)
library(ggplot2)
library(tidyr)
library(uwot)
library(irlba)
library(readr)
library(stringr)
library(RColorBrewer)
#install.packages("NatParksPalettes")
library(NatParksPalettes)

# Step 1: Gene correlation and PCA
gene_cor <- cor(t(log2fc_matrix_d50), use = "pairwise.complete.obs")
gene_cor[is.na(gene_cor)] <- 0

gene_pca <- prcomp_irlba(gene_cor, n = 100)

# Step 2: UMAP
gene_umap <- umap(
  gene_pca$x,
  n_neighbors = 25,
  min_dist = 0.2,
  metric = "cosine",
  n_threads = 1
)

# Step 3: Format UMAP output
gene_umap_df <- as.data.frame(gene_umap)
gene_umap_df$Gene <- rownames(log2fc_matrix_d50)

# ----------- Use subcell_df for annotation -----------
# subcell_df: each column = localization, values = gene symbols
# Step 4: Convert to long format
subcell_long <- subcell_df %>%
  pivot_longer(cols = everything(), names_to = "Localization", values_to = "Gene") %>%
  filter(!is.na(Gene))

# Step 5: Join with UMAP data (multi-row per gene possible)
gene_umap_annotated <- gene_umap_df %>%
  inner_join(subcell_long, by = "Gene")

# ----------- Plotting -----------
# Set a fixed palette length (e.g., 10 categories)
n_annots <- length(unique(gene_umap_annotated$Localization))
custom_colors <- colorRampPalette(rev(brewer.pal(11, "Paired")))(n_annots)

# UMAP with custom discrete colors
UMAP_gene <- ggplot(gene_umap_annotated, aes(x = V1, y = V2, color = Localization)) +
  geom_point(size = 0.8, alpha = 0.8) +
  scale_color_manual(values = custom_colors) +
  theme_classic() +
  labs(
    title = "ProteinID-level UMAP colored by subcellular localization",
    x = "UMAP 1", y = "UMAP 2", color = "Localization"
  )
UMAP_gene




# Faceted UMAP
# Assume 'gene_umap_annotated' has columns: V1, V2, Gene, Localization
# Step 1: Create a data frame with all combinations of genes and localizations
all_localizations <- unique(gene_umap_annotated$Localization)
all_genes <- gene_umap_annotated %>%
  select(Gene, V1, V2, Localization)

# Create all combinations
plot_data <- expand.grid(FacetLocalization = all_localizations, Gene = all_genes$Gene) %>%
  left_join(all_genes, by = "Gene")

# Step 2: Assign colors
plot_data <- plot_data %>%
  mutate(point_color = ifelse(Localization == FacetLocalization, "dodgerblue", "grey80"))

# Step 3: Separate the data into background and highlight points
background_points <- plot_data %>% filter(point_color == "grey80")
highlight_points <- plot_data %>% filter(point_color == "dodgerblue")

# Step 4: Plot
UMAP_gene_facet <- ggplot() +
  # Background layer: all points in grey
  geom_point(data = background_points, aes(x = V1, y = V2), color = "grey80", size = 0.8, alpha = 0.7) +
  # Highlight layer: points matching the facet's localization in blue
  geom_point(data = highlight_points, aes(x = V1, y = V2), color = "dodgerblue", size = 0.8, alpha = 0.7) +
  facet_wrap(~ FacetLocalization) +
  theme_classic() +
  labs(
    title = "ProteinID-level UMAP faceted by subcellular localization",
    x = "UMAP 1",
    y = "UMAP 2"
  )
UMAP_gene_facet




# Optional: save annotated file
write_csv(
  gene_umap_annotated,
  "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/gene_umap_annotated.csv"
)


# ------------ Combine Plots ----------- #
library(cowplot)
library(patchwork)

# combine plots for 
p10 <- UMAP_gene + theme(legend.position = "bottom")
p11 <- UMAP_gene_facet + theme(legend.position = "none")


# Combine layout: 
combined_plot_UMAP <- p10 / p11 +
  plot_layout(heights = c(0.5,1)) & 
  theme(plot.margin = margin(0.01, 10, 0.01, 10)) # Top, Right, Bottom, Left padding


# View or save
combined_plot_UMAP

# Save as PDF
ggsave("/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/diff132_d50_UMAP_gene_plot.pdf", combined_plot_UMAP, width = 12, height = 12, device = cairo_pdf)



```


    
# -------------------------------------------------- 
# -------- nDIA-nMOST comparative analysis ---------  
# --------------------------------------------------  



# XIII. nMOST whole cell plot correlcation matrix per genotype cluster
### XIIIa. nMOST LSD GO signatures of select Clusters for all genotypes
```{r}
# --------------------------------------------------- #
# HeLa nMOST whole cell correlations
# GO cluster ranking
# --------------------------------------------------- #

# --- Step 1. Color palette for gene groups
col <- c(
  AGA= "grey76", ARSA= "grey76", ARSB= "grey76", ASAH1="#D53E4F", PPT1= "#FEE08B", CTSD="#FEE08B", 
  GRN="#FEE08B", CLN12.ATP13A2="#FEE08B", CTSF="#FEE08B", KCTD7="grey76", TPP1="#FEE08B", CLN3="#FEE08B", 
  DNAJC5="#FEE08B", CLN5="#FEE08B", CLN6="#FEE08B", MFSD8="#FEE08B", CLN8="#FEE08B", CTNS="#E6F598", CTSA="grey76", 
  FUCA="grey76", GAA="#66C2A5", GALC="grey76", GALNS="#F46D43", GBA="#D53E4F", 
  GLA="grey76", GLB1="#D53E4F", GM2A="grey76", GNPTAB="grey76", GNPTG="grey76", GNS="grey76", 
  GUSB="grey76", HEXA="#D53E4F", HEXB="#D53E4F", HGSNAT="grey76", HYAL1="grey76", 
  IDS="grey76", IDUA="grey76", LAMP2="grey76", LIPA="#66C2A5", MAN2B1="grey76", MANBA="grey76", MCOLN1="#E6F598", 
  NAGA="grey76", NAGLU="grey76", NEU1="grey76", NPC1="#E6F598", NPC2="#E6F598", PSAP="#D53E4F", 
  SCARB2="grey76", SGSH="grey76", SLC17A5="grey76", SMPD1="#D53E4F", SUMF1="grey76"
)

# --- Step 2. Load and reshape the correlation data
HeLaCrossOmeCorrProt_df <- read.csv(
  '/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/20240801_dif118_iN-iDA_Ctrl-SMPD1-ASAH1_Proteomics/MSstats/HeLaCrossOmeCorr/LSD-nMOST_Protein-LipidCorr_tidyplots.csv',
  header = TRUE, sep = ',', stringsAsFactors = FALSE
)


# --- Step 3. Convert wide to long format and clean cluster names
HeLaCrossOmeCorrProt_df_long <- HeLaCrossOmeCorrProt_df %>%
  pivot_longer(cols = starts_with("Protein.Cluster"), names_to = "Cluster", values_to = "Score") %>%
  mutate(Cluster = Cluster %>%
           str_replace("Protein\\.Cluster\\.", "Cluster ") %>%
           str_replace("\\.Signature", ""))


# --- Step 4.  Order clusters by median for optional use
cluster_order <- HeLaCrossOmeCorrProt_df_long %>%
  group_by(Cluster) %>%
  summarise(med = median(Score, na.rm = TRUE)) %>%
  arrange(med) %>%
  pull(Cluster)

HeLaCrossOmeCorrProt_df_long <- HeLaCrossOmeCorrProt_df_long %>%
  mutate(Cluster = factor(Cluster, levels = cluster_order))


# --- Step 5. Main plotting function
HeLaClusterCorr <- function(df_long, cluster_name = "Cluster 7", plot_type = "mean") {
  df_filtered <- df_long %>%
    filter(Cluster == cluster_name) %>%
    mutate(Group = as.character(Group))

  # Sort groups by mean score for consistent display
  group_order <- df_filtered %>%
    group_by(Group) %>%
    summarise(mean_score = mean(Score, na.rm = TRUE)) %>%
    arrange(mean_score) %>%
    pull(Group)

  df_filtered <- df_filtered %>%
    mutate(Group = factor(Group, levels = group_order))

  if (plot_type == "mean") {
    # Barplot of group means
    df_filtered %>%
      group_by(Group) %>%
      summarise(mean_score = mean(Score, na.rm = TRUE)) %>%
      ggplot(aes(x = Group, y = mean_score)) +
      geom_col(fill = "grey40") +
      theme_minimal(base_size = 10) +
      labs(title = paste0("Mean score per group – ", cluster_name),
           x = NULL, y = "Mean Score") +
      theme(axis.text.x = element_text(angle = 45, hjust = 1))

  } else if (plot_type == "box") {
    # Color map for visible groups only
    used_groups <- levels(df_filtered$Group)
    col_used <- col[names(col) %in% used_groups]
    missing_groups <- setdiff(used_groups, names(col_used))
    col_used[missing_groups] <- "grey76"

    # Colored boxplot with quartile lines and y=0 reference
    ggplot(df_filtered, aes(x = Group, y = Score, fill = Group)) +
      geom_hline(yintercept = 0, linewidth = 0.4, linetype = "dashed", color = "black") +
      geom_boxplot(outlier.size = 0.5, color = "black", size = 0.3) +
      scale_fill_manual(values = col_used) +
      theme_bw(base_size = 10) +
      labs(title = paste0("nMOST Proteome Correlation GO – ", cluster_name),
           x = NULL, y = "Score") +
      theme(axis.text.x = element_text(angle = 90, hjust = 1),
            panel.grid = element_blank(),
            legend.position = "none")
  } else {
    stop("plot_type must be 'mean' or 'box'")
  }
}

## GO Cluster information:
# Cluster1: Chromosome, ribsosome
# Cluster2: Recycling endosome, vesicle membrane, early endosome membrane
# Cluster3: ER, ER lumen, mito
# Cluster4: Mito, mito matix 
# Cluster5: Lyso lumen, ER lumen, mito
# Cluster6: Cytoskeleton, actin cytoskeleton, focal adhesion
# Cluster7: late endosome, endosome, high-density lipoprotein particle 
# Cluster8: Autolysosome, lyososme, autophagosome
# Cluster9: Nucleus 
# Cluster10: Cytosol, centriolar satellite 
# Cluster11: Cytosol
# Cluster13: Peroxisome
# Cluster15: Plasma membrane raft 
# Cluster16: ER, MIto, Golgi membrane
# Cluster17: Transcription complex 
# Cluster18:  Membrane, golgi, late endosome, PM
  
# --- Step 6. Call function to plot cluster # of interest 
HeLaClusterCorrplot <- HeLaClusterCorr(HeLaCrossOmeCorrProt_df_long, "Cluster 2", plot_type = "box")
HeLaClusterCorrplot


# --- Step 7. Save as PDF
ggsave(file.path(out_dir_d50_nMOST_nDIAcorrelation,"nMOST_LSD_Corr_GOCluster2.pdf"), HeLaClusterCorrplot, width = 4, height = 4, device = cairo_pdf)

```

### XIIIb. nMOST GO Signatures of select genotype over all GO classes
``` {r}
# --------------------------------------------------- #
# HeLa nMOST whole cell correlations
# nMOST GO Signatures from select genotype over all GO classes 
# --------------------------------------------------- #

# --- Step 1. Function to plot all cluster signatures for a specific genotype
HeLaGenotypeSignature <- function(HeLaCrossOmeCorrProt_df_long, gene_name = "CLN3") {
  HeLaCrossOmeCorrProt_df_long_filtered <- HeLaCrossOmeCorrProt_df_long %>%
    filter(Group == gene_name) %>%
    mutate(Cluster = as.character(Cluster))

  # Order clusters by mean score
  cluster_order <- HeLaCrossOmeCorrProt_df_long_filtered  %>%
    group_by(Cluster) %>%
    summarise(mean_score = mean(Score, na.rm = TRUE)) %>%
    arrange(mean_score) %>%
    pull(Cluster)

  HeLaCrossOmeCorrProt_df_long_filtered <- HeLaCrossOmeCorrProt_df_long_filtered %>%
    mutate(Cluster = factor(Cluster, levels = cluster_order))

  ggplot(HeLaCrossOmeCorrProt_df_long_filtered, aes(x = Cluster, y = Score)) +
    geom_hline(yintercept = 0, linewidth = 0.4, linetype = "dashed", color = "black") +
    geom_boxplot(fill = "grey70", color = "black", outlier.size = 0.5, size = 0.3) +
    theme_bw(base_size = 10) +
    labs(title = paste0("nMOST Proteome GO Correlation – ", gene_name),
         x = NULL, y = "Score") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1),
          panel.grid = element_blank())
}


HeLaGenotypeSignaturePlot <- HeLaGenotypeSignature(HeLaCrossOmeCorrProt_df_long, "GBA")
HeLaGenotypeSignaturePlot

# --- Step 2. Save as PDF
ggsave(file.path(out_dir_d50_nMOST_nDIAcorrelation, "nMOST_LSD_CorrGenotype_GBA.pdf"), HeLaGenotypeSignaturePlot, width = 4, height = 8, device = cairo_pdf)

```



# XIV. Neuron - Hela Proteome Correlations 
use complete_data_annotated_day50 and group into iN and iDA
read in HeLa nMOST file
- match KOs and only use the ones found in all df
- calculate pairwise correlation based on genes / protein IDs per genotype
- plot corr across genotypes in crircos plot (color based on R corr)
- also plot heatmaps of pairwise comparisons 

### XIVa. Neuron–HeLa Proteome Correlation Analysis
```{r}
# --------------------------------------------------- #
# iNeuron - Hela Proteome Correlations 
# Neuron–HeLa Proteome Correlation Analysis
# --------------------------------------------------- #
library(ComplexHeatmap)
# -----------------------------
# I. Disease Class Definitions
# -----------------------------
disease_classes <- list(
  Sphigolipidoses = c("ARSA", "ASAH1", "GALC", "GBA1", "GLA", "GLB1", "GM2A", "HEXA", "HEXB", "PSAP", "SMPD1"),
  Mucopolysaccharidoses = c("GLB1", "ARSB", "GALNS", "GNS", "GUSB", "HGSNAT", "HYAL1", "IDS", "IDUA", "NAGLU", "SGSH"),
  Glycoproteinoses = c("AGA", "CTSA", "FUCA", "MAN2B1", "MANBA", "NAGA", "NEU1"),
  Neuronal.ceroid.lipofucinoses = c("PPT1", "CTSD", "GRN", "ATP13A2", "CTSF", "KCTD7", "TPP1", "CLN3", "DNAJC5", "CLN5", "CLN6", "MFSD8", "CLN8"),
  Integral.membrane.protein.disorders = c("ATP13A2", "CLN3", "CTNS", "LAMP2", "MCOLN1", "NPC1", "NPC2", "SCARB2", "SLC17A5"),
  PTM.defects = c("GNPTAB", "GNPTG", "SUMF1"),
  Lipid.storage.diseases = c("GAA", "LIPA")
)
disease_colors <- c(
  Sphigolipidoses = "#D53E4F", Mucopolysaccharidoses = "#F46D43",
  Glycoproteinoses = "#FDAE61", Neuronal.ceroid.lipofucinoses = "#FEE08B",
  Integral.membrane.protein.disorders = "#E6F598", PTM.defects = "#ABDDA4",
  Lipid.storage.diseases = "#66C2A5"
)
ko_to_class <- enframe(disease_classes) %>% unnest(value) %>% rename(KO = value, class = name)

# -----------------------------
# II. Data Preparation
# -----------------------------
neuron_proteome_wide <- complete_data_annotated_day50
HeLaWCnMOST_df <- read.csv("/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/HeLa_nMOSTWCprot.csv")

neuron_long <- neuron_proteome_wide %>%
  pivot_longer(-Genes, names_to = "sample_id", values_to = "log2_abundance") %>%
  filter(str_detect(sample_id, "log2_fold_change")) %>%
  mutate(
    genotype = str_extract(sample_id, "^[^_]+"),
    neuron = str_extract(sample_id, "_(iN|iDA)_") %>% str_remove_all("_")
  )

neuron_df <- neuron_long %>%
  filter(!is.na(log2_abundance)) %>%
  group_by(Genes, genotype, neuron) %>%
  summarise(mean_log2_abundance = mean(log2_abundance), .groups = "drop") %>%
  pivot_wider(names_from = neuron, values_from = mean_log2_abundance)

HeLa_long <- HeLaWCnMOST_df %>%
  rename(Genes = Gene.names) %>%
  pivot_longer(cols = ends_with(".KO"), names_to = "genotype", values_to = "hela_abundance") %>%
  mutate(genotype = str_remove(genotype, "\\.KO"))

merged_df <- inner_join(neuron_df, HeLa_long, by = c("Genes", "genotype"))

merged_wide <- merged_df %>%
  pivot_longer(c(iN, iDA), names_to = "neuron_type", values_to = "neuron_abundance") %>%
  mutate(sample = paste(genotype, neuron_type, sep = "_")) %>%
  select(Genes, sample, abundance = neuron_abundance) %>%
  bind_rows(
    merged_df %>%
      mutate(sample = paste0(genotype, "_HeLa")) %>%
      select(Genes, sample, abundance = hela_abundance)
  ) %>%
  group_by(Genes, sample) %>%
  summarise(abundance = mean(abundance, na.rm = TRUE), .groups = "drop") %>%
  pivot_wider(names_from = sample, values_from = abundance)

abundance_matrix <- merged_wide %>%
  column_to_rownames("Genes") %>%
  mutate(across(everything(), as.numeric)) %>%
  replace(is.na(.), 0) %>%
  as.matrix()

correlation_matrix_nMOSTnDIA <- cor(abundance_matrix, method = "pearson", use = "pairwise.complete.obs")

# -----------------------------
# III. Circos Plot Setup
# -----------------------------
sample_groups <- tibble(
  sample = colnames(correlation_matrix_nMOSTnDIA),
  group = case_when(
    str_detect(colnames(correlation_matrix_nMOSTnDIA), "_iN$") ~ "iN",
    str_detect(colnames(correlation_matrix_nMOSTnDIA), "_iDA$") ~ "iDA",
    str_detect(colnames(correlation_matrix_nMOSTnDIA), "_HeLa$") ~ "HeLa",
    TRUE ~ "Other"
  )
)

ordered_samples <- sample_groups %>% arrange(group, sample) %>% pull(sample)

# -----------------------------
# IV. Define Circos Plot Function
# -----------------------------
# Define global group color mapping
group_colors <- c("iN" = "dodgerblue", "iDA" = "#D53E4F", "HeLa" = "grey76")

# Define global sample color mapping for default fallback
sample_colors <- setNames(group_colors, names(group_colors))

# Define the plotting function
plot_dual_layer_circos <- function(link_df, title_text, output_path) {
  involved_samples <- unique(c(link_df$from, link_df$to))
  ordered_samples_local <- ordered_samples[ordered_samples %in% involved_samples]
  
  # Build disease class mapping aligned to ordered_samples_local
  ko_labels <- str_extract(ordered_samples_local, "^[^_]+")
  sector_classes_local <- tibble(sample = ordered_samples_local, KO = ko_labels) %>%
    left_join(ko_to_class, by = "KO") %>%
    mutate(disease_color = disease_colors[class]) %>%
    replace_na(list(disease_color = "grey90"))
  
  # ensure correct alignment
  disease_track_colors <- setNames(sector_classes_local$disease_color,
                                   sector_classes_local$sample)
  
  # Sample group mapping
  sample_colors_local <- setNames(group_colors[sample_groups$group[match(ordered_samples_local, sample_groups$sample)]],
                                  ordered_samples_local)
  
  pdf(output_path, width = 10, height = 12)
  circos.clear()
  circos.par(start.degree = 90, gap.degree = 4)
  
  chordDiagram(
    x = link_df,
    grid.col = sample_colors_local,
    col = colorRamp2(c(-1, 0, 1), c("blue", "white", "red"))(link_df$correlation),
    annotationTrack = "grid",
    transparency = 0,
    preAllocateTracks = list(
      #list(track.height = 0.05), # labels
      list(track.height = 0.03), # group colors
      list(track.height = 0.03)  # disease class colors
    ),
    order = ordered_samples_local
  )
  
  # Track 1: labels
  circos.trackPlotRegion(track.index = 1, panel.fun = function(x, y) {
    circos.text(CELL_META$xcenter, CELL_META$ylim[1] + mm_y(1),
                CELL_META$sector.index,
                facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5), cex = 0.6)
  }, bg.border = NA)
  
  # Track 2: group colors
  circos.trackPlotRegion(track.index = 2, bg.col = sample_colors_local,panel.fun = function(x, y) {}, bg.border = NA)
  
  # Track 3: disease class colors
  circos.trackPlotRegion(track.index = 3, bg.col = disease_track_colors, panel.fun = function(x, y) {}, bg.border = NA)
  
  # Title
  grid.text(title_text, x = 0.5, y = 0.98, gp = gpar(fontsize = 12, fontface = "bold"))
  
  # Add correlation legend
  cor_legend <- Legend(
    at = c(-0.5, -0.25, 0, 0.25, 0.5),
    col_fun = colorRamp2(c(-1, 0, 1), c("blue", "white", "red")),
    title = "Pearson r",
    direction = "horizontal",
    legend_width = unit(3, "cm")
  )
  draw(cor_legend, x = unit(0.5, "npc"), y = unit(0.02, "npc"), just = c("center", "bottom"))
  
  # Add disease class legend
  disease_legend <- Legend(
    labels = names(disease_colors),
    legend_gp = gpar(fill = disease_colors),
    title = "Disease Class",
    ncol = 2
  )
  draw(disease_legend, x = unit(1, "npc"), y = unit(0.02, "npc"), just = c("right", "bottom"))
  
  dev.off()
}
# -----------------------------
# V. Call Circos 
# -----------------------------
# Pairwise combinations (example)
pairwise_links <- expand.grid(from = colnames(correlation_matrix_nMOSTnDIA),
                              to = colnames(correlation_matrix_nMOSTnDIA),
                              stringsAsFactors = FALSE) %>%
  filter(from != to) %>%
  mutate(pair_id = pmap_chr(list(from, to), ~ paste(sort(c(..1, ..2)), collapse = "_"))) %>%
  distinct(pair_id, .keep_all = TRUE) %>%
  mutate(correlation = mapply(function(x, y) correlation_matrix_nMOSTnDIA[x, y], from, to))


# Identify inter-group correlations only
sample_groups <- data.frame(
  sample = colnames(correlation_matrix_nMOSTnDIA),
  group = case_when(
    str_detect(colnames(correlation_matrix_nMOSTnDIA), "_iN$")   ~ "iN",
    str_detect(colnames(correlation_matrix_nMOSTnDIA), "_iDA$")  ~ "iDA",
    str_detect(colnames(correlation_matrix_nMOSTnDIA), "_HeLa$") ~ "HeLa",
    TRUE ~ "Other"
  )
)

pairwise_links_inter <- pairwise_links %>%
  left_join(sample_groups, by = c("from" = "sample")) %>%
  rename(group_from = group) %>%
  left_join(sample_groups, by = c("to" = "sample")) %>%
  rename(group_to = group) %>%
  filter(group_from != group_to)  # Only inter-group comparisons


## plot function for both inter and intra correlations 
plot_dual_layer_circos(
  link_df = pairwise_links %>% filter(abs(correlation) > 0.05),
  title_text = "Neuron–HeLa Proteome Cross-Correlation",
  output_path = file.path(out_dir_d50_nMOST_nDIAcorrelation,"neuron_hela_circos_plot.pdf")
)



## plot only intra-celltype correlations:
plot_dual_layer_circos(
  link_df = pairwise_links_inter %>% filter(abs(correlation) > 0.05),
  title_text = "Inter-Group Neuron–HeLa Proteome Correlation",
  output_path = "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/nMOST-nDIAcorrelation/neuron_hela_circos_interonly.pdf"
)
#dev.off()
```



### XIVb. nMOST-nDIA correlation of select genotype 
```{r}
# --------------------------------------------------- #
# iNeuron - Hela Proteome Correlations 
# nMOST-nDIA correlation of select genotype
# --------------------------------------------------- #

# Functions to plot circos plot of select genotype. Splits by pos / neg correlation 
## change inter_only from FALSE to TRUE to only plot inter-group links
## inter_only = TRUE: Filters only inter-group links (e.g. iN–HeLa, iDA–HeLa, iN–iDA)

# --- 0. create output directory 
out_dir_d50_nMOST_nDIAcorrelationS_single <- "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/nMOST-nDIAcorrelation/SingleGeno"
dir.create(out_dir_d50_nMOST_nDIAcorrelationS_single, recursive = TRUE, showWarnings = FALSE)


# --- Step 1. Plotting function for user-def input 
circos_by_genotype <- function(ko,
                               pos_cut = 0.25,
                               neg_cut = -0.25,
                               out_dir = base_dir,
                               inter_only = TRUE) {
  # Create output directory if it doesn't exist
  if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)

  # 1. Find sample names matching the given KO
  ko_pat     <- paste0("^", ko, "_")
  ko_samples <- grep(ko_pat, colnames(correlation_matrix_nMOSTnDIA), value = TRUE)

  if (length(ko_samples) == 0) {
    stop("No samples matched the KO name ‘", ko, "’. Check spelling.")
  }

  # 2. Helper: Build link data frame based on correlation cutoff
  make_link_df <- function(cut_fun) {
    expand.grid(from = ko_samples,
                to   = colnames(correlation_matrix_nMOSTnDIA),
                stringsAsFactors = FALSE) |>
      dplyr::filter(from != to) |>
      dplyr::mutate(
        pair_id     = purrr::map2_chr(from, to, ~ paste(sort(c(.x, .y)), collapse = "_")),
        correlation = purrr::map2_dbl(from, to, ~ correlation_matrix_nMOSTnDIA[.x, .y])
      ) |>
      dplyr::filter(cut_fun(correlation)) |>
      dplyr::distinct(pair_id, .keep_all = TRUE) |>
      dplyr::select(-pair_id)
  }

  pos_links <- make_link_df(\(r) r >= pos_cut)
  neg_links <- make_link_df(\(r) r <= neg_cut)

  # 3. Optionally filter for inter-group links only
  if (inter_only) {
    pos_links <- pos_links |>
      dplyr::left_join(sample_groups, by = c("from" = "sample")) |>
      dplyr::rename(group_from = group) |>
      dplyr::left_join(sample_groups, by = c("to" = "sample")) |>
      dplyr::rename(group_to = group) |>
      dplyr::filter(group_from != group_to)

    neg_links <- neg_links |>
      dplyr::left_join(sample_groups, by = c("from" = "sample")) |>
      dplyr::rename(group_from = group) |>
      dplyr::left_join(sample_groups, by = c("to" = "sample")) |>
      dplyr::rename(group_to = group) |>
      dplyr::filter(group_from != group_to)
  }

  message(ko, ": ", nrow(pos_links), " positive; ",
              nrow(neg_links), " negative links kept")

  # 4. Define output file paths
  pos_file <- file.path(out_dir, paste0("circos_", ko, "_positive.pdf"))
  neg_file <- file.path(out_dir, paste0("circos_", ko, "_negative.pdf"))

  # 5. Plot
  if (nrow(pos_links) > 0) {
    plot_dual_layer_circos(
      link_df = pos_links,
      title_text = paste0(ko, " – positive r ≥ ", pos_cut),
      output_path = pos_file
    )
  }

  if (nrow(neg_links) > 0) {
    plot_dual_layer_circos(
      link_df = neg_links,
      title_text = paste0(ko, " – negative r ≤ ", neg_cut),
      output_path = neg_file
    )
  }
}



# --- Step 2. Call function block 
## Set output dir for plots / evaluations 
base_dir <- out_dir_d50_nMOST_nDIAcorrelationS_single

# Default thresholds (pos ≥ 0.25, neg ≤ –0.25)
circos_by_genotype("ASAH1")

# Relaxed threshold
circos_by_genotype("ASAH1", pos_cut = 0.05, neg_cut = -0.05)
```


### XIVc. HeLa-nMOST - neuron-nDIA organelle correlation
##### XIVc1. User-select annotations
```{r}
# --------------------------------------------------- #
# iNeuron,iDA  - Hela Proteome Correlations 
# HeLa-nMOST - neuron-nDIA organelle correlation
# --------------------------------------------------- #

#call pheatmap again, since compelxheatmap did mask it in call chunk before 
library(pheatmap)

## ─────────────────────────────────────────────────────────────
## 1.   Add annotations to HeLa-nMOST dataframe & save
## ─────────────────────────────────────────────────────────────
# use binary_matrix from IVa to add to HeLa-nMOST dataframe
# add to dataframe and save as .csv file 
HeLaWCnMOST_df_annotated <- HeLaWCnMOST_df %>%
  rename(Genes = 2) %>%
  left_join(binary_matrix, by = "Genes") %>%
  mutate(across(all_of(colnames(binary_matrix)[-1]), ~ ifelse(. == TRUE, TRUE, FALSE))) %>%
  replace(is.na(.), FALSE)

write.csv(HeLaWCnMOST_df_annotated,file = file.path(out_dir_d50_nMOST_nDIAcorrelation,"HeLaWCnMOST_annotated.csv"),row.names = FALSE)


## ─────────────────────────────────────────────────────────────
## 2.   Define annotations to be calculated in the function below
## ─────────────────────────────────────────────────────────────

selected_annotations <- c(
  "EndoLyso", "SynGO", "Endo_iN_curated_Hundley",
  "Lysosome", "Presynaptic", "Postsynaptic",
  "EarlyEndosome", "RecyclingEndosome"
)

selected_annotations = c("Mito","OXPHOS",
                  "mtComplexI","Golgi", "Lysosome","ER","Cytoplasm","Nucleus",
                  "Autophagy","SynGO","Endo_iN_curated_Hundley","SynapseSVs",
                  "Presynaptic","Postsynaptic","NeuroDev","EndoLyso","EarlyEndosome",
                  "RecyclingEndosome","SVfusion","Svendocytosis","Svexocytosis", "vATPase")

# selected_annotations = c("Mito","MitoIMS","MitoMatrix","MitoMIM","MitoMOM","OXPHOS",
#                   "mtComplexI","Golgi", "Lysosome","ER","Cytoplasm","Nucleus",
#                   "Autophagy","SynGO","Endo_iN_curated_Hundley","SynapseSVs",
#                   "Presynaptic","Postsynaptic","NeuroDev","EndoLyso","EarlyEndosome",
#                   "RecyclingEndosome","SVfusion","Svendocytosis","Svexocytosis","vATPase")


## ─────────────────────────────────────────────────────────────
## 3.   Function to calculate correlation for select annotation 
##      plots in circos plot
## ─────────────────────────────────────────────────────────────
plot_annotation_circos <- function(cor_mat, annot_name, output_path) {

  ## ─────────────────────────────────────────────────────────────
  ## 1. Prepare sample metadata
  ## ─────────────────────────────────────────────────────────────

  # Extract all sample names from the correlation matrix
  sector_names <- union(rownames(cor_mat), colnames(cor_mat))

  # Assign each sample to a cell type or origin
  sample_meta <- tibble(sample = sector_names) %>%
    mutate(geno_membership = case_when(
      str_detect(sample, "_iN") ~ "iN",
      str_detect(sample, "_iDA") ~ "iDA",
      str_detect(sample, "\\.KO$") ~ "HeLa",
      TRUE ~ "Other"
    ))

  # Define color scheme for sample types
  celltype_colors <- c("iN" = "dodgerblue", "iDA" = "#D53E4F", "HeLa" = "grey76")

  ## ─────────────────────────────────────────────────────────────
  ## 2. Create edge list from correlation matrix
  ## ─────────────────────────────────────────────────────────────

  link_df <- as.data.frame(as.table(cor_mat)) %>%
    rename(from = Var1, to = Var2, correlation = Freq) %>%
    mutate(from = as.character(from), to = as.character(to)) %>%
    filter(from != to) %>%
    mutate(pair_id = map2_chr(from, to, ~ paste(sort(c(.x, .y)), collapse = "_"))) %>%
    distinct(pair_id, .keep_all = TRUE) %>%
    select(-pair_id)

  ## ─────────────────────────────────────────────────────────────
  ## 3. Define color gradient for correlation strength
  ## ─────────────────────────────────────────────────────────────

  corr_palette <- rev(RColorBrewer::brewer.pal(11, "RdYlBu"))
  corr_values  <- seq(-0.6, 0.6, length.out = 11)
  col_fun <- colorRamp2(corr_values, corr_palette)

  ## ─────────────────────────────────────────────────────────────
  ## 4. Filter edges by threshold and prepare sample order
  ## ─────────────────────────────────────────────────────────────

  # Keep only strong correlations
  plot_links <- link_df %>%
    filter(correlation < -0.3 | correlation > 0.3)

  if (nrow(plot_links) == 0) {
  message("No correlations pass threshold for annotation: ", annot_name)
  return(invisible(NULL))
  }
  
  # Collect samples participating in selected edges
  samples_in_plot <- union(plot_links$from, plot_links$to)

  # Filter and order metadata for plotting
  ordered_sample_meta <- sample_meta %>%
    filter(sample %in% samples_in_plot) %>%
    arrange(geno_membership, sample)

  ordered_samples <- ordered_sample_meta$sample
  ordered_membership <- ordered_sample_meta$geno_membership
  sector_colors <- setNames(celltype_colors[ordered_membership], ordered_samples)
  celltype_ring_colors <- sector_colors
  
  ## ─────────────────────────────────────────────────────────────
  ## 5. Compute spacing between sectors
  ## ─────────────────────────────────────────────────────────────

  gap_between_sectors <- 1
  gap_between_groups  <- 10

  group_counts <- ordered_sample_meta %>%
    dplyr::count(geno_membership, name = "n") %>%
    pull(n)

  gap_after <- unlist(lapply(group_counts, function(n) {
    c(rep(gap_between_sectors, n - 1), gap_between_groups)
  }))
  gap_after[length(gap_after)] <- 0  # no trailing gap

  ## ─────────────────────────────────────────────────────────────
  ## 6. Draw circos plot
  ## ─────────────────────────────────────────────────────────────

  pdf(output_path, width = 10, height = 12)
  circos.clear()
  circos.par(start.degree = 90, gap.after = gap_after)

  chordDiagram(
    x = plot_links,
    grid.col = sector_colors,
    col = col_fun(plot_links$correlation),
    annotationTrack = "grid",
    transparency = 0.1,
    preAllocateTracks = list(
      list(track.height = 0.05),  # sector label track
      list(track.height = 0.03)   # outer ring track
    ),
    order = ordered_samples
  )

  # Track 1: Sample labels
  circos.trackPlotRegion(track.index = 1, panel.fun = function(x, y) {
    tryCatch({
      circos.text(
        CELL_META$xcenter, CELL_META$ylim[1] + mm_y(1),
        CELL_META$sector.index,
        facing = "clockwise", niceFacing = TRUE,
        adj = c(0, 0.5), cex = 0.6
      )
    }, error = function(e) {})
  }, bg.border = NA)

  # Track 2: Cell type color ring
  circos.trackPlotRegion(track.index = 2, bg.col = celltype_ring_colors,
                         panel.fun = function(x, y) {}, bg.border = NA)

  ## ─────────────────────────────────────────────────────────────
  ## 7. Add legends
  ## ─────────────────────────────────────────────────────────────

  draw(Legend(
    at = c(-0.6, 0, 0.6),
    col_fun = col_fun,
    title = "Pearson r",
    direction = "horizontal",
    legend_width = unit(3, "cm")
  ), x = unit(0.5, "npc"), y = unit(0.02, "npc"), just = c("center", "bottom"))

  draw(Legend(
    labels = names(celltype_colors),
    legend_gp = gpar(fill = celltype_colors),
    title = "Cell Type",
    ncol = 1
  ), x = unit(1, "npc"), y = unit(0.02, "npc"), just = c("right", "bottom"))

  dev.off()
}

## ─────────────────────────────────────────────────────────────
## 4.   Call circos function 
## ─────────────────────────────────────────────────────────────
in_dir <- out_dir_d50_nMOST_nDIAcorrelationS_OrganelleComp

for (ann in selected_annotations) {
  message("Plotting circos for: ", ann)

  cor_path <- file.path(in_dir, paste0("cor_", ann, ".csv"))
  if (!file.exists(cor_path)) {
    warning("Correlation file not found for: ", ann)
    next
  }

  # Load correlation matrix
  cor_mat <- read.csv(cor_path, row.names = 1, check.names = FALSE)
  cor_mat <- as.matrix(cor_mat)

  # Define output path
  circos_out <- file.path(
    out_dir_d50_nMOST_nDIAcorrelationS_Circos,
    paste0("circos_", ann, ".pdf")
  )

  # Generate circos plot
  plot_annotation_circos(
    cor_mat = cor_mat,
    annot_name = ann,
    output_path = circos_out
  )
}


## ─────────────────────────────────────────────────────────────
## 5.   Function to calculate correlation for select annotation 
##      plots in pheatmap and saves as csv
## ─────────────────────────────────────────────────────────────
calculate_annotation_correlation_matrix <- function(annot_name, neuron_df, hela_df) {
  # Filter for genes in annotation
  genes <- neuron_df %>%
    filter(!!sym(annot_name) == TRUE) %>%
    pull(Genes) %>%
    intersect(hela_df$Genes)

  # Prepare matrices
  neuron_mat <- neuron_df %>%
    filter(Genes %in% genes) %>%
    select(Genes, matches("^.*log2_fold_change.*")) %>%
    group_by(Genes) %>%
    summarise(across(everything(), mean, na.rm = TRUE), .groups = "drop") %>%
    column_to_rownames("Genes")

  hela_mat <- hela_df %>%
    filter(Genes %in% genes) %>%
    select(Genes, matches("\\.KO$")) %>%
    group_by(Genes) %>%
    summarise(across(everything(), mean, na.rm = TRUE), .groups = "drop") %>%
    column_to_rownames("Genes")

  # Keep only common genes
  common_genes <- intersect(rownames(neuron_mat), rownames(hela_mat))
  if (length(common_genes) < 5) {
    warning(paste("Too few genes for", annot_name))
    return(NULL)
  }

  neuron_mat <- neuron_mat[common_genes, ]
  hela_mat <- hela_mat[common_genes, ]

  # Pearson correlation
  cor_mat <- cor(neuron_mat, hela_mat, method = "pearson", use = "pairwise.complete.obs")

  # Save CSV
  write.csv(
    cor_mat,
    file = file.path(out_dir_d50_nMOST_nDIAcorrelationS_OrganelleComp, paste0("cor_", annot_name, ".csv")),
    quote = FALSE
  )

  # Prepare annotation for heatmap rows
  celltype_vec <- ifelse(grepl("iN", rownames(cor_mat)), "iN",
                         ifelse(grepl("iDA", rownames(cor_mat)), "iDA", NA))
  annotation_row <- data.frame(CellType = factor(celltype_vec, levels = c("iN", "iDA")))
  rownames(annotation_row) <- rownames(cor_mat)
  annotation_colors <- list(CellType = c(iN = "grey40", iDA = "grey80"))

  # Plot heatmap
  pheatmap::pheatmap(
    cor_mat,
    cluster_rows = TRUE,
    cluster_cols = TRUE,
    main = paste("Correlation:", annot_name),
    annotation_row = annotation_row,
    annotation_colors = annotation_colors,
    color = rev(RColorBrewer::brewer.pal(11, "RdYlBu")),
    fontsize = 6,
    border_color = NA,
    cellheight = 8,
    cellwidth = 8,
    filename = file.path(out_dir_d50_nMOST_nDIAcorrelationS_OrganelleComp, paste0("cor_", annot_name, ".pdf")),
    width = 8,
    height = 8
  )

  return(cor_mat)
}


## ─────────────────────────────────────────────────────────────
## 6.   Call function and plot heatmaps + csv files   
## ─────────────────────────────────────────────────────────────
all_corrs <- lapply(selected_annotations, function(ann) {
  message("Processing: ", ann)
  calculate_annotation_correlation_matrix(ann, complete_data_annotated_day50, HeLaWCnMOST_df_annotated)
})
# names(all_corrs) <- selected_annotations



```


##### XIVc2. Eval of combined annotations
```{r}
# --------------------------------------------------- #
# iNeuron,iDA - Hela Proteome Correlations 
# HeLa-nMOST - neuron-nDIA organelle correlation
# Combined select organelle level
# --------------------------------------------------- #

## ─────────────────────────────────────────────────────────────
## 1.   Combine all genes from selected annotations
## ─────────────────────────────────────────────────────────────
combined_genes <- unique(unlist(lapply(selected_annotations, function(ann) {
  intersect(
    complete_data_annotated_day50 %>% filter(!!sym(ann) == TRUE) %>% pull(Genes),
    HeLaWCnMOST_df_annotated$Genes
  )
})))


## ─────────────────────────────────────────────────────────────
## 2. Prepare matrices for combined annotations
## ─────────────────────────────────────────────────────────────
# Neuron matrix: iN and iDA
neuron_mat_combined <- complete_data_annotated_day50 %>%
  filter(Genes %in% combined_genes) %>%
  select(Genes, matches("^.*log2_fold_change.*")) %>%
  group_by(Genes) %>%
  summarise(across(everything(), mean, na.rm = TRUE), .groups = "drop") %>%
  column_to_rownames("Genes")

# HeLa matrix
hela_mat_combined <- HeLaWCnMOST_df_annotated %>%
  filter(Genes %in% combined_genes) %>%
  select(Genes, matches("\\.KO$")) %>%
  group_by(Genes) %>%
  summarise(across(everything(), mean, na.rm = TRUE), .groups = "drop") %>%
  column_to_rownames("Genes")


## ─────────────────────────────────────────────────────────────
## 3. Match genes & calcualte correlations
## ─────────────────────────────────────────────────────────────
shared_genes <- intersect(rownames(neuron_mat_combined), rownames(hela_mat_combined))
neuron_mat_combined <- neuron_mat_combined[shared_genes, ]
hela_mat_combined   <- hela_mat_combined[shared_genes, ]

cor_mat_combined <- cor(neuron_mat_combined, hela_mat_combined, method = "pearson", use = "pairwise.complete.obs")
cor_mat_combined[!is.finite(cor_mat_combined)] <- 0



## ─────────────────────────────────────────────────────────────
## 4. Add back row annotations & plot heatmap
## ─────────────────────────────────────────────────────────────
# Row annotations for neurons
celltype_vec <- ifelse(grepl("iN", rownames(cor_mat_combined)), "iN",
                  ifelse(grepl("iDA", rownames(cor_mat_combined)), "iDA", NA))
annotation_row <- data.frame(CellType = factor(celltype_vec, levels = c("iN", "iDA")))
rownames(annotation_row) <- rownames(cor_mat_combined)

annotation_colors <- list(CellType = c(iN = "grey40", iDA = "grey80"))



# Plot heatmap
pheatmap::pheatmap(
  cor_mat_combined,
  cluster_rows = TRUE,
  cluster_cols = TRUE,
  main = "Combined Annotation Correlation",
  color = rev(RColorBrewer::brewer.pal(11, "RdYlBu")),
  fontsize = 6,
  border_color = NA,
  cellheight = 8,
  cellwidth = 8,
  annotation_row = annotation_row,
  annotation_colors = annotation_colors,
  filename = file.path(out_dir_d50_nMOST_nDIAcorrelationS_OrganelleComp, "cor_combined_annotations.pdf"),
  width = 8, height = 8
)
```


# XV. Sph Mutants nMOST-nDIA comparison 
correlation of annotated genotypes
focus on SVs and endolysosomal system for comparisons 
make new df of only KOs in all three genotypes 
compture corr across the three datasets
compture select corr for annnotations (write function again)

