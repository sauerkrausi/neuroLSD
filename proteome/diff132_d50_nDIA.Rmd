---
title: "diff132_d50_nDIA"
output: html_document
date: "`r Sys.Date()`"
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# I. load packackes & set project directory
```{r}
setwd("/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132")

#install.packages("GWalkR")
#library(GWalkR)
#install.packages("gptstudio")
library(gptstudio)
library(plyr)
library(grid)
library(stringr)
library(tidyverse)
library(dplyr)
library(tibble)
library(purrr)
library(rlang)
library(devtools)
#install_github("vqv/ggbiplot")
library(ggbiplot)
library(ggrepel)
library(scales)
library(cowplot)
library(NatParksPalettes)
library(viridis)
library(RColorBrewer)
library(gridExtra)
library(ggplot2)
##install("gplots")
library(gplots)
library(ggVennDiagram)
install_github("jokergoo/ComplexHeatmap")
library(ComplexHeatmap)
#library(dendextend)
#install.packages("magick")
#library(magick)
library(png)
#devtools::install_github("rlbarter/superheat")
library(superheat)
install.packages("fmsb")
library(fmsb)
#devtools::install_github("krassowski/complex-upset")
library(ComplexUpset)
#install.packages("UpSetR")
library(UpSetR)
library(data.table)
library(plotly)
library(gghighlight)
#devtools::install_github("jbengler/tidyplots")
library(tidyplots)
library(tidyverse)
library(tidyr)
#install.packages("pheatmap")
library(pheatmap)
#install.packages("RColorBrewer")
library(patchwork)

# For the CRAN version
#install.packages("bigstatsr")
# For the latest version
#remotes::install_github("privefl/bigstatsr")
library(bigstatsr)
library(irlba)
library(lintr)
library(ggrepel)


```


# II. Circos plot for neuroLSD 
```{r}
#install and load the package
library(circlize)


#read the csv file
#read in first column (==gene) as row title
LSD <- read.csv('/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD/Proteomics_Lipidomics/Data_forplots/Circos/LSD_circos.csv', 
                header=T, row.names=1)

#convert the table to a martix
data <- as.matrix(LSD)

#create a chord diagram
chordDiagram(data)

############## CIRCOS Plot with confirmed KOs #####################
## plot only confirmed KOs in color, rest of genes in grey/ per disease group
## save plot as pdf 

# set colors for disease groups
col = c(Sphigolipidoses="#D53E4F",	Mucopolysaccharidoses="#F46D43",	Glycoproteinoses="#FDAE61", Neuronal.ceroid.lipofucinoses="#FEE08B",	
        Integral.membrane.protein.disorders="#E6F598",	PTM.defects="#ABDDA4",	Lipid.storage.diseases= "#66C2A5",
        
        AGA= "grey76", ARSA= "grey76", ARSB= "grey76", ASAH1="#D53E4F", CLN1.PPT1= "#FEE08B", CLN10.CTSD="#FEE08B", 
        CLN11.GRN="#FEE08B", CLN12.ATP13A2="#FEE08B", CLN12.ATP13A2="#E6F598", CLN13.CTSF="#FEE08B", CLN14.KCTD7="grey76", CLN2.TPP1="#FEE08B", CLN3="#FEE08B", CLN3="#E6F598", 
        CLN4.DNAJC5="#FEE08B", CLN5="#FEE08B", CLN6="#FEE08B", CLN7.MFSD8="#FEE08B", CLN8="#FEE08B", CTNS="#E6F598", CTSA="grey76", 
        FUCA="grey76", GAA="#66C2A5", GALC="grey76", GALNS="#F46D43", GBA="#D53E4F", 
        GLA="grey76", GLB1="#D53E4F", GM2A="grey76", GNPTAB="grey76", GNPTG="grey76", GNS="grey76", 
        GUSB="grey76", HEXA="#D53E4F", HEXB="#D53E4F", HGSNAT="grey76", HYAL1="grey76", 
        IDS="grey76", IDUA="grey76", LAMP2="grey76", LIPA="#66C2A5", MAN2B1="grey76", MANBA="grey76", MCOLN1="#E6F598", 
        NAGA="grey76", NAGLU="grey76", NEU1="grey76", NPC1="#E6F598", 
        NPC2="#E6F598", PSAP="#D53E4F", SCARB2="grey76", SGSH="grey76", SLC17A5="grey76",SMPD1="#D53E4F", SUMF1="grey76")


# Set output path and size
pdf("/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/LSD_circos_plot_confirmed_KOs.pdf", width = 10, height = 10)  # adjust size as needed

# Plot: chord diagram
chordDiagram(data, 
             grid.col = col, 
             annotationTrack = "grid", 
             preAllocateTracks = 1, 
             transparency = 0.1,
             link.lwd = 1,    
             link.lty = 1,    
             link.border = 1)

# Add labels
circos.trackPlotRegion(track.index = 2, panel.fun = function(x, y) {
  xlim = get.cell.meta.data("xlim")
  ylim = get.cell.meta.data("ylim")
  sector.name = get.cell.meta.data("sector.index")
  
  circos.text(mean(xlim), ylim[1] + 2.5, sector.name, 
              facing = "clockwise", niceFacing = TRUE, 
              adj = c(0, 0.5), cex = 0.6)
}, bg.border = "black")

# Finish writing the PDF
dev.off()


```



# III. day50 nDIA whole cell proteomics of iNeurons and iDA
Samples are in triplicates whole-cell samples from 12-well plates.
day 50 of in vitro differentiation of iN and iDA
Genotypes: Ctrl, ASAH1, CLN1.PPT1, CLN10.CTSD, CLN11.GRN, CLN12.ATP13A2, CLN12.ATP13A2, CLN13.CTSF,CLN2.TPP1, CLN3, CLN4.DNAJC5, CLN5, CLN6, CLN7.MFSD8, CLN8, CTNS, GAA, GBA, GLB1, HEXA, HEXB,LIPA, MCOLN1.TRPML1, NPC1, NPC2, PSAP, SMPD1
        
        
### IIIa. PCA plots of data
plot PCA plots to check data landscape on top level 
Have following genotypes and cells in there
iN, DA, pool (== QC mmaker)
3 replicates for genotypes 

```{r}
#install.packages("irlba")
library(irlba)
## Step 1: Read in the data from the CSV file
# The CSV file has been pre-processed in Excel to replace all NA values with 0.
diff132_d50_PCA_df_full <- read.csv('/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/datasets/lsd_pro_long.csv', 
                                    header = TRUE, sep = ',', stringsAsFactors = FALSE)

# Step 1.5: Fill NA or empty values in 'neuron' and 'replicate' with QC info
diff132_d50_PCA_df_full <- diff132_d50_PCA_df_full %>%
  mutate(
    is_qc = is.na(neuron) | neuron == "",
    neuron = ifelse(is_qc, "QC", neuron),
    replicate = ifelse(is_qc, as.character(seq_len(sum(is_qc))), replicate)
  )

# Step 2: Inspect the structure of the data
# This helps to understand the data types and identify which columns to retain or remove.
str(diff132_d50_PCA_df_full)

# Step 3: Remove unnecessary columns
# Assuming columns 1, 2, 4, 5, and 10 are not needed for PCA, they are removed.
diff132_d50_PCA_df <- diff132_d50_PCA_df_full[, -c(1,2,4,6,7,13,14)]

# Step 4: Identify and remove rows with missing or empty 'Genes' entries
# It's crucial to ensure that each gene has a valid identifier for accurate analysis.
# Identify problematic rows where 'Genes' is NA or an empty string
problematic_rows <- diff132_d50_PCA_df %>%
  filter(is.na(Genes) | Genes == "")

# Remove these problematic rows from the dataset
cleaned_df <- diff132_d50_PCA_df %>%
  filter(!is.na(Genes) & Genes != "") %>%       # remove empty gene names
  filter(!is.na(quan))                          # remove missing values in quan

# Step 5: Reshape the data from long to wide format
# Each gene will become a separate column, with 'quan' values as the data points.
# Missing values are filled with 0, and duplicate entries are summed.
d50_df_wide <- cleaned_df %>%
  group_by(Genes, genotype, neuron, day, replicate) %>%  # keep day info here
  summarise(across(quan, sum), .groups = "drop") %>%
  pivot_wider(
    names_from = Genes, # Column whose unique values will become new column names
    values_from = quan, # Column providing values for the new columns
    values_fill = list(quan = 0), # Fill missing values with 0
    values_fn = list(quan = sum) # Sum values if there are duplicates
  )

# Step 6: Select only numeric columns for PCA
# Keep sample-level metadata
sample_metadata <- d50_df_wide %>%
  select(genotype, neuron, day, replicate)

# Non-numeric data (like sample IDs) are excluded to prevent errors in PCA computation.
d50_numeric_data <- d50_df_wide %>%
  select_if(is.numeric)

# Step 7: Perform Principal Component Analysis (PCA)
# Step 7.1: PCA calculation is too large.. have to find different approach 
  # The data is scaled to ensure each variable contributes equally to the analysis.
  # Use irlba::prcomp_irlba() for approximate PCA
  # Much less memory required. You specify how many PCs (n) you want.
pca_res_d50 <- prcomp_irlba(d50_numeric_data, n = 10, scale. = TRUE)


# Step 8: Extract PCA scores into a data frame
# These scores represent the principal components for each sample.
pca_scores_d50 <- as.data.frame(pca_res_d50$x)
pca_scores_d50 <- cbind(sample_metadata, pca_scores_d50)
pca_scores_d50$day <- factor(pca_scores_d50$day)


# Step 9: Add metadata back into the PCA scores for plotting
# This allows for visualization of the PCA results with respect to sample characteristics.
pca_scores_d50$genotype <- d50_df_wide$genotype
pca_scores_d50$neuron   <- d50_df_wide$neuron
pca_scores_d50$day <- d50_df_wide$day

## 10. PLOTTING ##
# Determine the number of unique genotypes and neurons
n_genotypes <- length(unique(pca_scores_d50$genotype))
n_neurons <- length(unique(pca_scores_d50$neuron))
n_days <- length(unique(pca_scores_d50$day))

# Create color palettes
genotype_colors <- colorRampPalette(brewer.pal(11, "RdYlBu"))(n_genotypes)
neuron_colors <- c("#A50026", "#313695", "#FFFFBF") 
#neuron_colors <- colorRampPalette(brewer.pal(11, "RdYlBu"))(n_neurons)
day_colors <- colorRampPalette(brewer.pal(11, "RdYlBu"))(n_days)

## Plot Colored by Genotype: Generate the first PCA plot with points colored by genotype.
# PC1 and PC2 are plotted on the x and y axes, respectively.
d50plot1 <- ggplot(pca_scores_d50, aes(x = PC1, y = PC2, color = genotype)) +
  geom_point(size = 3, alpha = 0.8) +
  geom_text_repel(
                  data = pca_scores_d50 %>% distinct(genotype, .keep_all = TRUE),
                  aes(label=genotype),
                  size = 2,                # Adjust text size as needed
                  box.padding = 0.5,       # Padding around labels
                  point.padding = 0.5,     # Padding around data points
                  max.overlaps = 200) +    # Ensure all labels are displayed
  scale_color_manual(values = genotype_colors) +
  labs(
    title = "PCA of Gene Intensities Colored by Genotype",
    x = paste0("PC1 (", round(summary(pca_res_d50)$importance[2, 1] * 100, 1), "% variance)"),
    y = paste0("PC2 (", round(summary(pca_res_d50)$importance[2, 2] * 100, 1), "% variance)")
  ) +
  coord_fixed(ratio = 1.75) +
  theme_minimal() +
     theme(
    panel.border = element_rect(color = "black", fill = NA, linewidth = 1)
  )


## Plot Colored by Neuron: Generate the second PCA plot with points colored by neuron.
d50plot2 <- ggplot(pca_scores_d50, aes(x = PC1, y = PC2, color = neuron)) +
  geom_point(size = 3, alpha = 0.8) +
  stat_ellipse(aes(fill = neuron), geom = "polygon", alpha = 0.2, level = 0.95) + # 95% confidence ellipses
  scale_color_manual(values = neuron_colors) +
  scale_fill_manual(values = neuron_colors) +
  labs(
    title = "PCA of Gene Intensities Colored by Neuron Type",
    x = paste0("PC1 (", round(summary(pca_res_d50)$importance[2, 1] * 100, 1), "% variance)"),
    y = paste0("PC2 (", round(summary(pca_res_d50)$importance[2, 2] * 100, 1), "% variance)")
  ) +
  coord_fixed(ratio = 1) +
  theme_minimal() +
   theme(
    panel.border = element_rect(color = "black", fill = NA, linewidth = 1)
  )


## Plot Colored by day: Generate the second PCA plot with points colored by day of differentiation
d50plot3 <- ggplot(pca_scores_d50, aes(x = PC1, y = PC2, color = factor(day))) +
  geom_point(size = 3, alpha = 0.8) +
  stat_ellipse(aes(fill = factor(day)), geom = "polygon", alpha = 0.2, level = 0.95) +
  scale_color_manual(values = day_colors) +
  scale_fill_manual(values = day_colors) +
  labs(
    title = "PCA of Gene Intensities Colored by Day of Differentiation",
    x = paste0("PC1 (", round(summary(pca_res_d50)$importance[2, 1] * 100, 1), "% variance)"),
    y = paste0("PC2 (", round(summary(pca_res_d50)$importance[2, 2] * 100, 1), "% variance)")
  ) +
  coord_fixed(ratio = 1) +
  theme_minimal() +
  theme(panel.border = element_rect(color = "black", fill = NA, linewidth = 1))




# ----- Calculate PCA for excluding QC datasets ---- #
# since the PCA is skewed when the QCs are in there, have a 2nd run on the PCA calculation where QC datasets are removed.
# remove QC from "neuron" column in d50_df_wide df and then calculate the pca again 
# Step 5: Reshape the data from long to wide format
d50_df_wide <- cleaned_df %>%
  group_by(Genes, genotype, neuron, day, replicate) %>%  # keep day info
  summarise(across(quan, sum), .groups = "drop") %>%
  pivot_wider(
    names_from = Genes,
    values_from = quan,
    values_fill = list(quan = 0),
    values_fn = list(quan = sum)
  )

# Step 5b: Remove QC-labeled samples before PCA
d50_df_wide_noQC <- d50_df_wide %>%
  filter(neuron != "QC")

# Step 6b: Select only numeric columns for PCA
d50_numeric_data <- d50_df_wide_noQC %>%
  select(where(is.numeric))

# Step 7b: Perform PCA using memory-efficient method
pca_res_d50_noQC <- irlba::prcomp_irlba(d50_numeric_data, n = 10, scale. = TRUE)

# Step 8b: Extract PCA scores and attach metadata
pca_scores_d50_noQC <- as.data.frame(pca_res_d50_noQC$x)  # not pca_res_d50
pca_scores_d50_noQC$genotype <- d50_df_wide_noQC$genotype
pca_scores_d50_noQC$neuron   <- d50_df_wide_noQC$neuron
pca_scores_d50_noQC$day      <- factor(d50_df_wide_noQC$day)

# 10b plotting
# Determine the number of unique genotypes and neurons
n_genotypes_noQC <- length(unique(pca_scores_d50_noQC$genotype))
n_neurons_noQC <- length(unique(pca_scores_d50_noQC$neuron))
n_days_noQC <- length(unique(pca_scores_d50_noQC$day))

# Create color palettes
genotype_colors_noQC <- colorRampPalette(brewer.pal(11, "RdYlBu"))(n_genotypes_noQC)
neuron_colors_noQC <- c("#A50026", "#313695", "#FFFFBF") 
#neuron_colors <- colorRampPalette(brewer.pal(11, "RdYlBu"))(n_neurons)
day_colors_noQC <- colorRampPalette(brewer.pal(11, "RdYlBu"))(n_days_noQC)

d50plot1_noQC <- ggplot(pca_scores_d50_noQC, aes(x = PC1, y = PC2, color = genotype, alpha = day)) +
  geom_point(size = 3) +
  scale_alpha_manual(values = c("30" = 0.5, "50" = 1)) + # adjust as needed 
  geom_text_repel(
                  data = pca_scores_d50_noQC %>% distinct(genotype, .keep_all = TRUE),
                  aes(label=genotype),
                  color = "black",  
                  size = 6,                # Adjust text size as needed
                  box.padding = 0.5,       # Padding around labels
                  point.padding = 0.5,     # Padding around data points
                  max.overlaps = 1000) +    # Ensure all labels are displayed
  scale_color_manual(values = genotype_colors_noQC) +
  labs(
    title = "PCA of Gene Intensities Colored by Genotype",
    x = paste0("PC1 (", round(summary(pca_res_d50_noQC)$importance[2, 1] * 100, 1), "% variance)"),
    y = paste0("PC2 (", round(summary(pca_res_d50_noQC)$importance[2, 2] * 100, 1), "% variance)")
  ) +
  coord_fixed(ratio = 0.5) +
  theme_minimal() +
     theme(
    panel.border = element_rect(color = "black", fill = NA, linewidth = 1),
    legend.position = "bottom"
  )

#d50plot1_noQC


## Plot Colored by Neuron: Generate the second PCA plot with points colored by neuron.
d50plot2_noQC <- ggplot(pca_scores_d50_noQC, aes(x = PC1, y = PC2, color = neuron)) +
  geom_point(size = 3, alpha = 0.8) +
  stat_ellipse(aes(fill = neuron), geom = "polygon", alpha = 0.2, level = 0.998) + # 99.8% confidence ellipses
  scale_color_manual(values = neuron_colors_noQC) +
  scale_fill_manual(values = neuron_colors_noQC) +
  labs(
    title = "PCA of Gene Intensities Colored by Neuron Type",
    x = paste0("PC1 (", round(summary(pca_res_d50_noQC)$importance[2, 1] * 100, 1), "% variance)"),
    y = paste0("PC2 (", round(summary(pca_res_d50_noQC)$importance[2, 2] * 100, 1), "% variance)")
  ) +
  coord_fixed(ratio = 0.5) +
  theme_minimal() +
   theme(
    panel.border = element_rect(color = "black", fill = NA, linewidth = 1)
  )


## Plot Colored by day: Generate the second PCA plot with points colored by day of differentiation
d50plot3_noQC <- ggplot(pca_scores_d50_noQC, aes(x = PC1, y = PC2, color = factor(day))) +
  geom_point(size = 3, alpha = 0.8) +
  stat_ellipse(aes(fill = factor(day)), geom = "polygon", alpha = 0.2, level = 0.95) +
  scale_color_manual(values = day_colors_noQC) +
  scale_fill_manual(values = day_colors_noQC) +
  labs(
    title = "PCA of Gene Intensities Colored by Day of Differentiation",
    x = paste0("PC1 (", round(summary(pca_res_d50_noQC)$importance[2, 1] * 100, 1), "% variance)"),
    y = paste0("PC2 (", round(summary(pca_res_d50_noQC)$importance[2, 2] * 100, 1), "% variance)")
  ) +
  coord_fixed(ratio = 1) +
  theme_minimal() +
  theme(panel.border = element_rect(color = "black", fill = NA, linewidth = 1))



# ----- call all plots ---- #
d50plot1
d50plot2
d50plot3
d50plot1_noQC
d50plot2_noQC
d50plot3_noQC


# ----- Save plots as PDFs in homedir of the project ---- #
ggsave("/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/QC/diff132_d50_PCA_byGenotype.pdf", d50plot1,width =15, height = 15, units = "cm", dpi=600)
ggsave("/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/QC/diff132_d50_PCA_byCelltype.pdf", d50plot2, width =15, height = 15, units = "cm", dpi=600)
ggsave("/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/QC/diff132_d50_PCA_byDay.pdf", d50plot3, width =15, height = 15, units = "cm", dpi=600)

ggsave("/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/QC/diff132_d50_noQC_PCA_byGenotype.pdf", d50plot1_noQC,width =15, height = 15, units = "cm", dpi=600)
ggsave("/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/QC/diff132_d50_noQC_PCA_byCelltype.pdf", d50plot2_noQC, width =15, height = 15, units = "cm", dpi=600)
ggsave("/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/QC/diff132_d50_noQC_PCA_byDay.pdf", d50plot3_noQC, width =15, height = 15, units = "cm", dpi=600)



# save pivoted df (d50_wide) on home dir
#write.csv(d50_df_wide, "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/QC/d50_wide.csv", row.names = FALSE)
```



### IIIb. QC plots for supplements
``` {r}
### ---------- QC plots for supplements ### ---------- ###
## Average number of ProteinIDs per type on neuron
gene_counts_neuron <- cleaned_df %>%
  group_by(neuron) %>%
  summarise(quantified_genes = n_distinct(Genes), .groups = "drop")

neuronquant <- ggplot(gene_counts_neuron, aes(x = neuron, y = quantified_genes, fill = neuron)) +
  geom_bar(stat = "identity", width = 0.6) +
  scale_fill_manual(values = c("iN" = "grey60", "iDA" = "grey80", "QC" = "grey30")) +
  labs(
    title = "Total Number of Quantified ProteinIDs per Neuron Type",
    y = "ProteinIDs", x = "Neuron"
  ) +
  theme_bw() +
  theme(
    legend.position = "none",
    panel.grid = element_blank()
  )

neuronquant

# ---- plot  protein IDs vs  per genotype / neuron type ----
genotype_colors_noQC_2 <- colorRampPalette(brewer.pal(11, "RdYlBu"))(2*n_genotypes_noQC)

gene_seq_data <- diff132_d50_PCA_df %>%
  mutate(
    genotype = ifelse(is.na(genotype) & neuron == "QC", "QC", genotype),
    replicate = ifelse(genotype == "QC", NA, replicate)
  ) %>%
  filter(genotype != "QC") %>%  # <-- this line removes QC
  group_by(Genes, genotype, neuron) %>%
  summarise(
    total_sequences = sum(N.Sequences, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(group = interaction(genotype, neuron))


peptide_ID_QC <- ggplot(gene_seq_data, aes(x = Genes, y = log2(total_sequences), color = group)) +
  geom_point(alpha = 0.7) +
  scale_color_manual(values = genotype_colors_noQC_2) +
  labs(
    title = "Number N.Sequences vs IDs by Genotype × Neuron",
    x = "Genes",
    y = "Log2 Total N.Sequences"
  ) +
  theme_bw() +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_text(angle = 0, hjust = 1),
    panel.grid = element_blank(),
    legend.position = "bottom"
  )


### ---- plot average protein IDs per genotype / neuron type ---- 
# First, compute quantified genes per replicate (if replicate column exists)
# calculate the average for all QC IDs
gene_counts_per_rep <- cleaned_df %>%
  mutate(genotype = ifelse(is.na(genotype) & neuron == "QC", "QC", genotype),
    replicate = ifelse(genotype == "QC", NA, replicate)) %>%
  group_by(genotype, neuron, replicate) %>%
  summarise(quantified_genes = n_distinct(Genes), .groups = "drop")

# Separate QC and non-QC
qc_summary <- gene_counts_per_rep %>%
  filter(genotype == "QC") %>%
  group_by(genotype, neuron) %>%
  summarise(quantified_genes = sum(quantified_genes), .groups = "drop")

non_qc_summary <- gene_counts_per_rep %>%
  filter(genotype != "QC") %>%
  group_by(genotype, neuron) %>%
  summarise(quantified_genes = mean(quantified_genes), .groups = "drop")

# Combine
gene_counts_summary <- bind_rows(qc_summary, non_qc_summary)

# Then, calculate mean and SD across replicates per genotype × neuron group
gene_counts_genotype <- gene_counts_summary %>%
  group_by(genotype, neuron) %>%
  summarise(
    total_genes = sum(quantified_genes),
    sd_genes = ifelse(n() == 1, 0, sd(quantified_genes)),
    .groups = "drop"
    ) %>% 
  mutate(group = interaction(genotype, neuron))

# add "QC" in neuron column for color matching
gene_counts_genotype <- gene_counts_genotype %>%
  mutate(genotype = replace_na(genotype, "QC"))

# Plot with SD error bars
ProteinID_genotype_neurontype <- ggplot(gene_counts_genotype, aes(x = group, y = total_genes, fill = neuron)) +
  geom_bar(stat = "identity", width = 0.6) +
  geom_errorbar(aes(ymin = total_genes - sd_genes, ymax = total_genes + sd_genes), width = 0.2) +
  scale_fill_manual(values = c("iN" = "grey60", "iDA" = "grey80", "QC" = "grey30")) +
  labs(
    title = "Number of Quantified Genes per Genotype and Neuron Type",
    y = "Number of ProteinIDs", x = "Genotype × Neuron"
  ) +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1),
    panel.grid = element_blank()
  )

ProteinID_genotype_neurontype

## Save QC plots as PDFs in homedir of the project
ggsave("/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/QC/diff132_d50_QC_neuronquant.pdf", neuronquant,width =15, height = 15, units = "cm", dpi=600)
ggsave("/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/QC/diff132_d50_QC_ProteinID_genotype_neurontypee.pdf", ProteinID_genotype_neurontype, width =25, height = 10, units = "cm", dpi=600)



# ------------ Combine Plots ----------- #
library(cowplot)
library(patchwork)

# save three main plots for QC under each other 
# Force consistent theme and remove legends
p1 <- d50plot2 + theme(legend.position = "bottom")
p2 <- d50plot3 + theme(legend.position = "bottom")
p3 <- ProteinID_genotype_neurontype + theme(legend.position = "none")
p4 <- peptide_ID_QC + theme(legend.position = "none")

# Combine layout: (p1 | p2) / p3
combined_plot_QC <- ((p1 | p2) / p3 / p4) +
  plot_layout(heights = c(1, 1,0.5)) & 
  theme(plot.margin = margin(0.01, 10, 0.01, 10)) # Top, Right, Bottom, Left padding


# save three main plots for QC under each other 
# Force consistent theme and remove legends
p5 <- d50plot2_noQC + theme(legend.position = "bottom")
p6 <- d50plot3_noQC + theme(legend.position = "bottom")
p7 <- d50plot1_noQC + theme(legend.position = "bottom")

# Combine layout: (p5 | p6) / p7
combined_plot <- ((p5 | p6) / p7) +
  plot_layout(heights = c(1, 1)) & 
  theme(plot.margin = margin(0.01, 10, 0.01, 10)) # Top, Right, Bottom, Left padding



# View or save
combined_plot
combined_plot_QC

# Save as PDF
ggsave("/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/QC/diff132_d50_QC_combined_plot.pdf", combined_plot_QC, width = 12, height = 12, device = cairo_pdf)
ggsave("/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/QC/diff132_d50_combined_plot.pdf", combined_plot, width = 12, height = 12, device = cairo_pdf)
```



### IIIc. day50 full dataset for heatmaps
use the full dataset for plottng volcano and heatmaps etc 
each measured protein has mean ctrl, mean ko and fold-change and p/q value associated with it
probably makes sense to have it in tibble for easy data manipulation 
```{r}
### iN/iDA: Day 50 Proteomics Heatmap Pipeline ###
# Load necessary libraries
library(tidyverse)    # For data manipulation
library(pheatmap)     # For heatmap generation
library(RColorBrewer) # For color palettes

## 1. Load and Inspect Data
# Define the path to the input CSV file
input_LSD_file <- "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/datasets/lsd_fc_pv.csv"

# Read the CSV file into a data frame
diff132_d50_df <- read.csv(input_LSD_file, header = TRUE, sep = ",", stringsAsFactors = FALSE)

# Inspect the structure of the data
str(diff132_d50_df)


## 2. Data Cleaning
# Remove unnecessary columns: Protein.Group (1), Protein.Name (2), First.Protein.Description (4)
diff132_d50_df <- diff132_d50_df[, -c(1, 2, 4,14,15,16,17,18,19,21)]

# Filter out rows with missing or empty 'Genes' entries
clean_d50_df <- diff132_d50_df %>%
  filter(!is.na(Genes) & Genes != "")


##  3. Prepare Data for Heatmap
# Create a unique identifier for each sample by combining genotype and neuron
clean_d50_df<- clean_d50_df %>%
  mutate(sample_id = paste(genotype, neuron, sep = "_"))

# Pivot the data to have genes as rows and samples as columns
heatmap_d50_data <- clean_d50_df %>%
  select(Genes, sample_id, fold_change) %>%
  pivot_wider(
    names_from = sample_id,
    values_from = fold_change,
    values_fill = list(fold_change = 0),
    values_fn = list(fold_change = sum)
  )

# Convert the data frame to a matrix and set row names to gene names
rownames_df <- heatmap_d50_data$Genes  # Extract rownames before dropping the column
heatmap_matrix_d50 <- as.matrix(heatmap_d50_data[, -1])
rownames(heatmap_matrix_d50) <- rownames_df
heatmap_matrix_d50[is.na(heatmap_matrix_d50)] <- 0

# Remove rows/columns with zero variance
heatmap_matrix_d50 <- heatmap_matrix_d50[apply(heatmap_matrix_d50, 1, var) != 0, ]
heatmap_matrix_d50 <- heatmap_matrix_d50[, apply(heatmap_matrix_d50, 2, var) != 0]

## 4.Create Annotations for Heatmap
# Extract sample information for annotations
sample_d50_info <- clean_d50_df %>%
  select(sample_id, genotype, neuron) %>%
  distinct() %>%
  column_to_rownames("sample_id")


df_day30 <- clean_d50_df %>% filter(day == 30)
df_day50 <- clean_d50_df %>% filter(day == 50)

## Define a function to generate heatmaps
generate_heatmap <- function(df, day_label) {
  heatmap_data <- df %>%
    mutate(sample_id = paste(genotype, neuron, sep = "_")) %>%
    select(Genes, sample_id, fold_change) %>%
    pivot_wider(
      names_from = sample_id,
      values_from = fold_change,
      values_fill = list(fold_change = 0),
      values_fn = list(fold_change = sum)
    )

  # Extract matrix and rownames
  rownames_mat <- heatmap_data$Genes
  mat <- as.matrix(heatmap_data[, -1])
  rownames(mat) <- rownames_mat
  storage.mode(mat) <- "numeric"
  mat[!is.finite(mat)] <- 0
  mat <- mat[apply(mat, 1, var) != 0, , drop = FALSE]
  mat <- mat[, apply(mat, 2, var) != 0, drop = FALSE]

  # Annotations
  sample_info <- df %>%
    mutate(sample_id = paste(genotype, neuron, sep = "_")) %>%
    select(sample_id, genotype, neuron) %>%
    distinct() %>%
    column_to_rownames("sample_id")

  annotation_col <- data.frame(
    Genotype = sample_info$genotype,
    Neuron = sample_info$neuron
  )
  rownames(annotation_col) <- rownames(sample_info)

  genotypes <- unique(sample_info$genotype)
  neurons <- unique(sample_info$neuron)

  ann_colors <- list(
    Genotype = setNames(colorRampPalette(brewer.pal(9, "Set1"))(length(genotypes)), genotypes),
    Neuron = setNames(colorRampPalette(c("grey30", "grey60", "grey80"))(length(neurons)), neurons)
  )

  pheatmap(
    mat = mat,
    scale = "row",
    color = colorRampPalette(rev(brewer.pal(n = 11, name = "RdYlBu")))(100),
    annotation_col = annotation_col,
    annotation_colors = ann_colors,
    breaks = seq(-4, 4, length.out = 101),
    cluster_rows = TRUE,
    cluster_cols = TRUE,
    show_rownames = FALSE,
    show_colnames = TRUE,
    angle_col = "90",
    main = paste("Day", day_label, "iN / iDA Data"),
    fontsize = 10,
    border_color = NA
  )
}


heatmap_d30 <- generate_heatmap(df_day30, 30)
heatmap_d50 <- generate_heatmap(df_day50, 50)

# ------------ Combine Plots & save as PDF ----------- #
# have to use gridExtra, since do not use ggplot objects, but pheatmap() returns a grid object, not a ggplot. To arrange multiple pheatmap() plots, use gridExtra::grid.arrange() instead:
library(gridExtra)

# save three main plots for QC under each other 
combined_heatmap <- gridExtra::grid.arrange(
  heatmap_d30$gtable,
  heatmap_d50$gtable,
  ncol = 2,
  widths = c(1, 3)  # 1 part for d30, 3 parts for d50 = 25%/75%
)


# Define the output file path
output_file_50 <- "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/diff132_d30_d50_combined_heatmap.pdf"

# Save the heatmap to a PDF file
pdf(output_file_50, width = 40 / 2.54, height = 30 / 2.54)
gridExtra::grid.arrange(
  heatmap_d30$gtable,
  heatmap_d50$gtable,
  ncol = 2,
  widths = c(1, 3)  # Adjust for 25% / 75% layout
)
dev.off()

```


# IV. Day 30 & Day 50 in-depth evaluation
#### IVa. -- Subcell annotation to df for QC and Organelle Violin Plots 
add subcell annotation to df and save
sub sub-matrix for d30 and d50
export heatmap as csv file
add all colums of interest: FC, mean intensity, q-value
```{r}
# ------- add annotations do df and split by day and save as .csv files  -------- #
library(dplyr)
# Step 0: Define contaminant list
contaminant_genes <- c(
  "KRT8", "KRT19", "KRT9", "KRT10", "KRT2", "KRT18", "KRT1", "KRT5",
  "COL10A1", "COL13A1", "COL14A1", "COL18A1", "COL1A1", "COL1A2",
  "COL26A1", "COL2A1", "COL4A1", "COL4A2", "COL5A1", "COL6A1", "COL6A2"
  )

# Step 1: Transform columns
clean_d50_transformed_df <- clean_d50_df %>%
  mutate(
    log2_fold_change = ifelse(fold_change > 0, log2(fold_change), NA),
    neg_log10_q_value = ifelse(q_value > 0, -log10(q_value), NA),
    neg_log10_p_value = ifelse(p_value > 0, -log10(p_value), NA)
  ) %>%
  filter(!Genes %in% contaminant_genes)

# Step 2: Load and prepare annotation matrix (only once)
cols_to_read <- c(1,2,3,4,5,6,7,9,10,12,15,16,17,18,19,20,21,22,23,25,26,27,28)
subcell_df <- read.csv("/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day30/SubCellAnnotation.csv", stringsAsFactors = FALSE)[, cols_to_read]
subcell_df[] <- lapply(subcell_df, as.character)

long_subcell_df <- subcell_df %>%
  pivot_longer(
    cols = everything(),
    names_to = "Localization",
    values_to = "Genes"
  ) %>%
  filter(!is.na(Genes) & Genes != "") %>%
  mutate(Genes = trimws(Genes)) %>%
  distinct()

binary_matrix <- long_subcell_df %>%
  mutate(value = TRUE) %>%
  pivot_wider(
    names_from = Localization,
    values_from = value,
    values_fill = list(value = FALSE)
  )

# Step 3: Function to process each day independently
process_day_data <- function(df, day_value, save_path) {
  df_day <- df %>% filter(day == day_value)

  complete_data <- df_day %>%
    select(Genes, sample_id, log2_fold_change, mean_ctrl, mean_ko, neg_log10_q_value, neg_log10_p_value) %>%
    pivot_wider(
      names_from = sample_id,
      values_from = c(log2_fold_change, mean_ctrl, mean_ko, neg_log10_q_value, neg_log10_p_value),
      names_glue = "{sample_id}_{.value}",
      values_fill = list(
        log2_fold_change = 0, mean_ctrl = 0, mean_ko = 0,
        neg_log10_q_value = 0, neg_log10_p_value = 0
      ),
      values_fn = list(
        log2_fold_change = sum, mean_ctrl = mean, mean_ko = mean,
        neg_log10_q_value = mean, neg_log10_p_value = mean
      )
    )

  complete_data_annotated <- complete_data %>%
    left_join(binary_matrix, by = "Genes")
  complete_data_annotated[is.na(complete_data_annotated)] <- 0

  # Save to CSV
  write.csv(complete_data_annotated, save_path, row.names = FALSE)

  return(complete_data_annotated)
}

# Step 4: Run for Day 30 and Day 50
complete_data_annotated_day30 <- process_day_data(
  clean_d50_transformed_df, 30,
  "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day30/diff132_complete_annotated_day30.csv"
)

complete_data_annotated_day50 <- process_day_data(
  clean_d50_transformed_df, 50,
  "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/diff132_complete_annotated_day50.csv"
)
```

#### IVb. -- LSD KO protein abundnace across genotypes --
plan is to plot a heatmap of all LSD proteins of interest across the dataset -> check that these are KOs
```{r}
# Load required libraries
library(dplyr)
library(ggplot2)
library(stringr)
library(tidyr)

# ---- Define LSD Gene List ----
LSDgenes <- c("ASAH1", "PPT1", "CTSD", "GRN", "ATP13A2", "CTSF", "TPP1", "CLN3", 
              "DNAJC5", "CLN5", "CLN6", "MFSD8", "CLN8", "CTNS", "GAA", "GALNS", 
              "GBA1", "GLB1", "HEXA", "HEXB", "LIPA", "MCOLN1", "NPC1", "NPC2", 
              "PSAP", "SMPD1")

# ---- Prepare Long Format Data ----
# Filter for LSD genes and pivot to long format
df_clean_heatmap <- clean_d50_transformed_df %>%
  filter(Genes %in% LSDgenes) %>%
  select(Genes, genotype, neuron, day, mean_ctrl, mean_ko) %>%
  pivot_longer(cols = c(mean_ctrl, mean_ko), names_to = "condition", values_to = "value") %>%
  mutate(day = as.integer(day))

# ---- Filter for Matching Gene-Genotype Combinations at Day 50 ----
# Only keep rows where the gene matches the genotype (e.g., GBA1 expression in GBA1 KO)
plot_df <- df_clean_heatmap %>%
  filter(Genes == genotype, day == 50)

# ---- Replace NAs with 0 ----
plot_df <- plot_df %>%
  mutate(value = ifelse(is.na(value), 0, value))

# ---- Create DataFrame for Annotating Undetected Proteins ----
label_df <- plot_df %>%
  group_by(Genes) %>%
  mutate(max_y = max(value, na.rm = TRUE)) %>%
  filter(condition == "mean_ko" & value == 0) %>%
  mutate(
    label = "not detected",
    y_label = max_y * 0.5,                          # Position label at 50% of max height
    x_shift = as.numeric(factor(neuron)) + 0.2      # Shift x position slightly for clarity
  )

# ---- Plot Bar Plot with Facets per Gene ----
LSDgene_Abundance <- ggplot(plot_df, aes(x = neuron, y = value, fill = condition)) +
  geom_bar(stat = "summary", fun = mean, position = position_dodge(width = 0.6), width = 0.6) +
  geom_text(                                         # Add labels for undetected mean_ko
    data = label_df,
    aes(x = x_shift, y = y_label, label = label),
    inherit.aes = FALSE,
    angle = 90,
    size = 3,
    color = "red"
  ) +
  facet_wrap(~Genes, scales = "free_y") +
  scale_fill_manual(values = c("mean_ctrl" = "grey70", "mean_ko" = "steelblue")) +
  scale_color_manual(values = c("mean_ctrl" = "grey40", "mean_ko" = "steelblue4")) +
  labs(
    title = "LSD Protein Abundance (ctrl vs KO)",
    x = "Neuron Type",
    y = "Abundance (raw)",
    fill = "Condition"
  ) +
  theme_bw() +
  theme(
    legend.position = "bottom",
    panel.grid = element_blank()
  )

# ---- Display Plot ----
LSDgene_Abundance

# ---- Save Plot and Data ----
ggsave(
  "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/diff132_LSDgene_Abundance.pdf",
  LSDgene_Abundance,
  width = 12, height = 12, device = cairo_pdf
)

write.csv(
  df_clean_heatmap,
  "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/LSD_sorted.csv",
  row.names = FALSE
)
```




#### IVc. -- neuro QC plots ---- 
```{r}
# ---- neuro QC plots ---- #
# plot pre / post synaaptic markers of ctrl iN vs iDA. maybe plot 
# add annotation to cleaned_df (from PCA calculation, since has raw intensities for each gene in it)
PCAclean_d50_transformed_df <- cleaned_df %>%
  filter(!Genes %in% contaminant_genes)

# Join localization annotations into the filtered df
PCAclean_d50_annotated <- PCAclean_d50_transformed_df %>%
  left_join(binary_matrix, by = "Genes")

# Fill NAs with FALSE for localization columns
PCAclean_d50_annotated[is.na(PCAclean_d50_annotated)] <- FALSE


# function for plotting proteins of Interest 
plot_multiple_genes <- function(genes, data = PCAclean_d50_annotated) {
  gene_df <- data %>%
    filter(Genes %in% genes, genotype == "ctrl", neuron %in% c("iN", "iDA"), day == 50)

  ggplot(gene_df, aes(x = neuron, y = quan, fill = neuron)) +
    geom_bar(stat = "summary", fun = mean, position = position_dodge(width = 0.6), width = 0.5) +
    geom_jitter(aes(color = neuron), width = 0.15, size = 1.8, alpha = 0.6) +
    geom_errorbar(
      stat = "summary",
      fun.data = mean_se,
      width = 0.2,
      position = position_dodge(width = 0.6)
    ) +
    scale_fill_manual(values = c("iN" = "grey60", "iDA" = "grey80")) +
    scale_color_manual(values = c("iN" = "grey30", "iDA" = "grey10")) +
    facet_wrap(~Genes, scales = "free_y") +
    labs(
      title = "Expression of Selected Proteins in Ctrl Neurons day 50",
      x = "Neuron Type",
      y = "Quantified Intensity (quan)"
    ) +
  theme_bw() +
    theme(
    legend.position = "none",
    panel.grid = element_blank()
    )
}
Neuro_QC_Proteins <- plot_multiple_genes(c("TH", "SYP", "SYN1", "SNCA", "NEFH", "BSN", "SNX5", "VAMP2", "CPLX1"))
ggsave("/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/QC/diff132_d50_Neuro_QC_Proteins.pdf", Neuro_QC_Proteins, width = 12, height = 12, device = cairo_pdf)
```


#### IVd. -- Abundance of neuromarkers in Ctrl day 30 & day 50 ---- 
```{r}
# ------------ Abundance of neuromarkers in Ctrl day 30 & day 50 -------------- #
# Load required libraries
library(dplyr)
library(ggplot2)
library(tidyr)

# ---- Define Developmental Marker Gene List ----
dev_genes <- c("BDNF", "CAMK2B", "CRTC1", "DCX", "JUN", "MAP2", "NCAM1",
               "NEFH", "NEFL", "NEFM", "NES", "POU3F2", "SLC17A7", "SYN1",
               "SYP", "TUBB3", "TH", "BSN", "SYNJ1", "GAP43", "PSD95", "VGLUT",
               "SYN2", "SYN3", "NGN")

# ---- Prepare Data ----
dev_plot_df <- clean_d50_transformed_df %>%
  filter(Genes %in% dev_genes) %>%
  select(Genes, neuron, day, mean_ctrl) %>%
  mutate(day = as.factor(day))  # Ensure day is treated as categorical for plotting

# ---- Plot ----
Dev_Marker_Abundance <- ggplot(dev_plot_df, aes(x = neuron, y = mean_ctrl, fill = day)) +
  geom_bar(stat = "summary", fun = mean, position = position_dodge(width = 0.6), width = 0.6) +
  facet_wrap(~Genes, scales = "free_y") +
  scale_fill_manual(values = c("30" = "grey70", "50" = "steelblue")) +
  labs(
    title = "Neuronal Marker Abundance (Control, day 30 vs 50)",
    x = "Neuron Type",
    y = "Abundnace (mean_ctrl)",
    fill = "Day"
  ) +
  theme_bw() +
  theme(
    legend.position = "bottom",
    panel.grid = element_blank()
  )

# ---- Display ----
Dev_Marker_Abundance

# ---- Save ----
ggsave(
  "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/QC/diff132_NeuroMarkers_ctrl_d30_d50.pdf",
  Dev_Marker_Abundance,
  width = 12, height = 12, device = cairo_pdf
)
```


#### IVe. -- Abundance of Pre/Post Synaptic Markers in Ctrl day 30 & day 50 ---- 
``` {r}
# ------------ Abundance of Pre/Post Synaptic Markers in Ctrl day 30 & day 50 -------------- #
# ---- Define Developmental Marker Gene List ----
presyn_genes <- c("BSN", "CPLX1", "CPLX2", "ELKS1", "MUNC13A", "MUNC13B", "MUNC18", "NRXN1", 
                  "NRXN2", "NRXN3", "PCLO", "RAB3A", "RIM1", "RIM2", "RIMBP2", "SNAP25", "STX1A", 
                  "STX1B", "SV2A", "SV2B", "SV2C", "SYN1", "SYN2", "SYP", "SYT1", "SYT2", "SYT7", 
                  "VAMP1", "VAMP2", "VGLUT1", "VGLUT2", "VGLUT3"
)


postsyn_genes <- c(
"DLG4", "DLG3", "DLG2", "SHANK1", "SHANK2", "SHANK3", "HOMER1", "HOMER2", "HOMER3", "NLGN1", 
"NLGN2", "NLGN3", "NLGN4X", "GPHN", "SYNGAP1", "GRIN1", "GRIN2A", "GRIN2B", "GRIA1", "GRIA2", 
"GRIA3", "GRIA4", "GABRA1", "GABRA2", "GABRA3", "GABRA5", "GABRB1", "GABRB2", "GABRB3", "GABRG2", 
"CAMK2A", "CAMK2B", "PPP1R9B", "NRGN", "NPTX2"
)


# --- Define presynaptic and postsynaptic gene lists ---
presyn_df <- tibble::tibble(Genes = presyn_genes, marker_type = "Presynaptic")
postsyn_df <- tibble::tibble(Genes = postsyn_genes, marker_type = "Postsynaptic")
synapse_genes_df <- bind_rows(presyn_df, postsyn_df)

# --- Filter and transform data for control samples at Day 30/50 ---
synapse_long <- clean_d50_transformed_df %>%
  filter(Genes %in% synapse_genes_df$Genes) %>%
  select(Genes, neuron, day, mean_ctrl) %>%
  inner_join(synapse_genes_df, by = "Genes") %>%
  mutate(
    day = paste("Day", day),                  # Convert numeric to "Day X"
    log2_abundance = log2(mean_ctrl)          # Apply log2 transform
  )

# --- Summarize per gene and reshape to wide for change calculation ---
delta_df <- synapse_long %>%
  group_by(Genes, neuron, marker_type, day) %>%
  summarise(log2_abundance = mean(log2_abundance, na.rm = TRUE), .groups = "drop") %>%
  pivot_wider(names_from = day, values_from = log2_abundance) %>%
  filter(!is.na(`Day 30`) & !is.na(`Day 50`)) %>%
  mutate(direction = ifelse(`Day 50` > `Day 30`, "up", "down"))

# --- Reshape back to long format for plotting ---
long_with_direction <- delta_df %>%
  pivot_longer(cols = c(`Day 30`, `Day 50`), names_to = "day", values_to = "log2_abundance") %>%
  mutate(day = factor(day, levels = c("Day 30", "Day 50")))

# --- Plot function with per-gene trajectories and group average overlays ---
SynapseTrajectoryPlot <- function(df) {
  ggplot(df, aes(x = day, y = log2_abundance)) +
    # Individual gene lines by direction
    geom_line(aes(group = Genes, color = direction), alpha = 0.3, linewidth = 0.4) +
    
    # Overlay group mean lines
    stat_summary(
      aes(group = interaction(marker_type, neuron)),
      fun = mean, geom = "line",
      color = "grey40", linewidth = 2
    ) +
    stat_summary(
      aes(group = interaction(marker_type, neuron)),
      fun = mean, geom = "point",
      color = "grey30", size = 4
    ) +
    facet_grid(marker_type ~ neuron) +
    scale_color_manual(values = c("up" = "#e31a1c", "down" = "#1f78b4")) +
    theme_bw() +
    labs(
      title = "log2 Abundance Trajectories of \n Synaptic Genes (Control Neurons)",
      x = "Day", y = "log2(Abundance)",
      color = "Direction"
    ) +
    theme(
      panel.grid = element_blank(),
      legend.position = "bottom",
      )
}

# --- Generate and save plot ---
Synaptic_Marker_Abundance <- SynapseTrajectoryPlot(long_with_direction)
Synaptic_Marker_Abundance

ggsave(
  "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/QC/diff132_SynapticMarkers_ctrl_d30_d50.pdf",
  Synaptic_Marker_Abundance,
  width = 4, height = 8, device = cairo_pdf
)

```


#### IVf. -- NeuroDev protein trajectory for day 30 & day 50 for select genotypes ----
```{r}
# ------------ NeuroDev protein trajectory for day 30 & day 50 for select genotypes -------------- #
# For Ctrl, GRN, ASAH1, GBA1 and SMPD1 have both day30 and day50 data. plot neuronal markers etc and see if they increase.
# Define your gene sets
es_drivers <- c("ATF1", "CUX1", "MKI67", "NANOG", "POU5F1", "SOX2")
neuron_drivers <- c(
  "BDNF", "CAMK2B", "CRTC1", "DCX", "JUN", "MAP2", "NCAM1",
  "NEFH", "NEFL", "NEFM", "NES", "POU3F2", "SLC17A7", "SYN1",
  "SYP", "TUBB3", "TH", "BSN", "SYNJ1", "GAP43", "PSD95", "VGLUT",
  "SYN2", "SYN3", "NGN"
)
# Create marker label dataframe
marker_genes_df <- tibble(
  Genes = c(es_drivers, neuron_drivers),
  marker_type = c(rep("ES-driver", length(es_drivers)),
                  rep("Neuron-driver", length(neuron_drivers)))
)
# Step 1: Filter for NeuroDev == TRUE
d30_neurodev <- complete_data_annotated_day30 %>% filter(NeuroDev == TRUE)
d50_neurodev <- complete_data_annotated_day50 %>% filter(NeuroDev == TRUE)

# Step 2: Reshape to long format and add 'day'
pivot_neurodev <- function(df, day_label) {
  df %>%
    select(Genes, matches("_log2_fold_change$")) %>%
    pivot_longer(
      cols = -Genes,
      names_to = "sample",
      values_to = "log2FC"
    ) %>%
    mutate(
      day = day_label,
      sample = str_remove(sample, "_log2_fold_change$"),
      genotype = str_extract(sample, "^[^_]+"),
      neuron = str_extract(sample, "(?<=_)(iDA|iN)$")
    )
}

d30_long <- pivot_neurodev(d30_neurodev, "Day 30")
d50_long <- pivot_neurodev(d50_neurodev, "Day 50")

# Step 3: Combine
combined_df <- bind_rows(d30_long, d50_long)

# Join annotation info
combined_df_annotated <- combined_df %>%
  inner_join(marker_genes_df, by = "Genes")

# Now you can summarize or plot
summary_df <- combined_df_annotated %>%
  filter(genotype %in% c("ctrl", "ASAH1", "GBA1", "SMPD1", "GRN")) %>%
  group_by(marker_type, genotype, neuron, day) %>%
  summarise(mean_log2FC = mean(log2FC, na.rm = TRUE), .groups = "drop")


# Step 5: Plot
NeuoDevd30d50 <- ggplot(
  combined_df_annotated %>% filter(genotype %in% c("ctrl", "ASAH1", "GBA1", "SMPD1", "GRN")),
  aes(x = day, y = log2FC, group = interaction(Genes, neuron), marker_type = marker_type)
) +
  # Individual traces
  geom_line(aes(color = neuron), alpha = 0.2, linewidth = 0.5) +
  geom_point(aes(color = neuron), alpha = 0.4, size = 1) +

  # Mean lines
  stat_summary(
    aes(group = neuron, color = neuron),
    fun = mean, geom = "line", linewidth = 1.2
  ) +
  stat_summary(
    aes(group = neuron, fill = neuron),
    fun = mean, geom = "point", size = 2.5, color = "black", shape = 21
  ) +

  facet_grid(rows = vars(marker_type), cols = vars(genotype)) +
  scale_color_manual(values = c("iN" = "grey60", "iDA" = "grey80")) +
  scale_fill_manual(values = c("iN" = "grey60", "iDA" = "grey80")) +
  labs(
    title = "log2FC of NeuroDev Genes by Marker Type and Genotype",
    x = "Day", y = "log2 Fold Change"
  ) +
  theme_bw() +
  theme(
    strip.text = element_text(face = "bold"),
    panel.grid = element_blank()
  )

NeuoDevd30d50

ggsave(
  "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/QC/diff132_NeuoDevd30d50.pdf",
  NeuoDevd30d50,
  width = 8, height = 6, device = cairo_pdf)

```


#### IVg. -- Violin Plot Function for LSD Organelle Proteomics ----
``` {r}
# ------------ Violin Plot Function for LSD Organelle Proteomics -------------- #
# This function creates violin plots of log2 fold change values for proteins
# grouped by subcellular annotation, genotype, and neuron type.

plot_log2fc_violin <- function(data, annotations, genotypes) {

  # 1. Gather gene identifiers for each annotation
  annotation_genes <- map_dfr(annotations, function(ann) {
    data %>%
      filter(!!sym(ann)) %>%      # Select genes with the current annotation
      select(Genes) %>%
      mutate(annotation = ann)    # Label them with the annotation name
  })

  # 2. Join gene annotations back to the full dataset
  plot_df <- annotation_genes %>%
    left_join(data, by = "Genes")

  # 3. Generate column names for iDA and iN comparisons for selected genotypes
  fc_cols <- unlist(lapply(genotypes, function(g) {
    paste0(g, c("_iDA_log2_fold_change", "_iN_log2_fold_change"))
  }))

  # 4. Reshape data into long format for plotting
  plot_df_long <- plot_df %>%
    select(Genes, annotation, all_of(fc_cols)) %>%
    pivot_longer(
      cols = -c(Genes, annotation),
      names_to = "sample", values_to = "log2FC"
    ) %>%
    separate(sample, into = c("genotype", "neuron", NA), sep = "_")

  # 5. Trim y-axis: focus on core 75% of distribution
  full_range <- range(plot_df_long$log2FC, na.rm = TRUE)
  midpoint <- median(plot_df_long$log2FC, na.rm = TRUE)
  range_width <- diff(full_range)
  scaled_half_range <- 0.375 * range_width  # 75% total span
  lower_lim <- midpoint - scaled_half_range
  upper_lim <- midpoint + scaled_half_range

  # 6. Generate the violin plot
  ggplot(plot_df_long, aes(x = neuron, y = log2FC, fill = annotation)) +
    geom_jitter(color = "grey80", width = 0.1, size = 0.5, alpha = 0.5) +  # White dots for individual values
    geom_violin(scale = "width", trim = FALSE, color = NA, width = 0.85) +
    geom_boxplot(width = 0.2, fill = "white", outlier.shape = NA, color = "black", linewidth = 0.3) +
    geom_hline(yintercept = 0, linetype = "dashed", color = "black", linewidth = 0.3) +
    facet_grid(rows = vars(genotype), cols = vars(annotation), scales = "free_y") +
    scale_fill_brewer(palette = "Paired") +
    labs(
      title = "log2 Fold Change of Proteins by Annotation and Genotype",
      x = "Neuron Type", y = "log2 Fold Change"
    ) +
    coord_cartesian(ylim = c(lower_lim, upper_lim)) +
    theme_bw() +
    theme(
      strip.text = element_text(size = 6, face = "bold"),
      axis.text.x = element_text(angle = 0, hjust = 0.5),
      panel.grid = element_blank()
    )
}

# ------------ Run and Save Plot of select Genotypes ------------- #
LSD_d50_Violin_plot <- plot_log2fc_violin(
  data = complete_data_annotated_day50,
  #annotations = c("Mito","Mito.IMS","Mito.Matrix","Mito.MIM","Mito.MOM","OXPHOS","mtComplexI"),
  annotations = c("EndoLyso","Presynaptic","Postsynaptic", "SynGO","EarlyEndosome","RecyclingEndosome"),
  genotypes = c("ASAH1", "SMPD1", "GBA1")
)
LSD_d50_Violin_plot


# Annotations:
#"Mito","Mito.IMS","Mito.Matrix","Mito.MIM","Mito.MOM","OXPHOS","mtComplexI","Plasma Membrane","Golgi.Genes","Lysosome.Genes","ER.genes","	Endosome.Genes","EndoType","Cytoplasm","Nucleus","Autophagy","SynGO","Endo_iN_curated_Hundley","Presynaptic","Postsynaptic","EndoLyso" "EarlyEndosome","RecyclingEndosome")

#annotations = c("Mito","Mito.IMS","Mito.Matrix","Mito.MIM","Mito.MOM","OXPHOS","mtComplexI"),
#annotations = c("Mito","Golgi.Genes","Lysosome.Genes","ER.genes","Autophagy","Endo_iN_curated_Hundley","SynGO")
#annotations = c("EndoLyso","Presynaptic","Postsynaptic", "SynGO")

# Save as square-format PDF
ggsave(
  "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/Organelle_Violin/diff132_d50_LSD_Violin_plot_ASAH1-SMPD1-GBA1_detailedEndoLysoSynGO.pdf",
  LSD_d50_Violin_plot,
  width = 12, height = 9, device = cairo_pdf)
```



#### IVh. -- Sph mutant investigation ----
To achieve in this section:
make subset of only Sph mutant in day50 dataframe
plot heatmap w/ z-score norm of genotypes
run correlation matrix on EndoLyso, SynGo, endososme, lysosome, pre and post synaptic 
save the subset with annotation as csv file
save plots as pdfs 
use unique variables, so I can calculate the correlation between neurons and nMOST hela later down in the script

##### IVh1. --- Add annotations & heatmap & save csv ---
```{r}
library(dplyr)
library(tidyr)
library(pheatmap)
library(RColorBrewer)
library(tibble)
library(readr)
library(stringr)
library(readr)

# Directory for saving files
out_dir <- "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/SphMut"
dir.create(out_dir, showWarnings = FALSE, recursive = TRUE)

# Define SphMut sample IDs
SphMut_samples <- c("Ctrl_iN", "Ctrl_iDA", "GLB1_iN", "GLB1_iDA", "GBA1_iN", "GBA1_iDA", 
                    "ASAH1_iN", "ASAH1_iDA", "SMPD1_iN", "SMPD1_iDA", "PSAP_iN", "PSAP_iDA", 
                    "HEXA_iN", "HEXA_iDA", "HEXB_iN", "HEXB_iDA")

# Subset and pivot
SphMut_df <- clean_d50_transformed_df %>%
  filter(sample_id %in% SphMut_samples, day == 50)

SphMut_df <- SphMut_df %>%
  mutate(sample_id = paste0(sample_id, "_d", day))

SphMut_wide_df <- SphMut_df %>%
  select(Genes, sample_id, log2_fold_change, mean_ctrl, mean_ko, neg_log10_q_value, neg_log10_p_value) %>%
  pivot_wider(
    names_from = sample_id,
    values_from = c(log2_fold_change, mean_ctrl, mean_ko, neg_log10_q_value, neg_log10_p_value),
    names_glue = "{sample_id}_{.value}",
    values_fill = list(
      log2_fold_change = 0, mean_ctrl = 0, mean_ko = 0,
      neg_log10_q_value = 0, neg_log10_p_value = 0
    ),
    values_fn = list(
      log2_fold_change = sum,
      mean_ctrl = mean,
      mean_ko = mean,
      neg_log10_q_value = mean,
      neg_log10_p_value = mean
    )
  )

# Add annotations
SphMut_annotated_df <- SphMut_wide_df %>%
  left_join(binary_matrix, by = "Genes") %>%
  replace(is.na(.), 0)

# Save as CSV
write_csv(SphMut_annotated_df, file.path(out_dir, "SphMut_log2FC_day50_annotated.csv"))


log2fc_cols <- grep("_d50_log2_fold_change$", names(SphMut_annotated_df), value = TRUE)

SphMut_mat <- SphMut_annotated_df %>%
  select(all_of(log2fc_cols)) %>%
  as.matrix()
rownames(SphMut_mat) <- SphMut_annotated_df$Genes
SphMut_mat[!is.finite(SphMut_mat)] <- 0 

# Sample annotations
SphMut_sample_info <- tibble(sample_id = colnames(SphMut_mat)) %>%
  mutate(
    Genotype = str_extract(sample_id, "^[^_]+"),
    Neuron = str_extract(sample_id, "_i[DN]A") %>% str_remove("^_")
  ) %>%
  column_to_rownames("sample_id")

ann_colors <- list(
  Genotype = setNames(brewer.pal(length(unique(SphMut_sample_info$Genotype)), "Set3"),
                      unique(SphMut_sample_info$Genotype)),
  Neuron = c("iDA" = "grey80", "iN" = "grey40")
)

row_var <- apply(SphMut_mat, 1, var)
SphMut_mat_filtered <- SphMut_mat[row_var > 0, ]

# Heatmap with internal z-score
Sphmut_hm <- pheatmap(
  SphMut_mat_filtered,
  annotation_col = SphMut_sample_info,
  annotation_colors = ann_colors,
  color = rev(brewer.pal(11, "RdYlBu")),
  cluster_rows = TRUE,
  cluster_cols = TRUE,
  scale = "row",
  show_rownames = FALSE,
  show_colnames = TRUE,
  fontsize = 6,
  #cellheight = 5,
  #cellwidth  = 5,
  border_color = NA,
  na_col = "grey90",
  main = "SphMut Z-Score Log2FC (Day 50)"
)

pdf(file.path(out_dir, "SphMut_log2FC_heatmap.pdf"), width = 3, height = 10, useDingbats = FALSE)
print(Sphmut_hm)
dev.off()

```

##### IVh2. --- Correlation analysis on selected annotations --- 
```{r}
# --- Correlation analysis on selected annotations --- #
selected_annotations <- c("EndoLyso", "SynGO", "Endo_iN_curated_Hundley",
                          "Lysosome.Genes", "Presynaptic", "Postsynaptic","EarlyEndosome","RecyclingEndosome")

# selected_annotations <- c("Mito", "Mito.IMS",  "Mito.Matrix", "Mito.MIM","Mito.MOM", "OXPHOS", "mtComplexI", "Golgi.Genes", "Lysosome.Genes", "ER.genes","Cytoplasm", "Nucleus", "Autophagy", "SynGO", "Endo_iN_curated_Hundley","Presynaptic","Postsynaptic","NeuroDev", "EndoLyso", "EarlyEndosome","RecyclingEndosome")
   

log2fc_cols <- grep("log2_fold_change$", names(SphMut_annotated_df), value = TRUE)

SphMut_corr_df <- purrr::map_dfr(selected_annotations, function(ann) {
  x <- as.numeric(SphMut_annotated_df[[ann]])
  purrr::map_dfr(log2fc_cols, function(ko) {
    y <- SphMut_annotated_df[[ko]]
    keep <- !(is.na(x) | is.na(y))
    if (sum(keep) < 5) return(NULL)
    ct <- suppressWarnings(cor.test(x[keep], y[keep], method = "spearman"))
    tibble(KO = ko, Organelle = ann, r = unname(ct$estimate), p = ct$p.value)
  })
})

# Save correlation results
write_csv(SphMut_corr_df, file.path(out_dir, "SphMut_annotation_correlation.csv"))

# --- Plot correlation matrix --- #
SphMut_corr_mat <- SphMut_corr_df %>%
  select(KO, Organelle, r) %>%
  pivot_wider(names_from = Organelle, values_from = r) %>%
  column_to_rownames("KO") %>%
  as.matrix()
SphMut_corr_mat[!is.finite(SphMut_corr_mat)] <- 0

# KO annotation
SphMut_ko_type <- data.frame(CellType = ifelse(grepl("iDA", rownames(SphMut_corr_mat)), "iDA", "iN"))
rownames(SphMut_ko_type) <- rownames(SphMut_corr_mat)

# Final correlation heatmap
pdf(file.path(out_dir, "SphMut_annotation_corr_heatmap.pdf"), width = 10, height = 14, useDingbats = FALSE)
pheatmap(
  SphMut_corr_mat,
  color = rev(brewer.pal(11, "RdYlBu")),
  cluster_rows = TRUE,
  cluster_cols = TRUE,
  annotation_row = SphMut_ko_type,
  annotation_colors = list(CellType = c(iDA = "grey80", iN = "grey40")),
  border_color = NA,
  cellheight = 15,
  cellwidth  = 15,
  main = "SphMut Organelle Correlation"
)
dev.off()

```


##### IVh3. --- Correlation analysis on all organelles --- 
```{r}
## --- Cross-correlation matrix of Sph-genotypes for each organelle --- ##
library(gridExtra)
library(pheatmap)

# --- Setup ---
out_corr_dir <- file.path(out_dir, "Organelle_CrossCorr")
dir.create(out_corr_dir, showWarnings = FALSE, recursive = TRUE)

SphMut_sample_cols <- grep("log2_fold_change$", names(SphMut_annotated_df), value = TRUE)
SphMut_ko_type <- data.frame(CellType = ifelse(grepl("iDA", SphMut_sample_cols), "iDA", "iN"))
rownames(SphMut_ko_type) <- SphMut_sample_cols
celltype_colors <- c(iDA = "grey80", iN = "grey40")

# --- Function: Compute KO×KO correlation matrix for a given organelle ---
plot_sphmut_corr_matrix <- function(organelle_name, df = SphMut_annotated_df) {
  gene_filter <- df[[organelle_name]] == 1
  mat <- df[gene_filter, SphMut_sample_cols, drop = FALSE]
  if (nrow(mat) < 5) return(NULL)

  corr_mat <- cor(mat, use = "pairwise.complete.obs", method = "spearman")
  corr_mat[!is.finite(corr_mat)] <- 0

  pheatmap::pheatmap(
    corr_mat,
    main = organelle_name,
    color = rev(RColorBrewer::brewer.pal(11, "RdYlBu")),
    silent = TRUE,
    cellheight = 10,
    cellwidth = 10,
    na_col = "grey90",
    cluster_rows = TRUE,
    cluster_cols = TRUE,
    border_color = NA,
    fontsize = 6,
    annotation_row = SphMut_ko_type,
    annotation_colors = list(CellType = celltype_colors)
  )
}

# --- Run for all selected organelles ---
selected_annotations <- c("Mito", "Mito.IMS",  "Mito.Matrix", "Mito.MIM","Mito.MOM", "OXPHOS", "mtComplexI", "Golgi.Genes", "Lysosome.Genes", "ER.genes","Cytoplasm", "Nucleus", "Autophagy", "SynGO", "Endo_iN_curated_Hundley","Presynaptic","Postsynaptic","NeuroDev", "EndoLyso", "EarlyEndosome","RecyclingEndosome")
  


# selected_annotations <- c("EndoLyso", "SynGO", "Endo_iN_curated_Hundley",
#                           "Lysosome.Genes", "Presynaptic", "Postsynaptic")


SphMut_ko_corr_hms <- lapply(selected_annotations, plot_sphmut_corr_matrix)
SphMut_ko_corr_hms <- Filter(Negate(is.null), SphMut_ko_corr_hms)

# --- Save multi-panel heatmap PDF ---
pdf(file.path(out_corr_dir, "SphMut_KOxKO_Corr_Heatmaps.pdf"), width = 30, height = 30, useDingbats = FALSE)
gridExtra::grid.arrange(
  grobs = lapply(SphMut_ko_corr_hms, `[[`, "gtable"),
  ncol = 3
)
dev.off()

```


#### IVi. -- GRN d30/50 DA neuron investigation ----
we see that the DA neurons of GRN in both day 30 and day50 have differences in their proteome compared to the other genotypes or the iN of the same genotype
use complete_data_annotated_day30 & complete_data_annotated_day50 for evaluation, since has already mean and log2 intensities and annotations in the dataframe 

- make dataframe of only Ctrl, GRN, GBA1, ASAH1, SMPD1 for day30 and day 50; both iN and iDA
- add annotations to Genes in dataframe
- also calculate the log2FC but also keep the mean_ctrl and mean_ko values in the dataframe => calculate mean of that 

- plot mean_ctrl and mean_ko across the genotypes
- make heatmap containing both timepoints => gene.rows are matched
- plot corr of GRN/Ctrl day30 (x) and GRN/Ctrl day50 (y)
- plot outliers of this corr and see what is different? 
```{r}
# use modified function to loop through clean_50_transformed_df to get genotypes and days and annotations in new dataframe 
process_day_data_combined <- function(df, binary_matrix) {
  selected_samples <- c("Ctrl_iN", "Ctrl_iDA", "GRN_iN", "GRN_iDA", 
                        "GBA1_iN", "GBA1_iDA", "ASAH1_iN", "ASAH1_iDA", 
                        "SMPD1_iN", "SMPD1_iDA")
  
  # Filter to relevant samples only
  df_filtered <- df %>% filter(sample_id %in% selected_samples, day %in% c(30, 50))
  
  # Add time label to sample_id (to avoid collision after pivoting)
  df_filtered <- df_filtered %>%
    mutate(sample_id = paste0(sample_id, "_d", day))
  
  # Pivot to wide format
  complete_data <- df_filtered %>%
    select(Genes, sample_id, log2_fold_change, mean_ctrl, mean_ko, neg_log10_q_value, neg_log10_p_value) %>%
    pivot_wider(
      names_from = sample_id,
      values_from = c(log2_fold_change, mean_ctrl, mean_ko, neg_log10_q_value, neg_log10_p_value),
      names_glue = "{sample_id}_{.value}",
      values_fill = list(
        log2_fold_change = 0, mean_ctrl = 0, mean_ko = 0,
        neg_log10_q_value = 0, neg_log10_p_value = 0
      ),
      values_fn = list(
        log2_fold_change = sum,
        mean_ctrl = mean,
        mean_ko = mean,
        neg_log10_q_value = mean,
        neg_log10_p_value = mean
      )
    )
  
  # Add annotations
  complete_data_annotated <- complete_data %>%
    left_join(binary_matrix, by = "Genes") %>%
    replace(is.na(.), 0)
  
  return(complete_data_annotated)
}

day3050_subset <- process_day_data_combined(clean_d50_transformed_df, binary_matrix)
write.csv(day3050_subset, "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/diff132_day3050_subset.csv",row.names = FALSE)




# ---- heatmap of day30/50 dataset ---- #
# load libraries 
library(pheatmap)
library(RColorBrewer)

generate_day3050_heatmap <- function(df, title_label = "Combined Heatmap") {
  # Extract log2FC columns
  log2fc_cols <- grep("_log2_fold_change$", names(df), value = TRUE)
  mat <- as.matrix(df[, log2fc_cols])
  rownames(mat) <- df$Genes
  storage.mode(mat) <- "numeric"
  mat[!is.finite(mat)] <- 0

  # Remove invariant rows/columns
  mat <- mat[apply(mat, 1, var) != 0, , drop = FALSE]
  mat <- mat[, apply(mat, 2, var) != 0, drop = FALSE]

  # Sample annotation: extract genotype, neuron type, and day
  sample_info <- data.frame(
    sample_id = colnames(mat)
  ) %>%
    mutate(
      Genotype = str_extract(sample_id, "^[^_]+"),
      Neuron = str_extract(sample_id, "_iDA|_iN") %>% str_remove("^_"),
      Day = str_extract(sample_id, "_d\\d+") %>% str_remove("^_")
    ) %>%
    column_to_rownames("sample_id")

  # Annotation colors
  ann_colors <- list(
    Genotype = setNames(brewer.pal(length(unique(sample_info$Genotype)), "Set1"), unique(sample_info$Genotype)),
    Neuron = setNames(c("grey40", "grey70"), unique(sample_info$Neuron)),
    Day = setNames(c("#3182bd", "#9ecae1"), unique(sample_info$Day))
  )

  # Generate heatmap
  pheatmap(
    mat,
    scale = "row",
    color = colorRampPalette(rev(brewer.pal(n = 11, name = "RdYlBu")))(100),
    annotation_col = sample_info,
    annotation_colors = ann_colors,
    breaks = seq(-4, 4, length.out = 101),
    cluster_rows = TRUE,
    cluster_cols = TRUE,
    show_rownames = FALSE,
    show_colnames = TRUE,
    angle_col = 90,
    main = title_label,
    fontsize = 10,
    border_color = NA
  )
}
day3050_heatmap <- generate_day3050_heatmap(day3050_subset, title_label = "LSD DA Neuron Log2FC – Day30 & Day50")
day3050_heatmap

ggsave(
  "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/diff132_selectKO_day3050_heatmap.pdf",
  day3050_heatmap,
  width = 8, height = 10, device = cairo_pdf)



# ---- Correlation scatterplot of day30 / day 50 DA GRN neurons---- #
library(ggplot2)
library(ggpmisc)  # for stat_cor
library(ggpubr)


# -- color & facet~wrap by annotation of compartment 
# Create a copy to avoid modifying original
annot_subset <- day3050_subset

## --- STEP1: define protein sub cellular localizations --- 
# Step 1a: Identify annotation columns (logical columns at the end of the dataframe)
annotation_columns <- names(annot_subset)[sapply(annot_subset, is.logical)]

# Step 1b: Remove overly specific or problematic annotations
usable_annotations <- setdiff(annotation_columns, c("Autophagy..Detailed.", "EndoDetailed"))

# Step 1c: Reshape to long format: Gene - Localization pairs
annotation_long <- annot_subset %>%
  select(Genes, all_of(usable_annotations)) %>%
  pivot_longer(cols = -Genes, names_to = "Localization", values_to = "Present") %>%
  filter(Present) %>%
  select(-Present) %>%
  distinct()


## --- STEP2: define protein sub cellular localizations --- 
# Step 2a: Create full combination of genes and facet localizations
facet_levels <- unique(annotation_long$Localization)

# Step 2c: Expand gene-localization combinations
facet_expanded <- expand.grid(
  Genes = unique(annotation_long$Genes),
  FacetLocalization = facet_levels,
  stringsAsFactors = FALSE
)

## --- STEP3: differentiate between highlights / background for facet~wrap --- 
# Step 3a: Join annotation and expression data
plot_data <- facet_expanded %>%
  left_join(annotation_long, by = "Genes") %>%
  left_join(day3050_subset, by = "Genes") %>%
  mutate(point_color = ifelse(Localization == FacetLocalization, "dodgerblue", "grey80"))

# Step 3b: Separate highlight vs background
highlight_points <- plot_data %>% filter(point_color == "dodgerblue")
background_points <- plot_data %>% filter(point_color == "grey80")

## --- STEP4: plot scatterplot with different highlights, based on annoations ---
# Step 4a: Plot with background and highlight
day3050_GRN <- ggplot() +
  # Background points
  geom_point(data = background_points,
             aes(x = GRN_iDA_d30_log2_fold_change, y = GRN_iDA_d50_log2_fold_change),
             color = "grey80", size = 0.8, alpha = 0.7) +
  # Highlighted points
  geom_point(data = highlight_points,
             aes(x = GRN_iDA_d30_log2_fold_change, y = GRN_iDA_d50_log2_fold_change),
             color = "dodgerblue", size = 0.8, alpha = 0.9) +
  geom_hline(yintercept = 0, linetype = "dashed", linewidth = 0.3) +
  geom_vline(xintercept = 0, linetype = "dashed", linewidth = 0.3) +
  geom_smooth(data = plot_data,
              aes(x = GRN_iDA_d30_log2_fold_change, y = GRN_iDA_d50_log2_fold_change),
              method = "lm", se = FALSE, color = "black", linewidth = 0.3) +
  facet_wrap(~FacetLocalization) +
  theme_classic(base_size = 10) +
  labs(
    title = "GRN iDA: Day 30 vs Day 50 log2FC by Subcellular Localization",
    x = "Day 30 log2FC",
    y = "Day 50 log2FC"
  ) +
      xlim(-4,4) + ylim(-4,4)

day3050_GRN

ggsave(
  "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/diff132_day3050_GRN_DA_scattter.pdf",
  day3050_GRN,
  width = 8, height = 8, device = cairo_pdf)







# -- plot DA 30 vs 50, and highlight top 10 enriched proteins in both data frames
library(ggrepel)

# ---- STEP 1: Base data ----
plot_df <- day3050_subset %>%
  select(Genes, GRN_iDA_d30_log2_fold_change, GRN_iDA_d50_log2_fold_change)

# ---- STEP 2: Define enrichment ranking ----
# Rank by absolute log2FC sum across both timepoints
top10_genes <- plot_df %>%
  mutate(total_abs = abs(GRN_iDA_d30_log2_fold_change) + abs(GRN_iDA_d50_log2_fold_change)) %>%
  arrange(desc(total_abs)) %>%
  slice_head(n = 50) %>%
  pull(Genes)

# ---- STEP 3: Annotate color and label ----
plot_df <- plot_df %>%
  mutate(
    highlight = Genes %in% top10_genes,
    point_color = ifelse(highlight, "red", "grey76"),
    label = ifelse(highlight, Genes, NA)
  )

# ---- STEP 4: Plot ----
day3050_GRN_top <- ggplot(plot_df, aes(x = GRN_iDA_d30_log2_fold_change, y = GRN_iDA_d50_log2_fold_change)) +
  geom_point(aes(color = point_color), size = 1.2, alpha = 0.8, show.legend = FALSE) +
  geom_text_repel(aes(label = label), size = 2.5, max.overlaps = 100) +
  geom_smooth(method = "lm", se = FALSE, color = "black", linewidth = 0.3) +
  geom_hline(yintercept = 0, linetype = "dashed", linewidth = 0.3) +
  geom_vline(xintercept = 0, linetype = "dashed", linewidth = 0.3) +
  scale_color_identity() +
  xlim(-4, 4) + ylim(-4, 4) +
  theme_bw(base_size = 10) +
    theme(
      panel.grid = element_blank()
    ) +
    labs(
    title = "Top Enriched Proteins: GRN iDA Day30 vs Day50",
    x = "log2FC Day 30",
    y = "log2FC Day 50"
  )

day3050_GRN_top

ggsave(
  "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/diff132_day3050_GRN_DA_topHits.pdf",
  day3050_GRN_top,
  width = 8, height = 8, device = cairo_pdf)

```






# V. Organelle Cross-DF correlations
have now complete_data_annotated_day50, which contains all the organelle annotations across all genotypes
easiest way now is to calculate the correlations of log2fc across all organelles across all genotypes
maybe get a heatmap for each organelle? Strategy is to get a function that asks for the organelle / annotation to correlate across the whole set of genotypes. 


#### Va. --- User-Select Organelle-annotation correlation  
```{r}
# Load required libraries
library(dplyr)
library(stringr)
library(pheatmap)
library(RColorBrewer)
library(dplyr)
library(stringr)


# ---------------- Generate  log2FC_d50_annotated dataframe --------------- #
# Step 1: Extract log2FC columns (columns 1–47)
log2fc_d50 <- complete_data_annotated_day50[, 1:48]

# Step 2: Extract annotation columns (last 19 columns)
annotation_d50 <- complete_data_annotated_day50[, (ncol(complete_data_annotated_day50) - 21):ncol(complete_data_annotated_day50)]

# Step 3: Clean column names: remove "_log2_fold_change" suffix
colnames(log2fc_d50) <- str_replace(colnames(log2fc_d50), "_log2_fold_change$", "")

# Step 4: Combine cleaned log2FC values with annotations
log2FC_d50_annotated <- bind_cols(log2fc_d50, annotation_d50)


# ---------------- Function for user selected correlation of annotation ---------------- #
# This function computes and visualizes the correlation of log2 fold changes (log2FC)
# across multiple genotypes for genes annotated to selected organelles.
# It generates both a correlation matrix (as CSV) and a heatmap (as PDF).

correlate_log2fc_annotations <- function(data, annotations, basedir, prefix = "diff132_d50_neuroLSD_correlation") {

  # Step 1: Filter genes belonging to any of the selected annotations
  filtered_data <- data %>%
    filter(if_any(all_of(annotations), ~ .x == TRUE))

  # Step 2: Extract log2FC values (columns 2–47), replace NAs with 0
  log2fc_matrix <- filtered_data[, 2:47]
  log2fc_matrix[is.na(log2fc_matrix)] <- 0
  rownames(log2fc_matrix) <- filtered_data$Genes  # set gene names as rownames

  # Step 3: Compute correlation matrix (genotype × genotype)
  correlation_matrix <- cor(log2fc_matrix, use = "pairwise.complete.obs")
  correlation_matrix[is.na(correlation_matrix)] <- 0  # ensure no missing values

  # Step 4: Create sample metadata from column names (genotype and neuron type)
  meta <- str_match(colnames(correlation_matrix), "^(.+?)_(iDA|iN)")
  annotation_df <- data.frame(
    Genotype = meta[, 2],
    Neuron = meta[, 3]
  )
  rownames(annotation_df) <- colnames(correlation_matrix)

  # Step 5: Define color mappings for annotation
  genotype_colors <- setNames(
    colorRampPalette(brewer.pal(8, "Paired"))(length(unique(annotation_df$Genotype))),
    unique(annotation_df$Genotype)
  )
  neuron_colors <- c("iN" = "grey50", "iDA" = "grey80")
  ann_colors <- list(Genotype = genotype_colors, Neuron = neuron_colors)

  # Step 6: Construct file paths using input annotations
  annotation_label <- paste(annotations, collapse = "_")
  csv_path <- file.path(basedir, paste0(prefix, "_", annotation_label, ".csv"))
  pdf_path <- file.path(basedir, paste0(prefix, "_", annotation_label, ".pdf"))

  # Step 7: Save correlation matrix as CSV
  write.csv(correlation_matrix, file = csv_path, row.names = TRUE)

  # Step 8: Plot heatmap and save as PDF
  pdf(pdf_path, width = 8, height = 7)  # adjust to square if needed
  pheatmap(
    mat = correlation_matrix,
    color = colorRampPalette(rev(brewer.pal(11, "RdYlBu")))(100),
    annotation_col = annotation_df,
    annotation_row = annotation_df,
    annotation_colors = ann_colors,
    cluster_rows = TRUE,
    cluster_cols = TRUE,
    show_rownames = TRUE,
    show_colnames = TRUE,
    border_color = NA,
    fontsize = 6,
    main = paste("Correlation –", annotation_label)
    # cellheight = 15, cellwidth = 15 # Uncomment for fixed-size cells
  )
  dev.off()

  return(correlation_matrix)
}

# ---------------- Run the Function ---------------- #
# This example correlates log2FC across genotypes for SynGO and Lysosomal genes
# run dev.off to clear plotting space
dev.off()

correlate_log2fc_annotations(
  data = log2FC_d50_annotated,
  annotations = c("EndoLyso","Presynaptic","Postsynaptic", "SynGO"),
  basedir = "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/Organelle_CrossCorr"
)


# Annotations:
# "Mito.IMS","Mito.Matrix","Mito.MIM", "Mito.MOM","OXPHOS","mtComplexI","Golgi.Genes","Lysosome.Genes","ER.genes","Cytoplasm","Nucleus","Autophagy","Autophagy..Detailed.","SynGO",                "Endo_iN_curated_Hundley","Presynaptic","Postsynaptic","EndoDetailed","NeuroDev","EndoLyso","EarlyEndosome","RecyclingEndosome"    




```

#### Vb. --- All Organelle-annotation correlation  ---
```{r}
library(dplyr)
library(tidyr)
library(pheatmap)
library(RColorBrewer)
library(tibble)

## --- Cross-correlation matrix of genotypes --- ##
# idea is that to calculate correlation of annotated organelles across all genotypes
# the organelles that have high corr do not change much between the genotypes
# the organelles that do anti-correlate change more between them ==> more interesting biology? 

run_all_organelle_corr <- function(df, annotations) {
  # KO‐effect columns = everything that ends with “_iDA” or “_iN”
  ko_cols <- grep("_(iDA|iN)$", names(df), value = TRUE)

  purrr::map_dfr(annotations, function(ann) {
    purrr::map_dfr(ko_cols, function(ko) {
      x <- df[[ko]]                 # log2-FC vector
      y <- as.numeric(df[[ann]])    # 1/0 membership
      keep <- !(is.na(x) | is.na(y))
      if (sum(keep) < 5) return(NULL)

      ct <- suppressWarnings(cor.test(x[keep], y[keep], method = "spearman"))
      tibble(
        KO        = ko,
        Organelle = ann,
        r         = unname(ct$estimate),
        p         = ct$p.value
      )
    })
  })
}

org_corr_df <- run_all_organelle_corr(
  log2FC_d50_annotated,
  annotations = c("Mito", "Mito.IMS", "Mito.Matrix", "Mito.MIM", "Mito.MOM",
                  "OXPHOS", "mtComplexI", "Golgi.Genes", "Lysosome.Genes",
                  "ER.genes", "Endosome.Genes", "Cytoplasm", "Nucleus",
                  "Autophagy", "SynGO", "Endo_iN_curated_Hundley",
                  "Presynaptic", "Postsynaptic", "NeuroDev", "EndoLyso", "EarlyEndosome","RecyclingEndosome")
)

# Convert to wide matrix: KO × Organelle
org_corr_mat <- org_corr_df %>%
  select(KO, Organelle, r) %>%
  pivot_wider(names_from = Organelle, values_from = r) %>%
  column_to_rownames("KO") %>%
  as.matrix()

# Replace NA with 0
org_corr_mat[is.na(org_corr_mat)] <- 0

# Define KO type (iN vs iDA) from KO names
ko_type <- data.frame(CellType = ifelse(grepl("_iDA$", rownames(org_corr_mat)), "iDA", "iN"))
rownames(ko_type) <- rownames(org_corr_mat)

# Color scheme for celltypes 
celltype_colors <- c(iDA = "grey80", iN = "grey40")

# Plot the heatmap
annotCorrLSD <- pheatmap::pheatmap(
  org_corr_mat,
  color = rev(RColorBrewer::brewer.pal(11, "RdYlBu")),
  na_col = "grey90",
  cluster_rows = TRUE,
  cluster_cols = TRUE,
  angle_col = 90,
  cellheight = 15,
  cellwidth  = 15,
  main = paste("Organelle Correlation"),
  fontsize = 10,
  border_color = NA,
  annotation_row = ko_type,
  annotation_colors = list(CellType = celltype_colors)
)


annotCorrLSD
pdf("/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/Organelle_CrossCorr/diff132_annotCorrLSD.pdf",
    width = 12, height = 16, useDingbats = FALSE)
print(annotCorrLSD)
dev.off()

## save org_corr_mat as csv file in the same directory
write.csv(org_corr_mat, 
          file = "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/Organelle_CrossCorr/diff132_organelle_corr_matrix.csv",
          row.names = TRUE)




## --- Cross-correlation matrix of genotypes for each organelle --- ##
library(gridExtra)

# Function: compute KO × KO correlation matrix for a given organelle
plot_ko_corr_matrix <- function(organelle_name, df = log2FC_d50_annotated) {
  ko_cols <- grep("_(iDA|iN)$", names(df), value = TRUE)
  gene_filter <- df[[organelle_name]] == 1
  mat <- df[gene_filter, ko_cols, drop = FALSE]

  # Drop if insufficient data
  if (nrow(mat) < 5) return(NULL)

  corr_mat <- cor(mat, use = "pairwise.complete.obs", method = "spearman")

  # Build heatmap object
  pheatmap::pheatmap(
    corr_mat,
    main = organelle_name,
    color = rev(RColorBrewer::brewer.pal(11, "RdYlBu")),
    silent = TRUE,
    cellheight = 6,
    cellwidth  = 6,
    na_col = "grey90",
    cluster_rows = TRUE,
    cluster_cols = TRUE,
    #angle_col = 90,
    border_color = NA,
    fontsize = 6,
    annotation_row = ko_type,
    annotation_colors = list(CellType = celltype_colors)
  )
}

## abbotations for plotting
all_ann <- c(
  "Mito","Mito.IMS","Mito.Matrix","Mito.MIM","Mito.MOM",
  "OXPHOS","mtComplexI","Golgi.Genes","Lysosome.Genes",
  "ER.genes","Endosome.Genes","Cytoplasm","Nucleus",
  "Autophagy","SynGO","Endo_iN_curated_Hundley",
  "Presynaptic","Postsynaptic","NeuroDev","EndoLyso",
  "EarlyEndosome","RecyclingEndosome"
)

# ---- per-organelle KO×KO heatmaps ------------------------------------------
heatmap_list <- lapply(all_ann, function(org) {
  if (!org %in% names(log2FC_d50_annotated)) return(NULL)   # skip if column absent
  plot_ko_corr_matrix(org, df = log2FC_d50_annotated)
})
heatmap_list <- Filter(Negate(is.null), heatmap_list)       # drop NULLs


# Arrange into a multi-panel figure (adjust ncol as needed) & save as pdf
pdf("/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/Organelle_CrossCorr/diff132_annotCorrLSD_facet.pdf",
    width = 30, height = 30, useDingbats = FALSE)

gridExtra::grid.arrange(
  grobs = lapply(heatmap_list, `[[`, "gtable"),
  ncol = 4
)

dev.off()

```


#### Vc. --- Plot average correlation per annotation across genotypes
```{r}
# function for plotting the average correlation per annotation
# dataframe is org_corr_mat
# on x axis should be the different genotypes 
# use barplot in theme_bw()
# plot in ascending manner  
# What to plot is based on user-input by annotations
plot_avg_corr_per_genotype <- function(corr_mat, annotations, out_path = NULL) {
  # Ensure annotations are present in the matrix
  valid_annotations <- annotations[annotations %in% colnames(corr_mat)]
  if (length(valid_annotations) == 0) {
    stop("None of the specified annotations are present in the correlation matrix.")
  }

  # Label for title and filename
  ann_label <- paste(valid_annotations, collapse = "_")
  ann_title <- paste(valid_annotations, collapse = ", ")

  # Subset matrix and compute mean and SEM per genotype (row)
  corr_subset <- corr_mat[, valid_annotations, drop = FALSE]
  avg_corr <- rowMeans(corr_subset, na.rm = TRUE)
  sem_corr <- apply(corr_subset, 1, function(x) sd(x, na.rm = TRUE) / sqrt(sum(!is.na(x))))

  avg_corr_df <- data.frame(
    Genotype = rownames(corr_mat),
    AvgCorr = avg_corr,
    SEM = sem_corr
  )

  p <- ggplot(avg_corr_df, aes(x = reorder(Genotype, AvgCorr), y = AvgCorr)) +
    geom_bar(stat = "identity", fill = "grey70", width = 0.7) +
    geom_errorbar(aes(ymin = AvgCorr - SEM, ymax = AvgCorr + SEM), width = 0.2) +
    geom_hline(yintercept = 0, linetype = "dashed", color = "black", linewidth = 0.3) +
    theme_bw(base_size = 6) +
    labs(
      title = paste("Average Organelle Correlation per Genotype -", ann_title),
      x = "Genotype", y = "Average Correlation (r)"
    ) +
    theme(
      axis.text.x = element_text(angle = 90, hjust = 1),
      panel.grid = element_blank()
    )

  # Save if output path is provided
  if (!is.null(out_path)) {
    out_file <- file.path(out_path, paste0("avg_corr_per_genotype_", ann_label, ".pdf"))
    ggsave(out_file, p, width = 5, height = 5, device = cairo_pdf)
  }

  return(p)
}

## Call plotting function and input annotation of interest to plot 
avg_corr_plot <- plot_avg_corr_per_genotype(
  corr_mat = org_corr_mat,
  annotations = c("EarlyEndosome"),
  out_path = "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/Organelle_CrossCorr/bar_avg"
)


# all_ann <- c(
#   "Mito","Mito.IMS","Mito.Matrix","Mito.MIM","Mito.MOM",
#   "OXPHOS","mtComplexI","Golgi.Genes","Lysosome.Genes",
#   "ER.genes","Endosome.Genes","Cytoplasm","Nucleus",
#   "Autophagy","SynGO","Endo_iN_curated_Hundley",
#   "Presynaptic","Postsynaptic","NeuroDev","EndoLyso",
#   "EarlyEndosome","RecyclingEndosome"
# )

```

### Vd. --- Linear regression on neuro nDIA dataset
#### Vd1. --- Linear regression on gene level across neurontypes
```{r}
### ---- Per-Gene Linear Modeling ----
# This script performs gene-specific linear regression to identify differential
# expression based on genotype and neuron type, accounting for experimental day.
library(tidyverse)
library(dplyr)
library(broom)
library(tidyr)
library(ggplot2)
library(ggrepel)
library(purrr)

## Step 1: Prepare and Factorize Data
# Filter out missing values and convert 'neuron' and 'genotype' to factors.
# 'iN' is set as the reference level for 'neuron'.
lm_results_gx2 <- clean_d50_df %>%
  filter(!is.na(fold_change), !is.na(genotype), !is.na(neuron)) %>%
  mutate(
    neuron   = factor(neuron, levels = c("iN", "iDA")),
    genotype = factor(genotype)
  )


## Step 2: Fit Per-Gene Linear Models
# Group data by gene, nest, and fit a linear model for 'fold_change' explained by
# 'genotype', 'neuron', their interaction, and 'day'.
lm_results <- lm_results_gx2 %>%
  group_by(Genes) %>%
  nest() %>%
  mutate(
    model = map(data, ~ tryCatch(
      lm(fold_change ~ genotype * neuron + day, data = .x),
      error = function(e) NULL
    )),
    tidy = map(model, ~ if (!is.null(.x)) broom::tidy(.x) else tibble())
  ) %>%
  unnest(tidy) %>%
  filter(!is.na(p.value))


## Step 3: Add Q-values (FDR Corrected P-values)
# Apply Benjamini-Hochberg (BH) False Discovery Rate (FDR) correction to p-values
# within each 'term' category to control for multiple comparisons.
lm_results_df <- lm_results %>%
  group_by(term) %>%
  mutate(q.value = p.adjust(p.value, method = "BH")) %>%
  ungroup()


## Step 4: Filter for Significant Terms
# Filter for terms with a q-value (FDR-adjusted p-value) less than 0.05.
sig_genes_df <- lm_results_df %>%
  filter(q.value < 0.05)


## Step 5: Filter and Extract Interaction Terms
# Isolate significant **genotype:neuron interaction terms** and extract the
# genotype and neuron types for easier interpretation.
sig_hits <- sig_genes_df %>%
  filter(str_detect(term, "genotype") & str_detect(term, "neuron")) %>%
  mutate(
    genotype = str_extract(term, "(?<=genotype)[^:]+"),
    neuron = str_extract(term, "(?<=:neuron)[^:]+")
  )


## Step 6: Identify Top Genes by Absolute Effect Size
# For each genotype, select the top 5 genes with the largest absolute interaction
# effect size (estimate).
top_hits <- sig_hits %>%
  group_by(genotype) %>%
  slice_max(order_by = abs(estimate), n = 5, with_ties = FALSE) %>%
  ungroup()


## Step 7: Plot Results
# Generate a scatter plot showing interaction effect sizes. Point size indicates
# significance (-log10(q-value)), and `ggrepel` labels the top genes.
d50_LinReg_plot <- ggplot(sig_hits, aes(x = interaction(genotype, neuron), y = estimate)) +
  geom_point(aes(size = -log10(q.value)), alpha = 0.7, color = "#1f78b4") +
  geom_text_repel(data = top_hits, aes(label = Genes),
                  size = 2.5, max.overlaps = 100) +
  labs(title = "Top Differential Effects per Genotype:Neuron Interaction",
       x = "Genotype : Neuron", y = "Effect Size",
       size = "-log10(q-value)") +
  theme_bw(base_size = 10) +
  coord_flip()


## Step 8: Save Results
# Save the generated plot and the data frame of all significant terms.
ggsave("/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/LinReg/diff132_d50_LinReg.pdf", d50_LinReg_plot, width = 8, height = 8, device = cairo_pdf)
write_csv(sig_genes_df, "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/LinReg/diff132_d50_LinReg_significant_genotype_hits.csv")

```

#### Vd2. --- Stratified linear modeling of genotype effects by neuron type ---
```{r}
library(tidyverse)
library(dplyr)
library(broom)
library(tidyr)
library(ggplot2)
library(ggrepel)
library(purrr)
# --- Prepare input data -----------------------------------------------------
# Filter out incomplete rows and ensure proper factor encoding
lm_input_df <- clean_d50_df %>%
  filter(!is.na(fold_change), !is.na(genotype), !is.na(neuron)) %>%
  mutate(
    genotype = factor(genotype),
    neuron   = factor(neuron)
  )


# --- Stratified linear regression function ----------------------------------
# This function fits a linear model (fold_change ~ genotype + day)
# for each gene within a specified neuron type (iN or iDA)
fit_stratified_model <- function(df, neuron_label) {
  df %>%
    filter(neuron == neuron_label) %>%
    group_by(Genes) %>%
    nest() %>%
    mutate(
      # Remove NA rows inside nested data
      data = map(data, ~ .x %>% drop_na(fold_change, genotype, day)),

      # Fit model only if gene has sufficient variation
      model = map(data, ~ {
        d <- .x
        if (n_distinct(d$genotype) < 2 || n_distinct(d$day) < 2) return(NULL)
        lm(fold_change ~ genotype + day, data = d)
      }),

      # Extract tidy output if model succeeded
      tidy = map(model, ~ if (!is.null(.x)) broom::tidy(.x) else NULL)
    ) %>%
    filter(!map_lgl(tidy, is.null)) %>%     # keep only successful fits
    select(Genes, tidy) %>%
    unnest(tidy) %>%
    mutate(neuron = neuron_label)
}


# --- Run model for each neuron type ----------------------------------------
lm_in_df  <- fit_stratified_model(lm_input_df, "iN")
lm_ida_df <- fit_stratified_model(lm_input_df, "iDA")

# Combine results from both neuron types
lm_neuronwise_df <- bind_rows(lm_in_df, lm_ida_df)


# --- Adjust p-values for multiple testing ----------------------------------
# Apply Benjamini-Hochberg correction within each term × neuron group
lm_neuronwise_df <- lm_neuronwise_df %>%
  group_by(term, neuron) %>%
  mutate(q.value = p.adjust(p.value, method = "BH")) %>%
  ungroup()


# --- Extract and summarize significant results -----------------------------
# Keep only genotype-related terms (omit intercept), FDR < 0.05
ko_terms_sig <- lm_neuronwise_df %>%
  filter(str_detect(term, "^genotype"), term != "(Intercept)", q.value < 0.05)

# For each genotype × neuron term, get top 3 genes by effect size
top_ko_hits <- ko_terms_sig %>%
  group_by(term, neuron) %>%
  slice_max(order_by = abs(estimate), n = 3, with_ties = FALSE) %>%
  ungroup()


# --- Visualization: Effect sizes for significant genotype terms -----------
d50_LinRegNeuron_plot <- ggplot(ko_terms_sig, aes(x = term, y = estimate, fill = neuron)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.6) +
  geom_jitter(width = 0.2, alpha = 0.2, size = 0.3) +
  geom_text_repel(
    data = top_ko_hits,
    aes(label = Genes),
    size = 2.5, max.overlaps = 100
  ) +
  scale_fill_manual(values = c("iDA" = "dodgerblue", "iN" = "#F08080")) +
  labs(
    title = "Significant Genotype Effects by Neuron Type",
    x = "Genotype (KO vs ctrl)", y = "Estimated Effect",
    fill = "Neuron"
  ) +
  theme_bw(base_size = 10) +
  coord_flip()


# --- Save output ----------------------------------------------------------
# Save plot as PDF
ggsave(
  "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/LinReg/diff132_d50_LinReg_byNeuron.pdf",
  d50_LinRegNeuron_plot, width = 8, height = 8, device = cairo_pdf
)

# Export top hits to CSV
write_csv(
  top_ko_hits,
  "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/LinReg/diff132_d50_LinReg_significant_genotype_hits_neuron.csv"
)


```


#### Vd3. --- Limma linear modeling ---
Use-Case for limma (Linear Models for Microarray/omics Data)

limma is highly optimized for large-scale omics data where:
	•	Genes are modeled in parallel.
	•	The number of observations per gene is small (e.g. 3–5 replicates per condition).
	•	You want borrowing of variance information across genes to stabilize estimates.

Advantages:
	•	Empirical Bayes moderation of standard errors → improves power when sample size is small.
	•	Efficient for batch comparisons, e.g. all KOs vs ctrl.
	•	Handles complex designs via model.matrix().
	•	Very fast for large matrices.

Best suited if:
	•	Your data is already log-transformed intensities or fold changes.
	•	You want to test contrasts like:
	•	KO vs ctrl in iDA
	•	KO vs ctrl in iN
	•	KO effect shared across both neuron types
	•	Interaction (is KO effect different in iDA vs iN)
	
	
	
	Design Matrix: 
	design <- model.matrix(~ genotype * neuron, data = sample_meta)
	
	This generates three types of terms in your model:
	1.	Main effect of genotype
  	•	Measures how each genotype differs from the reference genotype in the reference neuron type (e.g. iDA).
  	•	Use when you’re asking: “Does genotype X differ from control in iDA neurons?”
	2.	Main effect of neuron
  	•	Measures the effect of switching from iDA to iN in the reference genotype (e.g. control).
  	•	Use when you’re asking: “Is there a baseline difference between neuron types in controls?”
	3.	Interaction: genotype:neuron
  	•	Tests whether the effect of genotype differs between neuron types.
  	•	Use when you’re asking: “Is the genotype effect different in iN vs iDA?”
  	•	This tells you if there’s a non-additive (context-specific) effect of the mutation in iN.

```{r}
# Load necessary package
library(limma)
library(tidyverse)
# ─────────────────────────────────────────────────────────────
# Linear model: ~ genotype * neuron
# - Main effect of genotype: difference of KO vs control in reference neuron (here -> iN)
# - Main effect of neuron: difference between iN vs iDA in control genotype
# - Interaction (genotype:neuron): difference in KO effect between iN and iDA
# 
# File explaination 
# - MAplot_iN_genotypeKO ==> effect of  KO vs control in iN (reference neuron)
# - MAplot_iN_genotypeKO.neuroniDA ==> difference in KO effect between iDA and iN. Does the KO behave differently in iDA compared to iN
# - MAplot_iDA_genotype…KOgenotypeKO.neuroniDA ==> effect of  KO vs control in iDA neurons
# ─────────────────────────────────────────────────────────────

diff132_long_reps <- read.csv('/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/datasets/lsd_pro_long.csv', 
                                    header = TRUE, sep = ',', stringsAsFactors = FALSE)

## ─────────────────────────────────────────────────────────────
## Step 1.  Filter out QC samples (NA genotype)
##          Filter out contaminant proteins
## ─────────────────────────────────────────────────────────────
contaminant_genes <- c(
  "KRT8", "KRT19", "KRT9", "KRT10", "KRT2", "KRT18", "KRT1", "KRT5",
  "COL10A1", "COL13A1", "COL14A1", "COL18A1", "COL1A1", "COL1A2",
  "COL26A1", "COL2A1", "COL4A1", "COL4A2", "COL5A1", "COL6A1", "COL6A2"
  )

df_day50_filtered <- diff132_long_reps %>%
  filter(!is.na(genotype)) %>%
  filter(!Genes %in% contaminant_genes)


## ─────────────────────────────────────────────────────────────
## Step 2.  Create unique sample IDs from experimental metadata
## ─────────────────────────────────────────────────────────────
df_day50_filtered <- df_day50_filtered %>%
  mutate(sample_id = paste(day, genotype, neuron, replicate, sep = "_"))


## ─────────────────────────────────────────────────────────────
## Step 3.  Pivot to wide format using unique sample IDs
## ─────────────────────────────────────────────────────────────
expr_df <- df_day50_filtered %>%
  group_by(Genes, sample_id) %>%
  summarise(quan_0 = mean(quan_0, na.rm = TRUE), .groups = "drop") %>%
  pivot_wider(names_from = sample_id, values_from = quan_0) %>%
  column_to_rownames("Genes")


expr_mat <- expr_df %>%
  mutate(across(everything(), as.numeric)) %>%
  as.matrix()

# Log2-transform the expression matrix to stabilize variance
expr_mat <- log2(expr_mat + 1)  # add pseudocount to avoid log(0)


## ─────────────────────────────────────────────────────────────
## Step 4.  clean df from NA, prepare metadata, and align samples
##          run limma 
## ─────────────────────────────────────────────────────────────
# Impute NAs with row means
expr_mat[is.na(expr_mat)] <- rowMeans(expr_mat, na.rm = TRUE)[row(expr_mat)[is.na(expr_mat)]]

# Prepare sample metadata
sample_meta <- df_day50_filtered %>%
  select(sample_id, genotype, neuron) %>%
  distinct() %>%
  mutate(sample_id = make.names(sample_id))

# Align samples
colnames(expr_mat) <- make.names(colnames(expr_mat))
matching_ids <- intersect(colnames(expr_mat), sample_meta$sample_id)
expr_mat <- expr_mat[, matching_ids]
sample_meta <- filter(sample_meta, sample_id %in% matching_ids)

## check metadata: how many replicates per genotype X celltype?
table(sample_meta$genotype, sample_meta$neuron)

# Set reference level
sample_meta <- sample_meta %>%
  mutate(
    genotype = factor(genotype),
    neuron = factor(neuron, levels = c("iN", "iDA"))  # iN as reference
  )

# Full model with interaction
design <- model.matrix(~ genotype * neuron, data = sample_meta)
colnames(design) <- make.names(colnames(design))

# Fit model
fit <- lmFit(expr_mat, design)
fit <- eBayes(fit)

# Construct contrast matrix: iDA KO vs iDA ctrl = genotypeKO + genotypeKO:neuroniDA
contrasts_list <- colnames(design)
ko_levels <- grep("^genotype", contrasts_list, value = TRUE)
interaction_levels <- grep("^genotype.*:neuron", contrasts_list, value = TRUE)

# Extract KO names (excluding 'ctrl')
ko_names <- grep("^genotype(?!ctrl)", colnames(design), value = TRUE, perl = TRUE)

# Build iDA contrasts and store valid entries
ida_contrasts_list <- lapply(ko_names, function(ko) {
  interaction_term <- paste0(ko, ".neuroniDA")
  if (all(c(ko, interaction_term) %in% colnames(design))) {
    return(paste0(ko, " + ", interaction_term))
  } else {
    return(NULL)
  }
})

# Filter out NULLs
valid_idx <- !sapply(ida_contrasts_list, is.null)
ida_contrasts <- unlist(ida_contrasts_list[valid_idx])
names(ida_contrasts) <- gsub("^genotype", "iDA_", ko_names[valid_idx])

# Create contrast matrix
contrast_matrix <- makeContrasts(contrasts = ida_contrasts, levels = design)

# Fit contrasts
fit_contrasts <- contrasts.fit(fit, contrast_matrix)
fit_contrasts <- eBayes(fit_contrasts)


## ─────────────────────────────────────────────────────────────
## Step 5.  save limma results in output dir
##          save MA plot for each coefficient 
## ─────────────────────────────────────────────────────────────
# Create output directory
output_dir <- "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/LinReg/limma_all_coef"
dir.create(output_dir, showWarnings = FALSE, recursive = TRUE)

# Initialize list for saving variables 
results_all <- list()

# Loop through coefficients
# Combine all coefficient names: original + iDA contrasts
# Track coefficients from original and contrast fits
all_coef_names <- c(colnames(fit$coefficients), colnames(fit_contrasts$coefficients))
fit_sources <- c(rep("fit", ncol(fit)), rep("fit_contrasts", ncol(fit_contrasts)))

for (i in seq_along(all_coef_names)) {
  coef_name <- all_coef_names[i]
  fit_obj <- if (fit_sources[i] == "fit") fit else fit_contrasts
  prefix <- if (fit_sources[i] == "fit") "iN_" else "iDA_"

  res <- topTable(fit_obj, coef = coef_name, number = Inf, adjust.method = "BH") %>%
    rownames_to_column("Genes")

  matched_idx <- match(res$Genes, rownames(expr_mat))
  valid_idx <- which(!is.na(matched_idx))
  res <- res[valid_idx, ]
  matched_idx <- matched_idx[valid_idx]

  res <- res %>%
    mutate(
      coef = coef_name,
      baseMean = rowMeans(expr_mat[matched_idx, , drop = FALSE], na.rm = TRUE),
      log2FoldChange = log2(abs(logFC) + 1e-6) * sign(logFC),
      baseMean_log2  = log2(baseMean + 1e-6),
      padj = adj.P.Val,
      sig = case_when(
        #padj < 0.05 & log2FoldChange > log2(1.3)  ~ "Up",        # BH-adjusted p-value
        #padj < 0.05 & log2FoldChange < -log2(1.3) ~ "Down",      # BH-adjusted p-value
        P.Value < 0.01 & log2FoldChange > log2(2)  ~ "Up",      # raw p-value
        P.Value < 0.01 & log2FoldChange < -log2(2) ~ "Down",    # raw p-value
        TRUE ~ "NS"
      )
    )

  # Save per-contrast CSV
  write.csv(
    res,
    file = file.path(output_dir, paste0("limma_results_", prefix, make.names(coef_name), ".csv")),
    row.names = FALSE
  )

  # Plot
  top_genes <- res %>% filter(sig != "NS") %>%
    slice_max(order_by = abs(log2FoldChange), n = 50)
  df_ns  <- res %>% filter(sig == "NS")
  df_sig <- res %>% filter(sig != "NS")

  p <- ggplot() +
    geom_point(data = df_ns, aes(x = baseMean, y = log2FoldChange),
               color = "gray70", size = 1.5, alpha = 0.5) +
    geom_point(data = df_sig, aes(x = baseMean, y = log2FoldChange, color = sig),
               size = 2.0) +
    geom_text_repel(data = top_genes,
                    aes(x = baseMean, y = log2FoldChange, label = Genes, color = sig),
                    size = 3, box.padding = 0.5, point.padding = 1,
                    max.overlaps = 75, segment.color = "grey50") +
    scale_color_manual(values = c("Down" = "#1465AC", "Up" = "#B31B21")) +
    theme_bw(base_size = 10) +
    labs(
      x = "Mean Abundance",
      y = "Log2 Fold Change",
      title = paste("MA Plot:", prefix, coef_name),
      color = "Significance"
    ) +
    theme(panel.grid = element_blank(), legend.position = "bottom")

  ggsave(
    filename = file.path(output_dir, paste0("MAplot_", prefix, make.names(coef_name), ".pdf")),
    plot = p, width = 8, height = 8, device = cairo_pdf
  )

  results_all[[paste0(prefix, coef_name)]] <- res
}

# Combine and save all results
results_all_df <- bind_rows(results_all, .id = "coef")
write.csv(results_all_df, file.path(output_dir, "limma_results_all.csv"), row.names = FALSE)


# check results ==> how many are significant etc 
# Check results
summary(results_all_df$P.Value)
sum(results_all_df$P.Value < 0.01)

 

## ─────────────────────────────────────────────────────────────
## Step 6. Select limma results => if interested in spec. geno / celltype & save 
## ─────────────────────────────────────────────────────────────
# List available coefficient names:
colnames(fit$coefficients)

# list of plottable coefficients
# "genotypeATP13A2","genotypeCLN3","genotypeCLN5","genotypeCLN6","genotypeCLN8","genotypectrl","genotypeCTSD","genotypeCTSF","genotypeDNAJC5","genotypeGAA","genotypeGBA1","genotypeGRN","genotypeHEXA","genotypeHEXB","genotypeLIPA","genotypeMCOLN1","genotypeMFSD8","genotypeNPC1","genotypeNPC2","genotypePPT1","genotypePSAP","genotypeSMPD1","genotypeTPP1"
# "neuroniN"
# "genotypeATP13A2:neuroniN","genotypeCLN3:neuroniN","genotypeCLN5:neuroniN","genotypeCLN6:neuroniN","genotypeCLN8:neuroniN","genotypectrl:neuroniN","genotypeCTSD:neuroniN","genotypeCTSF:neuroniN","genotypeDNAJC5:neuroniN","genotypeGAA:neuroniN","genotypeGBA1:neuroniN","genotypeGRN:neuroniN","genotypeHEXA:neuroniN","genotypeHEXB:neuroniN","genotypeLIPA:neuroniN","genotypeMCOLN1:neuroniN","genotypeMFSD8:neuroniN","genotypeNPC1:neuroniN","genotypeNPC2:neuroniN","genotypePPT1:neuroniN","genotypePSAP:neuroniN","genotypeSMPD1:neuroniN","genotypeTPP1:neuroniN"

# View results for interaction term (e.g., ATP13A2 genotype x iNeuron cell type)
resultsSelect <- topTable(fit, coef = "genotypeMCOLN1:neuroniN", number = Inf)

# Save results
write.csv(resultsSelect, "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/LinReg/limma_select/limma_results_genotypeATP13A2-X-neuroniN.csv", row.names = TRUE)



## ─────────────────────────────────────────────────────────────
## 7. MA plot using ggplot for select input coefficient 
## ─────────────────────────────────────────────────────────────
#install.packages("ggpubr")  # if not already installed
library(ggpubr)
library(dplyr)


# Example: coefficient of interest
coef_name <- "genotypeNPC1:neuroniN"

resultsSelect <- results_all_df %>% filter(coef == coef_name)

## ggplot implementation 
# Annotate significance
de_df <- resultsSelect %>%
  mutate(
    sig = case_when(
        #padj < 0.05 & log2FoldChange > log2(1.3)  ~ "Up",        # BH-adjusted p-value
        #padj < 0.05 & log2FoldChange < -log2(1.3) ~ "Down",      # BH-adjusted p-value
        P.Value < 0.01 & log2FoldChange > log2(2)  ~ "Up",      # raw p-value
        P.Value < 0.01 & log2FoldChange < -log2(2) ~ "Down",    # raw p-value
      TRUE ~ "NS"
    )
  )

# filter top genes 
top_genes <- de_df %>%
  filter(sig != "NS") %>%
  slice_max(order_by = abs(log2FoldChange), n = 50)

# Split into NS and significant
df_ns  <- de_df %>% filter(sig == "NS")
df_sig <- de_df %>% filter(sig != "NS")

# Plot
neuroMAplot <- ggplot() +
  geom_point(data = df_ns, aes(x = baseMean, y = log2FoldChange), 
             color = "gray70", size = 1.5, alpha = 0.5) +
  geom_point(data = df_sig, aes(x = baseMean, y = log2FoldChange, color = sig), 
             size = 2.0) + 
  geom_text_repel(data = top_genes,
                    aes(x = baseMean, y = log2FoldChange, label = Genes, color = sig),
                    size = 3, box.padding = 0.5, point.padding = 1,
                    max.overlaps = 75, segment.color = "grey50") + 
  scale_color_manual(values = c("Down" = "#1465AC", "Up" = "#B31B21")) +
  theme_bw(base_size = 10) +
  labs(
    x = "Mean Abundance",
    y = "Log2 Fold Change",
    title = paste("MA Plot:", coef_name),
    color = "Significance"
  ) +
  theme(panel.grid = element_blank(),
        legend.position = "bottom")



ggsave(
  "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/LinReg/limma_all_coef/MAplot_SelectGenotype.pdf",
  neuroMAplot, width = 8, height = 8, device = cairo_pdf
)



```


## --- umap attempty of lin model results
```{r}
# UMAP Parameters Explained
# metric (default: “euclidean”)
# 	•	Defines the distance metric used in high-dimensional space.
# 	•	Common options:
# 	•	"euclidean": straight-line distance.
# 	•	"manhattan": sum of absolute differences.
# 	•	"cosine": angle-based, good for sparse / high-dimensional data.
# 	•	"correlation": clusters based on expression pattern, not magnitude (useful for gene-level analysis).

library(tidyverse)
library(uwot)      # for UMAP
library(ggplot2)
library(RColorBrewer)
library(scales)


# Create output directory
output_dir_umap <- "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/LinReg/umap"
dir.create(output_dir_umap, showWarnings = FALSE, recursive = TRUE)


# 1. Reshape results_all_df into a wide matrix: genes × coefficients
# Pivot to wide format: each gene's logFC across all coefficients
limma_UMAP_logfc_matrix <- results_all_df %>%
  select(Genes, coef, logFC) %>%
  pivot_wider(names_from = coef, values_from = logFC) %>%
  column_to_rownames("Genes")

# Optional: filter genes with too many NAs
limma_UMAP_logfc_matrix <- limma_UMAP_logfc_matrix[rowSums(is.na(limma_UMAP_logfc_matrix)) < 0.5 * ncol(limma_UMAP_logfc_matrix), ]

# Impute missing logFC with 0 or row/column mean (simplest: 0)
limma_UMAP_logfc_matrix[is.na(limma_UMAP_logfc_matrix)] <- 0

# 2. Run UMAP on logFC matrix
set.seed(123)
umap_res <- umap(limma_UMAP_logfc_matrix, n_neighbors = 10, min_dist = 0.1, metric = "manhattan")

umap_df <- as.data.frame(umap_genes$layout)

# 3. K-means clustering
kres <- kmeans(umap_df, centers = 18)

# 4. Create UMAP dataframe
colnames(umap_df) <- c("UMAP1", "UMAP2")
umap_df$cluster <- factor(kres$cluster)
umap_df$Genes <- rownames(limma_UMAP_logfc_matrix)

# 3. Merge with average logFC or metadata (optional)
gene_meta <- results_all_df %>%
  group_by(Genes) %>%
  summarise(mean_logFC = mean(logFC, na.rm = TRUE))

gene_group <- results_all_df %>%
  group_by(Genes) %>%
  slice_max(order_by = abs(log2FoldChange), n = 1, with_ties = FALSE) %>%
  select(Genes, coef)

umap_df <- umap_df %>%
  distinct(Genes, .keep_all = TRUE)
umap_df <- left_join(umap_df, gene_meta, by = "Genes")
umap_df <- left_join(umap_df, gene_group, by = "Genes")


# Create 18-color palette by interpolating
my_colors <- colorRampPalette(brewer.pal(9, "Set3"))(18)
custom_colors <- colorRampPalette(brewer.pal(9, "Set3"))(70)

# Plot 1: Cluster
umap_limma_cluster <- ggplot(umap_df, aes(x = UMAP1, y = UMAP2, color = cluster)) +
  geom_point(size = 1.2) +
  scale_color_manual(values = my_colors) +
  theme_bw(base_size = 10) +
  labs(color = "Cluster", title = "UMAP Clustering of Genes by logFC") +
  theme(panel.grid = element_blank(), legend.position = "bottom")

# Plot 2: logFC
umap_limma_logFC <- ggplot(umap_df, aes(x = UMAP1, y = UMAP2, color = mean_logFC)) +
  geom_point(size = 1.2, alpha = 0.8) +
  scale_color_gradientn(colors = colorRampPalette(rev(brewer.pal(n = 11, name = "RdBu")))(9)) +
  theme_bw(base_size = 10) +
  labs(color = "Mean logFC", title = "UMAP of genes across coefficients") +
  theme(panel.grid = element_blank(), legend.position = "bottom")

# Plot 3: coef
umap_limma_coef <- ggplot(umap_df, aes(x = UMAP1, y = UMAP2, color = coef)) +
  geom_point(alpha = 0.8, size = 1.5) +
  #scale_color_viridis_d()+
  scale_color_manual(values = custom_colors) +
  theme_bw(base_size = 10) +
  labs(color = "Mean logFC", title = "UMAP of Genes by logFC across Conditions", color = "Group (coef)")+
  theme(panel.grid = element_blank(), legend.position = "bottom")


umap_limma_cluster
umap_limma_logFC
umap_limma_coef

# save csv
write.csv(umap_df, file.path(output_dir_umap , "umap_results_genes.csv"), row.names = FALSE)



```



### --- UMAP embedding of combined features 
```{r}
library(uwot)

# feature matrix: rows = proteins, cols = (corr_to_orgX, logFC_genotypeY, …)
feat_mat <- complete_data_annotated_day50 %>% 
  select(Genes, ends_with("_log2_fold_change")) %>% 
  column_to_rownames("Genes") %>% 
  as.matrix() %>% 
  scale(center = TRUE)

set.seed(123)
umap_res <- uwot::umap(feat_mat, n_neighbors = 20, min_dist = 0.3)
umap_df  <- as.data.frame(umap_res) %>% 
            mutate(Gene = rownames(feat_mat)) %>% 
            left_join(binary_matrix, by = "Gene")

ggplot(umap_df, aes(V1, V2, colour = Lysosome.Genes)) +
  geom_point(size = 1, alpha = 0.6) +
  labs(title = "Protein landscape – UMAP")



## --- UMAP embedding of combined features --- ##
library(dplyr)
library(uwot)


feat_mat <- complete_data_annotated_day50 %>%
  select(Genes, ends_with("_log2_fold_change")) %>%
  distinct(Genes, .keep_all = TRUE) %>%  # drop any duplicates
  column_to_rownames("Genes") %>%
  as.matrix() %>%
  scale(center = TRUE)

annotations <- c("Mito", "Mito.IMS", "Mito.Matrix", "Mito.MIM", "Mito.MOM",
                 "OXPHOS", "mtComplexI", "Golgi.Genes", "Lysosome.Genes",
                 "ER.genes", "Cytoplasm", "Nucleus",
                 "Autophagy", "SynGO", "Endo_iN_curated_Hundley",
                 "Presynaptic", "Postsynaptic", "NeuroDev","EndoLyso","EarlyEndosome", "RecyclingEndosome")

binary_matrix <- complete_data_annotated_day50 %>%
  select(Genes, all_of(annotations)) %>%
  distinct(Genes, .keep_all = TRUE) %>%
  tibble::column_to_rownames("Genes")

set.seed(123)
umap_res <- uwot::umap(feat_mat, n_neighbors = 8, min_dist = 0.01, metric = "manhattan")
umap_df <- as.data.frame(umap_res) %>%
  mutate(Genes = rownames(feat_mat)) %>%
  left_join(tibble::rownames_to_column(binary_matrix, "Genes"), by = "Genes")



umap_df <- umap_df %>%
  mutate(Lysosome_Label = factor(Lysosome.Genes, levels = c(FALSE, TRUE),
                                 labels = c("Not Lysosomal", "Lysosomal")))


ggplot(umap_df, aes(V1, V2, color = Lysosome_Label)) +
  geom_point(alpha = 0.7, size = 1) +
  scale_color_manual(values = c("Not Lysosomal" = "grey80", "Lysosomal" = "#D53E4F")) +
  labs(title = "UMAP of Proteins – Lysosomal Membership",
       x = "UMAP1", y = "UMAP2", color = "Membership") +
  theme_bw()



#Facet across organelles
library(tidyr)

# Reshape to long format: one row per Gene × Organelle
umap_long <- umap_df %>%
  select(V1, V2, Genes, all_of(annotations)) %>%
  pivot_longer(cols = all_of(annotations), names_to = "Organelle", values_to = "Membership") %>%
  mutate(Membership = factor(Membership, levels = c(FALSE, TRUE), labels = c("No", "Yes")))

# Plot with facets
ggplot(umap_long, aes(V1, V2, color = Membership)) +
  geom_point(size = 0.5, alpha = 0.7) +
  scale_color_manual(values = c("No" = "grey90", "Yes" = "#2166AC")) +
  facet_wrap(~ Organelle, ncol = 4) +
  labs(title = "UMAP: Organelle Membership by Protein",
       x = "UMAP1", y = "UMAP2", color = "Member") +
  theme_bw(base_size = 8)



#Color all organelle annotations in one UMAP
umap_df <- umap_df %>%
  mutate(OrganelleCount = rowSums(select(., all_of(annotations)), na.rm = TRUE))

ggplot(umap_df, aes(V1, V2, color = OrganelleCount)) +
  geom_point(size = 1, alpha = 0.8) +
  color_scale_gradientn(rev(RColorBrewer::brewer.pal(11, "RdYlBu")))
     labs(title = "UMAP Colored by Organelle Annotation Load",
       x = "UMAP1", y = "UMAP2", color = "# of Organelle Annotations") +
  theme_minimal()



#Color by genotype influence (e.g., average abs(log2FC))
log2fc_magnitude <- rowMeans(abs(feat_mat), na.rm = TRUE)

umap_df$KOeffect <- log2fc_magnitude[umap_df$Genes]

ggplot(umap_df, aes(V1, V2, color = KOeffect)) +
  geom_point(size = 1, alpha = 0.8) +
  scale_color_distiller(palette = "RdYlBu", direction = -1) +
  labs(title = "UMAP Colored by Genotype Effect Size",
       x = "UMAP1", y = "UMAP2", color = "Mean |log2FC|") +
  theme_minimal()
```


### Cross correlation of gene abunace per annotation for UMAP
https://embed.tidymodels.org/reference/step_umap.html

- do not have organelle IP data, but have very rich proteinIDs from the nDIA
- idea now is, for each organelle annotation list, to calculate the correlation of the proteins against each other, based on the log2FC from KO/Ctrl.
- have to embed the effect of the KO/Ctrl into the correlation
- then use these correlations and embed them in an UMAP.
- So in simple terms we embed the correlations of protein abundance influences both by the knockout (KO) and the local, synthetic protein environment (annotations)
```{r}
#install.packages("umap")
#library(umap)
library(ggplot2)
library(dplyr)
library(tidyr)
library(stringr)
#install.packages("uwot")
library(uwot)

# create new df variable, so it will not get corrupted 
UMAP_d50_df <- complete_data_annotated_day50

# Define your annotations
annotation_columns <- names(log2FC_d50_annotated)[(ncol(log2FC_d50_annotated)-19):ncol(log2FC_d50_annotated)]

# Step: Define usable annotations
usable_annotations <- colnames(complete_data_annotated_day50)[
  (ncol(complete_data_annotated_day50) - 17):ncol(complete_data_annotated_day50)
]

# Drop problematic or overly specific annotations
usable_annotations <- setdiff(usable_annotations, c("Autophagy..Detailed.", "EndoDetailed"))

# Function to process one annotation
process_annotation_umap <- function(usable_annotations) {
  # Step 1: Filter by annotation
  filtered <- log2FC_d50_annotated %>% filter(.data[[usable_annotations]] == TRUE)
  
  # Step 2: Extract log2FC matrix
  log2fc_mat <- filtered[, 2:47]
  log2fc_mat[is.na(log2fc_mat)] <- 0
  rownames(log2fc_mat) <- filtered$Genes
  
  # Step 3: Gene correlation
  gene_corr <- cor(t(log2fc_mat), use = "pairwise.complete.obs")
  gene_corr[is.na(gene_corr)] <- 0
  
  # Step 4: UMAP
  if (nrow(gene_corr) < 3) return(NULL)  # Skip tiny sets
  umap_res <- umap(gene_corr, n_neighbors = 10, min_dist = 0.1, metric = "correlation")
  
  # Step 5: Format output
  umap_df <- as.data.frame(umap_res)
  umap_df$Gene <- rownames(gene_corr)
  umap_df$Annotation <- usable_annotations
  return(umap_df)
}

# Run across all annotations
umap_all <- usable_annotations %>%
  map_dfr(~process_annotation_umap(.x))

# Plot UMAP embeddings
ggplot(umap_all, aes(x = V1, y = V2)) +
  geom_point(size = 1.2, alpha = 0.7) +
  facet_wrap(~Annotation, scales = "free") +
  theme_bw() +
  labs(title = "UMAP Embedding of Gene Correlation per Organelle Annotation",
       x = "UMAP1", y = "UMAP2")




# ----- annotation based UMAP ------ # 
# Load required libraries
library(dplyr)
library(stringr)
library(tidyr)
library(uwot)
library(ggplot2)


# --- Step 0: Copy input to avoid corrupting original ---
UMAP_d50_df <- complete_data_annotated_day50

# --- Step 1: Prepare log2FC and annotation matrices ---
log2fc_matrix_d50 <- UMAP_d50_df[, 2:47]
log2fc_matrix_d50[is.na(log2fc_matrix_d50)] <- 0
rownames(log2fc_matrix_d50) <- UMAP_d50_df$Genes

annotation_matrix_d50 <- UMAP_d50_df[, 48:ncol(UMAP_d50_df)]
rownames(annotation_matrix_d50) <- UMAP_d50_df$Genes

# Drop problematic annotations
annotation_matrix_d50 <- annotation_matrix_d50 %>%
  select(-c("Autophagy..Detailed.", "EndoDetailed"))

# --- Step 2: Identify valid annotations with ≥ 3 genes ---
valid_annotations <- annotation_matrix_d50 %>%
  summarise(across(everything(), ~sum(.x == TRUE))) %>%
  pivot_longer(cols = everything(), names_to = "Annotation", values_to = "Count") %>%
  filter(Count >= 3) %>%
  pull(Annotation)

# --- Step 3: Compute flattened correlation matrices ---
organelle_cor_vectors <- list()
max_length <- 0

for (ann in valid_annotations) {
  genes <- rownames(annotation_matrix_d50)[annotation_matrix_d50[[ann]] == TRUE]
  sub_mat <- log2fc_matrix_d50[genes, , drop = FALSE]
  if (nrow(sub_mat) < 3) next

  corr_mat <- cor(t(sub_mat), use = "pairwise.complete.obs")
  corr_mat[is.na(corr_mat)] <- 0

  corr_vec <- as.vector(corr_mat)
  organelle_cor_vectors[[ann]] <- corr_vec

  max_length <- max(max_length, length(corr_vec))
}

# --- Step 4: Pad correlation vectors to uniform length ---
organelle_correlation_matrix <- do.call(rbind, lapply(organelle_cor_vectors, function(v) {
  length(v) <- max_length
  v[is.na(v)] <- 0
  v
}))

# --- Step 5: UMAP embedding with disk-backed temp dir ---
cor_mat_file <- "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/organelle_correlation_matrix.rds"
umap_out_file <- "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/organelle_umap_result.rds"
local_tmp <- "~/umap_tmp"
dir.create(local_tmp, showWarnings = FALSE)

if (!exists("organelle_correlation_matrix")) {
  organelle_correlation_matrix <- readRDS(cor_mat_file)
}

if (!file.exists(umap_out_file)) {
  organelle_umap_result <- umap(
    organelle_correlation_matrix,
    n_neighbors = 5,
    min_dist = 0.1,
    metric = "euclidean",
    n_threads = 1,
    tmpdir = normalizePath(local_tmp),
    verbose = TRUE
  )
  saveRDS(organelle_umap_result, umap_out_file)
} else {
  organelle_umap_result <- readRDS(umap_out_file)
}

rownames(organelle_umap_result) <- rownames(organelle_correlation_matrix)

# --- Step 6: Plot UMAP ---
umap_df <- as.data.frame(organelle_umap_result)
umap_df$Annotation <- rownames(umap_df)

ggplot(umap_df, aes(x = V1, y = V2, label = Annotation)) +
  geom_point(size = 3, color = "grey30") +
  geom_text(size = 3, vjust = 1.2, hjust = 0.5) +
  labs(
    title = "UMAP of Organelle Log2FC Correlation Patterns",
    x = "UMAP1", y = "UMAP2"
  ) +
  theme_minimal()








# ----------- Gene-based UMAP -----------
library(dplyr)
library(ggplot2)
library(tidyr)
library(uwot)
library(irlba)
library(readr)
library(stringr)
library(RColorBrewer)
#install.packages("NatParksPalettes")
library(NatParksPalettes)

# Step 1: Gene correlation and PCA
gene_cor <- cor(t(log2fc_matrix_d50), use = "pairwise.complete.obs")
gene_cor[is.na(gene_cor)] <- 0

gene_pca <- prcomp_irlba(gene_cor, n = 100)

# Step 2: UMAP
gene_umap <- umap(
  gene_pca$x,
  n_neighbors = 25,
  min_dist = 0.2,
  metric = "cosine",
  n_threads = 1
)

# Step 3: Format UMAP output
gene_umap_df <- as.data.frame(gene_umap)
gene_umap_df$Gene <- rownames(log2fc_matrix_d50)

# ----------- Use subcell_df for annotation -----------
# subcell_df: each column = localization, values = gene symbols
# Step 4: Convert to long format
subcell_long <- subcell_df %>%
  pivot_longer(cols = everything(), names_to = "Localization", values_to = "Gene") %>%
  filter(!is.na(Gene))

# Step 5: Join with UMAP data (multi-row per gene possible)
gene_umap_annotated <- gene_umap_df %>%
  inner_join(subcell_long, by = "Gene")

# ----------- Plotting -----------
# Set a fixed palette length (e.g., 10 categories)
n_annots <- length(unique(gene_umap_annotated$Localization))
custom_colors <- colorRampPalette(rev(brewer.pal(11, "Paired")))(n_annots)

# UMAP with custom discrete colors
UMAP_gene <- ggplot(gene_umap_annotated, aes(x = V1, y = V2, color = Localization)) +
  geom_point(size = 0.8, alpha = 0.8) +
  scale_color_manual(values = custom_colors) +
  theme_classic() +
  labs(
    title = "ProteinID-level UMAP colored by subcellular localization",
    x = "UMAP 1", y = "UMAP 2", color = "Localization"
  )
UMAP_gene




# Faceted UMAP
# Assume 'gene_umap_annotated' has columns: V1, V2, Gene, Localization
# Step 1: Create a data frame with all combinations of genes and localizations
all_localizations <- unique(gene_umap_annotated$Localization)
all_genes <- gene_umap_annotated %>%
  select(Gene, V1, V2, Localization)

# Create all combinations
plot_data <- expand.grid(FacetLocalization = all_localizations, Gene = all_genes$Gene) %>%
  left_join(all_genes, by = "Gene")

# Step 2: Assign colors
plot_data <- plot_data %>%
  mutate(point_color = ifelse(Localization == FacetLocalization, "dodgerblue", "grey80"))

# Step 3: Separate the data into background and highlight points
background_points <- plot_data %>% filter(point_color == "grey80")
highlight_points <- plot_data %>% filter(point_color == "dodgerblue")

# Step 4: Plot
UMAP_gene_facet <- ggplot() +
  # Background layer: all points in grey
  geom_point(data = background_points, aes(x = V1, y = V2), color = "grey80", size = 0.8, alpha = 0.7) +
  # Highlight layer: points matching the facet's localization in blue
  geom_point(data = highlight_points, aes(x = V1, y = V2), color = "dodgerblue", size = 0.8, alpha = 0.7) +
  facet_wrap(~ FacetLocalization) +
  theme_classic() +
  labs(
    title = "ProteinID-level UMAP faceted by subcellular localization",
    x = "UMAP 1",
    y = "UMAP 2"
  )
UMAP_gene_facet




# Optional: save annotated file
write_csv(
  gene_umap_annotated,
  "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/gene_umap_annotated.csv"
)


# ------------ Combine Plots ----------- #
library(cowplot)
library(patchwork)

# combine plots for 
p10 <- UMAP_gene + theme(legend.position = "bottom")
p11 <- UMAP_gene_facet + theme(legend.position = "none")


# Combine layout: 
combined_plot_UMAP <- p10 / p11 +
  plot_layout(heights = c(0.5,1)) & 
  theme(plot.margin = margin(0.01, 10, 0.01, 10)) # Top, Right, Bottom, Left padding


# View or save
combined_plot_UMAP

# Save as PDF
ggsave("/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/diff132_d50_UMAP_gene_plot.pdf", combined_plot_UMAP, width = 12, height = 12, device = cairo_pdf)



```



# VI. nMOST whole cell plot correlcation matrix per genotype cluster
use tidyplots for that 
https://jbengler.github.io/tidyplots/

// Data preparation
Before starting to plot, the first thing is to ensure that your data is tidy. More formally, in tidy data

each variable must have its own column
each observation must have its own row and
each value must have its own cell

#### VIa. --- nMOST LSD GO signatures of select Clusters for all genotypes ---
```{r}
library(ggplot2)
library(dplyr)
library(tidyr)
library(forcats)
library(tidyverse)
# Load required libraries
library(tidyverse)

# Color palette for gene groups
col <- c(
  AGA= "grey76", ARSA= "grey76", ARSB= "grey76", ASAH1="#D53E4F", PPT1= "#FEE08B", CTSD="#FEE08B", 
  GRN="#FEE08B", CLN12.ATP13A2="#FEE08B", CTSF="#FEE08B", KCTD7="grey76", TPP1="#FEE08B", CLN3="#FEE08B", 
  DNAJC5="#FEE08B", CLN5="#FEE08B", CLN6="#FEE08B", MFSD8="#FEE08B", CLN8="#FEE08B", CTNS="#E6F598", CTSA="grey76", 
  FUCA="grey76", GAA="#66C2A5", GALC="grey76", GALNS="#F46D43", GBA="#D53E4F", 
  GLA="grey76", GLB1="#D53E4F", GM2A="grey76", GNPTAB="grey76", GNPTG="grey76", GNS="grey76", 
  GUSB="grey76", HEXA="#D53E4F", HEXB="#D53E4F", HGSNAT="grey76", HYAL1="grey76", 
  IDS="grey76", IDUA="grey76", LAMP2="grey76", LIPA="#66C2A5", MAN2B1="grey76", MANBA="grey76", MCOLN1="#E6F598", 
  NAGA="grey76", NAGLU="grey76", NEU1="grey76", NPC1="#E6F598", NPC2="#E6F598", PSAP="#D53E4F", 
  SCARB2="grey76", SGSH="grey76", SLC17A5="grey76", SMPD1="#D53E4F", SUMF1="grey76"
)

# Load and reshape the correlation data
HeLaCrossOmeCorrProt_df <- read.csv(
  '/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/20240801_dif118_iN-iDA_Ctrl-SMPD1-ASAH1_Proteomics/MSstats/HeLaCrossOmeCorr/LSD-nMOST_Protein-LipidCorr_tidyplots.csv',
  header = TRUE, sep = ',', stringsAsFactors = FALSE
)

# Convert wide to long format and clean cluster names
HeLaCrossOmeCorrProt_df_long <- HeLaCrossOmeCorrProt_df %>%
  pivot_longer(cols = starts_with("Protein.Cluster"), names_to = "Cluster", values_to = "Score") %>%
  mutate(Cluster = Cluster %>%
           str_replace("Protein\\.Cluster\\.", "Cluster ") %>%
           str_replace("\\.Signature", ""))

# Order clusters by median for optional use
cluster_order <- HeLaCrossOmeCorrProt_df_long %>%
  group_by(Cluster) %>%
  summarise(med = median(Score, na.rm = TRUE)) %>%
  arrange(med) %>%
  pull(Cluster)

HeLaCrossOmeCorrProt_df_long <- HeLaCrossOmeCorrProt_df_long %>%
  mutate(Cluster = factor(Cluster, levels = cluster_order))

# Main plotting function
HeLaClusterCorr <- function(df_long, cluster_name = "Cluster 7", plot_type = "mean") {
  df_filtered <- df_long %>%
    filter(Cluster == cluster_name) %>%
    mutate(Group = as.character(Group))

  # Sort groups by mean score for consistent display
  group_order <- df_filtered %>%
    group_by(Group) %>%
    summarise(mean_score = mean(Score, na.rm = TRUE)) %>%
    arrange(mean_score) %>%
    pull(Group)

  df_filtered <- df_filtered %>%
    mutate(Group = factor(Group, levels = group_order))

  if (plot_type == "mean") {
    # Barplot of group means
    df_filtered %>%
      group_by(Group) %>%
      summarise(mean_score = mean(Score, na.rm = TRUE)) %>%
      ggplot(aes(x = Group, y = mean_score)) +
      geom_col(fill = "grey40") +
      theme_minimal(base_size = 10) +
      labs(title = paste0("Mean score per group – ", cluster_name),
           x = NULL, y = "Mean Score") +
      theme(axis.text.x = element_text(angle = 45, hjust = 1))

  } else if (plot_type == "box") {
    # Color map for visible groups only
    used_groups <- levels(df_filtered$Group)
    col_used <- col[names(col) %in% used_groups]
    missing_groups <- setdiff(used_groups, names(col_used))
    col_used[missing_groups] <- "grey76"

    # Colored boxplot with quartile lines and y=0 reference
    ggplot(df_filtered, aes(x = Group, y = Score, fill = Group)) +
      geom_hline(yintercept = 0, linewidth = 0.4, linetype = "dashed", color = "black") +
      geom_boxplot(outlier.size = 0.5, color = "black", size = 0.3) +
      scale_fill_manual(values = col_used) +
      theme_bw(base_size = 10) +
      labs(title = paste0("nMOST Proteome Correlation GO – ", cluster_name),
           x = NULL, y = "Score") +
      theme(axis.text.x = element_text(angle = 90, hjust = 1),
            panel.grid = element_blank(),
            legend.position = "none")
  } else {
    stop("plot_type must be 'mean' or 'box'")
  }
}

## GO Cluster information:
# Cluster1: Chromosome, ribsosome
# Cluster2: Recycling endosome, vesicle membrane, early endosome membrane
# Cluster3: ER, ER lumen, mito
# Cluster4: Mito, mito matix 
# Cluster5: Lyso lumen, ER lumen, mito
# Cluster6: Cytoskeleton, actin cytoskeleton, focal adhesion
# Cluster7: late endosome, endosome, high-density lipoprotein particle 
# Cluster8: Autolysosome, lyososme, autophagosome
# Cluster9: Nucleus 
# Cluster10: Cytosol, centriolar satellite 
# Cluster11: Cytosol
# Cluster13: Peroxisome
# Cluster15: Plasma membrane raft 
# Cluster16: ER, MIto, Golgi membrane
# Cluster17: Transcription complex 
# Cluster18:  Membrane, golgi, late endosome, PM
  
# Call function to plot cluster # of interest 
HeLaClusterCorrplot <- HeLaClusterCorr(HeLaCrossOmeCorrProt_df_long, "Cluster 2", plot_type = "box")
HeLaClusterCorrplot


# Save as PDF
ggsave("/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/nMOST-nDIAcorrelation/nMOST_LSD_Corr_GOCluster2.pdf", HeLaClusterCorrplot, width = 4, height = 4, device = cairo_pdf)

```

#### VIb.  --- nMOST GO Signatures from select genotype over all GO classes ---
``` {r}
# Function to plot all cluster signatures for a specific genotype
HeLaGenotypeSignature <- function(HeLaCrossOmeCorrProt_df_long, gene_name = "CLN3") {
  HeLaCrossOmeCorrProt_df_long_filtered <- HeLaCrossOmeCorrProt_df_long %>%
    filter(Group == gene_name) %>%
    mutate(Cluster = as.character(Cluster))

  # Order clusters by mean score
  cluster_order <- HeLaCrossOmeCorrProt_df_long_filtered  %>%
    group_by(Cluster) %>%
    summarise(mean_score = mean(Score, na.rm = TRUE)) %>%
    arrange(mean_score) %>%
    pull(Cluster)

  HeLaCrossOmeCorrProt_df_long_filtered <- HeLaCrossOmeCorrProt_df_long_filtered %>%
    mutate(Cluster = factor(Cluster, levels = cluster_order))

  ggplot(HeLaCrossOmeCorrProt_df_long_filtered, aes(x = Cluster, y = Score)) +
    geom_hline(yintercept = 0, linewidth = 0.4, linetype = "dashed", color = "black") +
    geom_boxplot(fill = "grey70", color = "black", outlier.size = 0.5, size = 0.3) +
    theme_bw(base_size = 10) +
    labs(title = paste0("nMOST Proteome GO Correlation – ", gene_name),
         x = NULL, y = "Score") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1),
          panel.grid = element_blank())
}


HeLaGenotypeSignaturePlot <- HeLaGenotypeSignature(HeLaCrossOmeCorrProt_df_long, "GBA")
HeLaGenotypeSignaturePlot

# Save as PDF
ggsave("/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/nMOST-nDIAcorrelation/nMOST_LSD_CorrGenotype_GBA.pdf", HeLaGenotypeSignaturePlot, width = 4, height = 8, device = cairo_pdf)

```



# VII. iNeuron - Hela Proteome Correlations 
we do have nDIA data from iN and iDA neurons
we have nMOST data from HeLa 
can we calculate the cross correlation on the proteome wide bases across these three samples?
use only KOs that are present in all three samples
plot the outcome in cricros plot 

use complete_data_annotated_day50 and group into iN and iDA
read in HeLa nMOST file
- match KOs and only use the ones found in all df
- calculate pairwise correlation based on genes / protein IDs per genotype
- plot corr across genotypes in crircos plot (color based on R corr)
- also plot heatmaps of pairwise comparisons 

#### VIIa. --- Neuron–HeLa Proteome Correlation Analysis ---
```{r}
# Load libraries
library(tidyverse)
library(data.table)
library(pheatmap)
library(circlize)
library(RColorBrewer)
library(Cairo)

# -----------------------------
# I. Disease Class Definitions
# -----------------------------
disease_classes <- list(
  Sphigolipidoses = c("ARSA", "ASAH1", "GALC", "GBA1", "GLA", "GLB1", "GM2A", "HEXA", "HEXB", "PSAP", "SMPD1"),
  Mucopolysaccharidoses = c("GLB1", "ARSB", "GALNS", "GNS", "GUSB", "HGSNAT", "HYAL1", "IDS", "IDUA", "NAGLU", "SGSH"),
  Glycoproteinoses = c("AGA", "CTSA", "FUCA", "MAN2B1", "MANBA", "NAGA", "NEU1"),
  Neuronal.ceroid.lipofucinoses = c("PPT1", "CTSD", "GRN", "ATP13A2", "CTSF", "KCTD7", "TPP1", "CLN3", "DNAJC5", "CLN5", "CLN6", "MFSD8", "CLN8"),
  Integral.membrane.protein.disorders = c("ATP13A2", "CLN3", "CTNS", "LAMP2", "MCOLN1", "NPC1", "NPC2", "SCARB2", "SLC17A5"),
  PTM.defects = c("GNPTAB", "GNPTG", "SUMF1"),
  Lipid.storage.diseases = c("GAA", "LIPA")
)
disease_colors <- c(
  Sphigolipidoses = "#D53E4F", Mucopolysaccharidoses = "#F46D43",
  Glycoproteinoses = "#FDAE61", Neuronal.ceroid.lipofucinoses = "#FEE08B",
  Integral.membrane.protein.disorders = "#E6F598", PTM.defects = "#ABDDA4",
  Lipid.storage.diseases = "#66C2A5"
)
ko_to_class <- enframe(disease_classes) %>% unnest(value) %>% rename(KO = value, class = name)

# -----------------------------
# II. Data Preparation
# -----------------------------
neuron_proteome_wide <- complete_data_annotated_day50
HeLaWCnMOST_df <- read.csv("/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/HeLa_nMOSTWCprot.csv")

neuron_long <- neuron_proteome_wide %>%
  pivot_longer(-Genes, names_to = "sample_id", values_to = "log2_abundance") %>%
  filter(str_detect(sample_id, "log2_fold_change")) %>%
  mutate(
    genotype = str_extract(sample_id, "^[^_]+"),
    neuron = str_extract(sample_id, "_(iN|iDA)_") %>% str_remove_all("_")
  )

neuron_df <- neuron_long %>%
  filter(!is.na(log2_abundance)) %>%
  group_by(Genes, genotype, neuron) %>%
  summarise(mean_log2_abundance = mean(log2_abundance), .groups = "drop") %>%
  pivot_wider(names_from = neuron, values_from = mean_log2_abundance)

HeLa_long <- HeLaWCnMOST_df %>%
  rename(Genes = Gene.names) %>%
  pivot_longer(cols = ends_with(".KO"), names_to = "genotype", values_to = "hela_abundance") %>%
  mutate(genotype = str_remove(genotype, "\\.KO"))

merged_df <- inner_join(neuron_df, HeLa_long, by = c("Genes", "genotype"))

merged_wide <- merged_df %>%
  pivot_longer(c(iN, iDA), names_to = "neuron_type", values_to = "neuron_abundance") %>%
  mutate(sample = paste(genotype, neuron_type, sep = "_")) %>%
  select(Genes, sample, abundance = neuron_abundance) %>%
  bind_rows(
    merged_df %>%
      mutate(sample = paste0(genotype, "_HeLa")) %>%
      select(Genes, sample, abundance = hela_abundance)
  ) %>%
  group_by(Genes, sample) %>%
  summarise(abundance = mean(abundance, na.rm = TRUE), .groups = "drop") %>%
  pivot_wider(names_from = sample, values_from = abundance)

abundance_matrix <- merged_wide %>%
  column_to_rownames("Genes") %>%
  mutate(across(everything(), as.numeric)) %>%
  replace(is.na(.), 0) %>%
  as.matrix()

correlation_matrix_nMOSTnDIA <- cor(abundance_matrix, method = "pearson", use = "pairwise.complete.obs")

# -----------------------------
# III. Circos Plot Setup
# -----------------------------
sample_groups <- tibble(
  sample = colnames(correlation_matrix_nMOSTnDIA),
  group = case_when(
    str_detect(colnames(correlation_matrix_nMOSTnDIA), "_iN$") ~ "iN",
    str_detect(colnames(correlation_matrix_nMOSTnDIA), "_iDA$") ~ "iDA",
    str_detect(colnames(correlation_matrix_nMOSTnDIA), "_HeLa$") ~ "HeLa",
    TRUE ~ "Other"
  )
)

ordered_samples <- sample_groups %>% arrange(group, sample) %>% pull(sample)

# -----------------------------
# IV. Define Circos Plot Function
# -----------------------------
# Define global group color mapping
group_colors <- c("iN" = "dodgerblue", "iDA" = "#D53E4F", "HeLa" = "grey76")

# Define global sample color mapping for default fallback
sample_colors <- setNames(group_colors, names(group_colors))

# Define the plotting function
plot_dual_layer_circos <- function(link_df, title_text, output_path) {
  involved_samples <- unique(c(link_df$from, link_df$to))
  ordered_samples_local <- ordered_samples[ordered_samples %in% involved_samples]

  # KO class colors
  ko_labels <- str_extract(ordered_samples_local, "^[^_]+")
  sector_classes_local <- tibble(sample = ordered_samples_local, KO = ko_labels) %>%
    left_join(ko_to_class, by = "KO") %>%
    mutate(disease_color = disease_colors[class]) %>%
    replace_na(list(disease_color = "grey90"))

  disease_track_colors <- setNames(sector_classes_local$disease_color, sector_classes_local$sample)

  # Sample color mapping
  sample_colors_local <- setNames(group_colors[sample_groups$group[match(ordered_samples_local, sample_groups$sample)]],
                                  ordered_samples_local)

  pdf(output_path, width = 10, height = 12)
  circos.clear()
  circos.par(start.degree = 90, gap.degree = 4)

  chordDiagram(
    x = link_df,
    grid.col = sample_colors_local,
    col = colorRamp2(c(-1, 0, 1), c("blue", "white", "red"))(link_df$correlation),
    annotationTrack = "grid",
    transparency = 0,
    preAllocateTracks = list(
      list(track.height = 0.05),
      list(track.height = 0.03)
    ),
    order = ordered_samples_local
  )

  circos.trackPlotRegion(track.index = 1, panel.fun = function(x, y) {
    circos.text(CELL_META$xcenter, CELL_META$ylim[1] + mm_y(1),
                CELL_META$sector.index,
                facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5), cex = 0.6)
  }, bg.border = NA)

  circos.trackPlotRegion(track.index = 2, bg.col = sample_colors_local, panel.fun = function(x, y) {}, bg.border = NA)
  circos.trackPlotRegion(track.index = 3, bg.col = disease_track_colors, panel.fun = function(x, y) {}, bg.border = NA)

  grid.text(title_text, x = 0.5, y = 0.98, gp = gpar(fontsize = 12, fontface = "bold"))
  
  
  # Add correlation legend
cor_legend <- Legend(
  at = c(-0.5, -0.25, 0, 0.25, 0.5),
  col_fun = colorRamp2(c(-1, 0, 1), c("blue", "white", "red")),
  title = "Pearson r",
  direction = "horizontal",
  legend_width = unit(3, "cm")
)

draw(cor_legend, x = unit(0.5, "npc"), y = unit(0.02, "npc"), just = c("center", "bottom"))

  # Add celltype / diseaseclass legend
disease_legend <- Legend(
  labels = names(disease_colors),
  legend_gp = gpar(fill = disease_colors),
  title = "Disease Class",
  ncol = 2
)

draw(disease_legend, x = unit(1, "npc"), y = unit(0.02, "npc"), just = c("right", "bottom"))

  dev.off()
}

# -----------------------------
# V. Call Circos 
# -----------------------------
# Pairwise combinations (example)
pairwise_links <- expand.grid(from = colnames(correlation_matrix_nMOSTnDIA),
                              to = colnames(correlation_matrix_nMOSTnDIA),
                              stringsAsFactors = FALSE) %>%
  filter(from != to) %>%
  mutate(pair_id = pmap_chr(list(from, to), ~ paste(sort(c(..1, ..2)), collapse = "_"))) %>%
  distinct(pair_id, .keep_all = TRUE) %>%
  mutate(correlation = mapply(function(x, y) correlation_matrix_nMOSTnDIA[x, y], from, to))


# Identify inter-group correlations only
sample_groups <- data.frame(
  sample = colnames(correlation_matrix_nMOSTnDIA),
  group = case_when(
    str_detect(colnames(correlation_matrix_nMOSTnDIA), "_iN$")   ~ "iN",
    str_detect(colnames(correlation_matrix_nMOSTnDIA), "_iDA$")  ~ "iDA",
    str_detect(colnames(correlation_matrix_nMOSTnDIA), "_HeLa$") ~ "HeLa",
    TRUE ~ "Other"
  )
)

pairwise_links_inter <- pairwise_links %>%
  left_join(sample_groups, by = c("from" = "sample")) %>%
  rename(group_from = group) %>%
  left_join(sample_groups, by = c("to" = "sample")) %>%
  rename(group_to = group) %>%
  filter(group_from != group_to)  # Only inter-group comparisons


## plot function for both inter and intra correlations 
plot_dual_layer_circos(
  link_df = pairwise_links %>% filter(abs(correlation) > 0.05),
  title_text = "Neuron–HeLa Proteome Cross-Correlation",
  output_path = "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/nMOST-nDIAcorrelation/neuron_hela_circos_plot.pdf"
)



## plot only intra-celltype correlations:
plot_dual_layer_circos(
  link_df = pairwise_links_inter %>% filter(abs(correlation) > 0.05),
  title_text = "Inter-Group Neuron–HeLa Proteome Correlation",
  output_path = "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/nMOST-nDIAcorrelation/neuron_hela_circos_interonly.pdf"
)
dev.off()
```



#### VIIb. --- nMOST-nDIA correlation of select genotype 
```{r}
# Functions to plot circos plot of select genotype. Splits by pos / neg correlation 
## change inter_only from FALSE to TRUE to only plot inter-group links
## inter_only = TRUE: Filters only inter-group links (e.g. iN–HeLa, iDA–HeLa, iN–iDA)

circos_by_genotype <- function(ko,
                               pos_cut = 0.25,
                               neg_cut = -0.25,
                               out_dir = base_dir,
                               inter_only = TRUE) {
  # Create output directory if it doesn't exist
  if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)

  # 1. Find sample names matching the given KO
  ko_pat     <- paste0("^", ko, "_")
  ko_samples <- grep(ko_pat, colnames(correlation_matrix_nMOSTnDIA), value = TRUE)

  if (length(ko_samples) == 0) {
    stop("No samples matched the KO name ‘", ko, "’. Check spelling.")
  }

  # 2. Helper: Build link data frame based on correlation cutoff
  make_link_df <- function(cut_fun) {
    expand.grid(from = ko_samples,
                to   = colnames(correlation_matrix_nMOSTnDIA),
                stringsAsFactors = FALSE) |>
      dplyr::filter(from != to) |>
      dplyr::mutate(
        pair_id     = purrr::map2_chr(from, to, ~ paste(sort(c(.x, .y)), collapse = "_")),
        correlation = purrr::map2_dbl(from, to, ~ correlation_matrix_nMOSTnDIA[.x, .y])
      ) |>
      dplyr::filter(cut_fun(correlation)) |>
      dplyr::distinct(pair_id, .keep_all = TRUE) |>
      dplyr::select(-pair_id)
  }

  pos_links <- make_link_df(\(r) r >= pos_cut)
  neg_links <- make_link_df(\(r) r <= neg_cut)

  # 3. Optionally filter for inter-group links only
  if (inter_only) {
    pos_links <- pos_links |>
      dplyr::left_join(sample_groups, by = c("from" = "sample")) |>
      dplyr::rename(group_from = group) |>
      dplyr::left_join(sample_groups, by = c("to" = "sample")) |>
      dplyr::rename(group_to = group) |>
      dplyr::filter(group_from != group_to)

    neg_links <- neg_links |>
      dplyr::left_join(sample_groups, by = c("from" = "sample")) |>
      dplyr::rename(group_from = group) |>
      dplyr::left_join(sample_groups, by = c("to" = "sample")) |>
      dplyr::rename(group_to = group) |>
      dplyr::filter(group_from != group_to)
  }

  message(ko, ": ", nrow(pos_links), " positive; ",
              nrow(neg_links), " negative links kept")

  # 4. Define output file paths
  pos_file <- file.path(out_dir, paste0("circos_", ko, "_positive.pdf"))
  neg_file <- file.path(out_dir, paste0("circos_", ko, "_negative.pdf"))

  # 5. Plot
  if (nrow(pos_links) > 0) {
    plot_dual_layer_circos(
      link_df = pos_links,
      title_text = paste0(ko, " – positive r ≥ ", pos_cut),
      output_path = pos_file
    )
  }

  if (nrow(neg_links) > 0) {
    plot_dual_layer_circos(
      link_df = neg_links,
      title_text = paste0(ko, " – negative r ≤ ", neg_cut),
      output_path = neg_file
    )
  }
}



##### Call function block 
## Set output dir for plots / evaluations 
base_dir <- "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/nMOST-nDIAcorrelation/SingleGeno"

# Default thresholds (pos ≥ 0.25, neg ≤ –0.25)
circos_by_genotype("ASAH1")

# Relaxed threshold
circos_by_genotype("ASAH1", pos_cut = 0.05, neg_cut = -0.05)
```


#### VIIc. --- HeLa-nMOST - neuron-nDIA organelle correlation ---

##### VIIc1. --- Select organelle level ---
```{r}
# load libraries
library(dplyr)
library(tidyr)
library(pheatmap)
library(readr)
library(gridExtra)

## ─────────────────────────────────────────────────────────────
## 1.   Add annotations to HeLa-nMOST dataframe & save
## ─────────────────────────────────────────────────────────────
# use binary_matrix from IVa to add to HeLa-nMOST dataframe
# add to dataframe and save as .csv file 
HeLaWCnMOST_df_annotated <- HeLaWCnMOST_df %>%
  rename(Genes = 2) %>%
  left_join(binary_matrix, by = "Genes") %>%
  mutate(across(all_of(colnames(binary_matrix)[-1]), ~ ifelse(. == TRUE, TRUE, FALSE))) %>%
  replace(is.na(.), FALSE)

write.csv(HeLaWCnMOST_df_annotated,
          "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/nMOST-nDIAcorrelation/HeLaWCnMOST_annotated.csv",
          row.names = FALSE)


## ─────────────────────────────────────────────────────────────
## 2.   Define annotations to be calculated in the function below & define out_dir
## ─────────────────────────────────────────────────────────────

selected_annotations <- c(
  "EndoLyso", "SynGO", "Endo_iN_curated_Hundley",
  "Lysosome.Genes", "Presynaptic", "Postsynaptic",
  "EarlyEndosome", "RecyclingEndosome"
)

out_dir <- "/Users/felix/Dropbox (HMS)/Felix/Harvard/03_LSD-PD/Proteomics/d50_diff132/day50/nMOST-nDIAcorrelation/HeLa_Neuron_SelectAnnotation_comparisons"
dir.create(out_dir, showWarnings = FALSE, recursive = TRUE)


## ─────────────────────────────────────────────────────────────
## 3.   Function to calculate correlation for select annotation 
##      plots in pheatmap and saves as csv
## ─────────────────────────────────────────────────────────────
calculate_annotation_correlation_matrix <- function(annot_name, neuron_df, hela_df) {
  # Filter for genes in annotation
  genes <- neuron_df %>% filter(!!sym(annot_name) == TRUE) %>% pull(Genes)
  genes <- intersect(genes, hela_df$Genes)
  
  # Filter and prepare wide matrices
   neuron_mat <- neuron_df %>%
      filter(Genes %in% genes) %>%
      select(Genes, matches("^.*log2_fold_change.*")) %>%
      group_by(Genes) %>%
      summarise(across(everything(), mean, na.rm = TRUE), .groups = "drop") %>%
      column_to_rownames("Genes")
  
    hela_mat <- hela_df %>%
      filter(Genes %in% genes) %>%
      select(Genes, matches("\\.KO$")) %>%
      group_by(Genes) %>%
      summarise(across(everything(), mean, na.rm = TRUE), .groups = "drop") %>%
      column_to_rownames("Genes")

  # Keep only common genes
  common_genes <- intersect(rownames(neuron_mat), rownames(hela_mat))
  if (length(common_genes) < 5) {
    warning(paste("Too few genes for", annot_name))
    return(NULL)
  }

  neuron_mat <- neuron_mat[common_genes, ]
  hela_mat   <- hela_mat[common_genes, ]

  # Pearson correlation
  cor_mat <- cor(neuron_mat, hela_mat, method = "pearson", use = "pairwise.complete.obs")
  
  # Save CSV
  write.csv(cor_mat, file = file.path(out_dir, paste0("cor_", annot_name, ".csv")), quote = FALSE)
  
  ### Annotation for neuron columns
  celltype_vec <- ifelse(grepl("iN", rownames(cor_mat)), "iN",
                    ifelse(grepl("iDA", rownames(cor_mat)), "iDA", NA))
  annotation_row <- data.frame(CellType = factor(celltype_vec, levels = c("iN", "iDA")))
  rownames(annotation_row) <- rownames(cor_mat)
  annotation_colors <- list(CellType = c(iN = "grey40", iDA = "grey80"))
  
    
    # plot heatmaps 
  pheatmap::pheatmap(
    cor_mat,
    cluster_rows = TRUE,
    cluster_cols = TRUE,
    main = paste("Correlation:", annot_name),
    annotation_row = annotation_row,
    annotation_colors = annotation_colors,
    color = rev(RColorBrewer::brewer.pal(11, "RdYlBu")),
    fontsize     = 6,
    border_color = NA,
    cellheight = 8,
    cellwidth  = 8,
    filename = file.path(out_dir, paste0("cor_", annot_name, ".pdf")),
    width = 8, height = 8
  )
  
    return(cor_mat)
}


## ─────────────────────────────────────────────────────────────
## 4.   call function and execute  
## ─────────────────────────────────────────────────────────────
all_corrs <- lapply(selected_annotations, function(ann) {
  message("Processing: ", ann)
  calculate_annotation_correlation_matrix(ann, complete_data_annotated_day50, HeLaWCnMOST_df_annotated)
})
names(all_corrs) <- selected_annotations

```


##### VIIc2. --- Combined select organelle level ---
```{r}
## ─────────────────────────────────────────────────────────────
## 1.   Combine all genes from selected annotations
## ─────────────────────────────────────────────────────────────
combined_genes <- unique(unlist(lapply(selected_annotations, function(ann) {
  intersect(
    complete_data_annotated_day50 %>% filter(!!sym(ann) == TRUE) %>% pull(Genes),
    HeLaWCnMOST_df_annotated$Genes
  )
})))


## ─────────────────────────────────────────────────────────────
## 2. Prepare matrices for combined annotations
## ─────────────────────────────────────────────────────────────
# Neuron matrix: iN and iDA
neuron_mat_combined <- complete_data_annotated_day50 %>%
  filter(Genes %in% combined_genes) %>%
  select(Genes, matches("^.*log2_fold_change.*")) %>%
  group_by(Genes) %>%
  summarise(across(everything(), mean, na.rm = TRUE), .groups = "drop") %>%
  column_to_rownames("Genes")

# HeLa matrix
hela_mat_combined <- HeLaWCnMOST_df_annotated %>%
  filter(Genes %in% combined_genes) %>%
  select(Genes, matches("\\.KO$")) %>%
  group_by(Genes) %>%
  summarise(across(everything(), mean, na.rm = TRUE), .groups = "drop") %>%
  column_to_rownames("Genes")


## ─────────────────────────────────────────────────────────────
## 3. Match genes & calcualte correlations
## ─────────────────────────────────────────────────────────────
shared_genes <- intersect(rownames(neuron_mat_combined), rownames(hela_mat_combined))
neuron_mat_combined <- neuron_mat_combined[shared_genes, ]
hela_mat_combined   <- hela_mat_combined[shared_genes, ]

cor_mat_combined <- cor(neuron_mat_combined, hela_mat_combined, method = "pearson", use = "pairwise.complete.obs")
cor_mat_combined[!is.finite(cor_mat_combined)] <- 0



## ─────────────────────────────────────────────────────────────
## 4. Add back row annotations & plot heatmap
## ─────────────────────────────────────────────────────────────
# Row annotations for neurons
celltype_vec <- ifelse(grepl("iN", rownames(cor_mat_combined)), "iN",
                  ifelse(grepl("iDA", rownames(cor_mat_combined)), "iDA", NA))
annotation_row <- data.frame(CellType = factor(celltype_vec, levels = c("iN", "iDA")))
rownames(annotation_row) <- rownames(cor_mat_combined)

annotation_colors <- list(CellType = c(iN = "grey40", iDA = "grey80"))



# Plot heatmap
pheatmap::pheatmap(
  cor_mat_combined,
  cluster_rows = TRUE,
  cluster_cols = TRUE,
  main = "Combined Annotation Correlation",
  color = rev(RColorBrewer::brewer.pal(11, "RdYlBu")),
  fontsize = 6,
  border_color = NA,
  cellheight = 8,
  cellwidth = 8,
  annotation_row = annotation_row,
  annotation_colors = annotation_colors,
  filename = file.path(out_dir, "cor_combined_annotations.pdf"),
  width = 8, height = 8
)
```



